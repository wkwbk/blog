[{"title":"test","url":"/posts/d87f7e0c/","content":"\n  80d31aac00003aec38ee25003a6db689128da61ff149524bf3d964a09d3449367c085067c4e06bf3db44ae2f281f36abd2a9e841d96718b79c6e137f46cf376d0ab04d0a9cd2464e42482672d55d7e51\n  \n    \n      \n      \n        嗨，在这里输入密码。\n      \n    \n  \n\n"},{"title":"Debian 安装 JDK","url":"/posts/372c544f/","content":"Java 是用于构建各种应用程序和系统的最流行的编程语言之一。Java 可以在所有主流的操作系统和设备上运行。\n\n\n\n下载 JDKJDK8\nJDK11\n下载前需要登录 Oracle\n安装 JDK上传下载好的 JDK(.tar.gz) 文件到服务器\n解压至当前目录\ntar zxvf jdk-linux-x64.tar.gz\n\n将解压后的目录（例如 jdk1.8.0_361）移动至 &#x2F;usr&#x2F;lib，并改个简单好记的文件夹名\nmv jdk1.8.0_361/ /usr/lib/jdk8\n\n修改环境变量修改 profile 文件\nvi /etc/profile\n\n添加以下代码到最后\n# jdk8 setting customexport JAVA_HOME=/usr/lib/jdk8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n\n刷新环境变量\nsource /etc/profile\n\n测试 JDK 是否配置成功# 输入java# 或者javac# 查看 JDK 版本java -version\n","categories":["备忘录"],"tags":["Linux","JDK"]},{"title":"Docker 管理工具 Portainer","url":"/posts/14069f3b/","content":"Portainer 是一款免费、开源的 Docker 的图形化管理工具，其能够提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm 集群和服务等集中管理和操作、登录用户管理和控制等功能。\n\n\n\n安装 Docker更新、安装必备软件apt-get update &amp;&amp; apt-get install -y wget vim\n\nDocker 安装wget -qO- get.docker.com | bash# orcurl -sSL get.docker.com | sh\n\n查看 Docker 版本docker -v\n\n开机自动启动systemctl enable docker\n\n卸载 Dockersudo apt-get purge docker-ce docker-ce-cli containerd.io\n\nsudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd\n\nDocker-compose 安装curl -L &quot;https://github.com/docker/compose/releases/download/v2.11.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose --version\n\nDocker 基本命令docker ps -a #查看运行的镜像进程docker stop &lt;CONTAINER ID&gt; #停止该镜像进程docker start &lt;CONTAINER ID&gt; #启动该镜像进程docker rm &lt;CONTAINER ID&gt; #卸载镜像docker images #查看当前 Docker 的镜像 IMAGE IDdocker rmi &lt;IMAGE ID&gt; #删除镜像\n\n修改 Docker 配置限制日志文件大小，防止 Docker 日志塞满硬盘\ncat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123;    &quot;log-driver&quot;: &quot;json-file&quot;,    &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;20m&quot;,        &quot;max-file&quot;: &quot;3&quot;    &#125;&#125;EOF\n\n然后重启 Docker 服务\nsystemctl restart docker\n\n安装 Portainer查看镜像docker search portainer\n\n拉取镜像docker pull portainer/portainer\n\n启动 Portainerdocker run --name portainer --restart=always --privileged=true \\    -p 8000:8000 \\    -p 9000:9000 \\    -v /var/run/docker.sock:/var/run/docker.sock \\    -v /root/data/docker/portainer/data/:/data \\    -v /root/data/docker/portainer/public/:/public \\    -d portainer/portainer-ce:latest\n\n\n-p 参数映射容器端口到本地 [服务器端口 : 容器内部端口]-v 参数持久化容器目录到本地 [服务器路径 : 容器内部路径]9000 端口为 web 管理界面端口，浏览器访问运行Portainer的Docker引擎的端口9000-v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock 默认配置 portainer 所在服务器 Docker 端点该语句用宿主机 9000 端口关联容器中的 9000 端口，并给容器起名为 portainer。执行完该命令之后，使用该机器 IP:PORT 即可访问 Portainer\n\n在 Portainer 添加其他服务器 Docker 节点\n在需要添加到 Portainer 的服务器中安装 Docker\n安装完成 Docker 后，修改 vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service 暴露 docker api 接口\n\n# 命令查看 docker.service 文件所在路径systemctl status docker.service# 编辑 docker.service 文件nano /lib/systemd/system/docker.service\n\n修改配置项ExecStart中的值为：\nExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H fd:// --containerd=/run/containerd/containerd.sock\n\n重启 Docker 服务\n# 重新加载服务配置文件systemctl daemon-reload# 重启 Docker 服务systemctl restart docker\n\n在 Portainer 所在服务器测试是否可连接目标服务器 Docker Api\n# 格式 docker -H [目标服务器IP/公网IP]:[2375/外网IP映射的端口号] infodocker -H 0.0.0.0:2375 info# 出现以下内容则配置成功WARNING: API is accessible on http://0.0.0.0:2375 without encryption.         Access to the remote API is equivalent to root access on the host. Refer         to the &#x27;Docker daemon attack surface&#x27; section in the documentation for         more information: https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface\n\n完成以上内容后即可在 Portainer 的 “端点&#x2F;EndPoint” 菜单中点击 “添加端点&#x2F;Add EndPoint”, 来添加目标服务器 Docker节点\n","categories":["备忘录"],"tags":["Docker","Portainer"]},{"title":"Java 环境变量配置","url":"/posts/aaf29273/","content":"本文介绍如何在 Windows 中配置 Java 环境变量。\n\n\n\n下载安装包，安装 JDK 到本地电脑中。\n我的电脑-&gt;右键-&gt;属性-&gt;左侧菜单-&gt;高级系统设置-&gt;环境变量\n系统变量-&gt;新建\n变量名：JAVA_HOME变量值：C:\\Programs\\Java\\jdk1.8.0_341 #变量值为 JDK 安装路径，根据自己安装路径更改\n\n系统变量-&gt;打开 Path 变量-&gt;新建\n#添加以下两个变量值%JAVA_HOME%\\bin%JAVA_HOME%\\jre\\bin\n\n系统变量-&gt;新建\n变量名：CLASSPATH变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; #不要漏了开头那一点\n","categories":["备忘录"],"tags":["Java"]},{"title":"Oracle Cloud 小鸡设置","url":"/posts/fc1ccebf/","content":"之前通过 F12 的方法，有幸喜提乌龟壳小鸡两只，在这里记录一下新开系统的一些设置\n\n\n\n更新系统apt update &amp;&amp; apt upgrade -y\n\n改为root密码登陆echo root:密码 |chpasswd rootsed -i &#x27;s/^#\\?PermitRootLogin.*/PermitRootLogin yes/g&#x27; /etc/ssh/sshd_config;sed -i &#x27;s/^#\\?PasswordAuthentication.*/PasswordAuthentication yes/g&#x27; /etc/ssh/sshd_config;systemctl restart sshd\n\n开启BBR#修改系统变量echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf#保存生效sysctl -p#查看内核是否已开启BBRlsmod | grep bbr#显示如下，即成功tcp_bbr                20480  2\n\n放行全部端口（重启失效）iptables -P INPUT ACCEPTiptables -P FORWARD ACCEPTiptables -P OUTPUT ACCEPTiptables -Fiptables-save\n\n持续化规则（重启不失效）#安装iptables-persistentapt install iptables-persistent#永久保存规则netfilter-persistent savenetfilter-persistent reload\n\n\n对于关闭防火墙更暴力点的方法，可以选择如下两种\n\nrm -rf /etc/iptables &amp;&amp; reboot或rm -rf /etc/iptables/rules.v4rm -rf /etc/iptables/rules.v6reboot\n\n同时你也需要进入后台配置一下入站规则，我是开放的所有协议\nDD 重装系统下方演示为 Debian 10bash &lt;(wget --no-check-certificate -qO- &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27;) -d 10 -v 64 -a -firmware -p &lt;password&gt; -port &lt;port&gt;# 将&lt;password&gt;替换成自定义的密码# 将&lt;port&gt;替换成自定义的端口号，-port 参数去掉则默认为 22 端口# -d 表示 Debian 系统，可换成 -u 表示 Ubuntu 系统# 10 表示系统版本号，Debian可换成 [7, 8, 9, 10, 11]# Ubuntu 可换成 [14.04, 16.04, 18.04, 20.04]\n\nDD 后添加 ipv6 方法#找到/etc/network/interfaces#在这个文件最下面添加一行iface &lt;设备名&gt; inet6 dhcp#将&lt;设备名&gt;替换成对应的设备名称，设备名可以在 allow-hotplug 那里找到# 重启\n","categories":["备忘录"],"tags":["VPS"]},{"title":"pip 使用国内镜像源","url":"/posts/dc94bb02/","content":"默认情况下 pip 使用的是国外的镜像，在下载的时候速度非常慢，本文我们介绍使用国内清华大学的源。\n\n\n\n我们可以直接在 pip 命令中使用 -i 参数来指定镜像地址，例如：\npip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n以上命令使用清华镜像源安装 numpy 包。这种只对当前安装命令有用，如果需要全局修改，则需要修改配置文件。\nWindows 配置方法你需要在当前用户目录下的 pip 文件夹中创建一个 pip.ini 文件（例如：C:\\Users\\用户名\\pip\\pip.ini），然后在 pip.ini 文件中输入以下内容：\n[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = pypi.tuna.tsinghua.edu.cn\n\nLinux&#x2F;Mac os 配置方法Linux&#x2F;Mac os 环境中，配置文件位置在 ~&#x2F;.pip&#x2F;pip.conf（如果不存在创建该目录和文件）：\nmkdir ~/.pip\n\n打开配置文件 ~&#x2F;.pip&#x2F;pip.conf，修改如下：\n[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn\n\n查看镜像地址：\n$ pip3 config list   global.index-url=&#x27;https://pypi.tuna.tsinghua.edu.cn/simple&#x27;install.trusted-host=&#x27;https://pypi.tuna.tsinghua.edu.cn&#x27;\n\n可以看到已经成功修改了镜像。\n其他国内镜像源中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple豆瓣：http://pypi.douban.com/simple/阿里云：http://mirrors.aliyun.com/pypi/simple/  \n常用 pip 命令# pip 升级pip install --upgrade pip# 或者python -m pip install --upgrade pip# 查看已安装的包pip list# 包安装pip install [包名]# 查看包的安装位置pip show [包名]# 包卸载pip uninstall [包名]# 查看可以升级的包pip list -o# 包升级pip install -U [包名]# 包搜索pip search [搜索关键字]# 本地包安装pip install [目录]/[文件名]\n","categories":["备忘录"],"tags":["pip","镜像源"]},{"title":"个人常用脚本及指令备份","url":"/posts/541785a9/","content":"一些常用的 Shell 脚本。\n\n\n\ndocker 搭建 socks5# 指定密码(建议)docker run -d --name socks5 -p 10808:1080 -e PROXY_USER=用户名 -e PROXY_PASSWORD=密码 --restart=always serjs/go-socks5-proxy# 不指定密码docker run -d --name socks5 -p 10808:1080 --restart=always serjs/go-socks5-proxy\n\n10808:1080 #把 docker 的 1080 端口映射到 VPS 的 10808 端口PROXY_USER #用户连接的用户名，不指定默认为无认证PROXY_PASSWORD #用户连接的密码，不指定默认为无密码\n\n自定义测速脚本用于对国外 vps 配置以及网络测试\nbash &lt;(curl -Lso- https://git.io/superbench)\n\n一键 DD 网络重装脚本wget --no-check-certificate -O AutoReinstall.sh https://git.io/AutoReinstall.sh &amp;&amp; bash AutoReinstall.shCentOS：Pwd@CentOS其他 Linux 系统：Pwd@Linux系统DD包下载：https://dd.1234234.xyz/\n\nDebian&#x2F;Ubuntu 开启 BBR# 修改系统变量echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf# 保存生效sysctl -p# 查看内核是否已开启BBRlsmod | grep bbr# 显示如下，即成功tcp_bbr                20480  2\n\nbbr&#x2F;bbrplus&#x2F;锐速内核安装脚本# 卸载内核wget -N --no-check-certificate &quot;https://github.000060000.xyz/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh# 或wget -O tcp.sh &quot;https://git.io/coolspeeda&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh# 不卸载内核wget -N --no-check-certificate &quot;https://github.000060000.xyz/tcpx.sh&quot; &amp;&amp; chmod +x tcpx.sh &amp;&amp; ./tcpx.sh# 或wget -O tcpx.sh &quot;https://git.io/JYxKU&quot; &amp;&amp; chmod +x tcpx.sh &amp;&amp; ./tcpx.sh\n\n服务器状态监控# 海外curl -L https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh  -o nezha.sh &amp;&amp; chmod +x nezha.sh./nezha.sh# 大陆curl -L https://cdn.jsdelivr.net/gh/naiba/nezha@master/script/install.sh -o nezha.sh &amp;&amp; chmod +x nezha.shCN=true ./nezha.sh\n\n宝塔挂载数据盘https://www.bt.cn/bbs/thread-3187-1-1.html安装面板https://www.bt.cn/bbs/thread-19376-1-1.html卸载面板https://www.bt.cn/bbs/thread-9043-1-1.html\n\n宝塔秒级监控#!/bin/bashPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHstep=1for (( i = 0; i &lt; 60; i=(i+step) )); docurl -sS --connect-timeout 10 -m 60 &#x27;网址&#x27;echo &quot;----------------------------------------------------------------------------&quot;endDate=`date +&quot;%Y-%m-%d %H:%M:%S&quot;`echo &quot;[$endDate] OK&quot;echo &quot;----------------------------------------------------------------------------&quot;sleep $stepdoneexit 0\n\nScreen# 新建 i 窗口screen -S i# 查看所有窗口screen -ls# 接入 i 窗口screen -r i# 关闭 i 窗口screen -X -S i quit# 结束已死进程screen -wipe\n\nGit# 配置用户名邮箱git config --global user.name “wkwbk”git config --global user.email “XXXXXX@qq.com”# 克隆远程仓库git clone https://github.com/wkwbk/wkwbk.github.io.git# 添加当前目录文件git add .# 提交说明git commit -m &#x27;lisir.me&#x27;# 更新到仓库git push origin main\n\n待更新、、、","categories":["备忘录"],"tags":["常用命令"]},{"title":"使用 WSL 在 Windows 上安装 Linux","url":"/posts/ff809430/","content":"https://github.com/wsldl-pg/CentWSLhttps://github.com/mishamosher/CentOS-WSLhttps://github.com/yosukes-dev/RHWSL\n\n\n\n先决条件必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11，检查 Windows 版本及内部版本号：按 Windows 徽标键 + R，然后键入“winver”，选择“确定”\n需要在BIOS中开启虚拟化技术，检查是否启用虚拟化：同时按住 CTRL、Shift 和 ESC 键打开任务管理器，选择“性能”&gt;“CPU”\n启用 Windows 子系统：“控制面板”&gt;“程序和功能”&gt;“启用或关闭 Windows 功能”&gt;勾选“适用于 Linux 的 Windows 子系统”\nWSL 的基本命令# 安装 WSL 命令wsl --install# 更新 WSLwsl --update# 检查正在运行的 WSL 版本wsl -l -v# 检查 WSL 状态wsl --status# 关闭wsl --shutdown\n\n设置WSL的默认版本wsl --set-default-version &lt;Version&gt;# 若要将默认版本设置为 WSL 1 或 WSL 2，将 &lt;Version&gt; 替换为 1 或 2。# 例如 wsl --set-default-version 2\n\n设置默认 Linux 发行版wsl --set-default &lt;DistributionName&gt;# 将 &lt;DistributionName&gt; 替换为要使用的 Linux 发行版的名称。# 例如 wsl --set-default CentOS8\n\n要设置与 wsl 命令一起使用的默认 Linux 发行版wsl --setdefault &lt;DistributionName&gt;# 将 &lt;DistributionName&gt; 替换为要使用的 Linux 发行版的名称。\n\n将 WSL 版本设置为 1 或 2wsl --set-version &lt;DistributionName&gt; &lt;Version&gt;# 若要指定运行 Linux 发行版的 WSL 版本# 将 &lt;DistributionName&gt; 替换为 Linux 发行版的名称，并将 &lt;Version&gt; 替换为 1 或 2。# 例如 wsl --set-version CentOS8 2 会将 CentOS8 发行版设置为使用 WSL 2\n\n更改发行版的默认用户&lt;DistributionName&gt; config --default-user &lt;Username&gt;# 更改用于发行版登录的默认用户。 用户必须已经存在于发行版中才能成为默认用户。# 例如 CentOS8 config --default-user root 会将 CentOS8 发行版的默认用户更改为“root”用户。\n\n其他命令# 关闭子系统net stop LxssManager# 终止子系统wsl --terminate &lt;DistributionName&gt;# 注销或卸载子系统wsl --unregister &lt;DistributionName&gt;# 导出系统镜像wsl --export &lt;DistributionName&gt; &lt;镜像存放路径&gt;# 将 &lt;DistributionName&gt; 替换为要使用的 Linux 发行版的名称。\n\n由于是最小安装，一些常用的命令没有，无法使用，可以使用 yum 命令进行安装，以方便使用yum -y update #更新系统中已有的软件包yum -y install gcc gcc-c++ make wget #安装gcc、gcc+、wget等yum -y install openssh-clients openssh-server #安装ssh相关yum -y install vim #安装vim编辑器yum -y install tar #安装压缩解压缩工具yum -y install net-tools #安装网络工具yum -y install ncurses #字符终端处理库\n\n解决 Centos8 yum 官方源下线后无法使用问题# 进入配置文件夹\nmv /etc/yum.repos.d/ /etc/yum.repos.d_bak &amp;&amp; mkdir /etc/yum.repos.d/\nwget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\n\n# 如果你没有安装wget，也可以用下面命令\ncurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\n\n# 运行 dnf makecache 生成缓存\ndnf makecache\n\n","categories":["备忘录"],"tags":["Linux","WSL"]},{"title":"各 Linux 发行版修改镜像源","url":"/posts/d7a91b5f/","content":"Linux 系统安装完后软件源一般都是国外服务器，在国内特别慢，这时候就需要更换国内的镜像源。本文介绍如何给 Centos、Ubuntu、Debian、Fedora、OpenSUSE、FreeBSD 系统更换软件源。\n\n\n\nCentos\n备份\n mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n\n更换源\n 下载新的 CentOS-Base.repo 到 &#x2F;etc&#x2F;yum.repos.d&#x2F;\n wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#或者curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n\n\n注意：http://mirrors.aliyun.com/repo/Centos-7.repo 中的 7 改为自己的 Centos 版本号，比如 Centos 8 就是 http://mirrors.aliyun.com/repo/Centos-8.repo\n\n\n然后运行 yum makecache 生成缓存\n yum makecache\n\nUbuntu\n备份\n cp /etc/apt/sources.list /etc/apt/sources.list.bak\n\n更换源\n # 使用 nano 打开文本nano /etc/apt/sources.list\n\n 删除原来文件里的内容，将下面其中一个源复制进去，然后保存。\n 清华源：\n deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n\n 阿里源：\n deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\n\n更新\n apt update\n\n 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。\n apt -f install\n\n 更新软件\n apt upgrade\n\nDebian\n备份\n # 将以前的源备份一下，以防以后可以用的cp /etc/apt/sources.list /etc/apt/sources.list.bak\n\n更换源\n 使用 nano 编辑 &#x2F;etc&#x2F;apt&#x2F;sources.list 文件\n nano /etc/apt/sources.list\n\n 加入如下内容：\n deb http://mirrors.ustc.edu.cn/debian stable main contrib non-free# deb-src http://mirrors.ustc.edu.cn/debian stable main contrib non-freedeb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free# deb-src http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free    # deb http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free# deb-src http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free\n\n更新\n apt update\n\n 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。\n apt -f install\n\n 更新软件\n apt upgrade\n\nOpenSUSE\n禁用原有软件源\n sudo zypper mr -da\n\n添加科大镜像源\n sudo zypper ar -fc https://mirrors.ustc.edu.cn/opensuse/distribution/leap/42.1/repo/oss USTC:42.1:OSSsudo zypper ar -fc https://mirrors.ustc.edu.cn/opensuse/distribution/leap/42.1/repo/non-oss USTC:42.1:NON-OSSsudo zypper ar -fc https://mirrors.ustc.edu.cn/opensuse/update/leap/42.1/oss USTC:42.1:UPDATE-OSSsudo zypper ar -fc https://mirrors.ustc.edu.cn/opensuse/update/leap/42.1/non-oss USTC:42.1:UPDATE-NON-OSS\n\n手动刷新软件源\n sudo zypper ref\n\n更新系统\n sudo zypper up\n\nFreeBSD\n修改 pkg 源\n mkdir -p /usr/local/etc/pkg/reposvim /usr/local/etc/pkg/repos/FreeBSD.conf# content of FreeBSD.confFreeBSD: &#123;    url: &quot;pkg+http://mirrors.ustc.edu.cn/freebsd-pkg/$&#123;ABI&#125;/quarterly&quot;,&#125;\n\n修改 ports 源\n vim /etc/make.conf# content of make.confFETCH_CMD=axel -n 10 -aDISABLE_SIZE=yesMASTER_SITE_OVERRIDE?=http://mirrors.ustc.edu.cn/freebsd-ports/distfiles/$&#123;DIST_SUBDIR&#125;/\n\n修改 portsnap 源\n vim /etc/portsnap.conf# content of porsnap.confSERVERNAME=porsnap.tw.freebsd.org\n\n国内开源镜像站大学类\n清华大学：https://mirrors.tuna.tsinghua.edu.cn/ (推荐)\n中国科学技术大学：https://mirrors.ustc.edu.cn/ (推荐)\n浙江大学：http://mirrors.zju.edu.cn/\n兰州大学：http://mirror.lzu.edu.cn/\n大连理工大学：http://mirror.dlut.edu.cn/\n东北大学：http://mirror.neu.edu.cn/\n大连东软信息学院：http://mirrors.neusoft.edu.cn/\n\n公司类\n阿里云开源镜像：http://mirrors.aliyun.com/ (推荐)\n网易开源镜像站：http://mirrors.163.com/\n搜狐开源镜像站：http://mirrors.sohu.com/\n\nPyPi 镜像\n豆瓣：https://pypi.doubanio.com/ (推荐)\n\n","categories":["备忘录"],"tags":["Linux","镜像源"]},{"title":"哪吒监控透明主题","url":"/posts/8f89fbd6/","content":"哪吒面板自定义透明主题\n\n\n\n哪吒监控https://github.com/naiba/nezha\n主题截图https://nz.wkwbk.cn\n主题演示https://nz.wkwbk.cn\n主题代码&lt;!--引入字体，全局字体使用--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://npm.elemecdn.com/lxgw-wenkai-webfont@1.1.0/lxgwwenkai-regular.css&quot; /&gt;&lt;style&gt;  /* 屏幕适配 */  @media only screen and (min-width: 1200px) &#123;    .ui.container &#123;      width: 80% !important;    &#125;  &#125;  @media only screen and (max-width: 767px) &#123;    .ui.card &gt; .content &gt; .header:not(.ui),    .ui.cards &gt; .card &gt; .content &gt; .header:not(.ui) &#123;      margin-top: 0.4em !important;    &#125;  &#125;  /* 整体图标 */  i.icon &#123;    color: #000;    width: 1.2em !important;  &#125;  /* 背景图片 */  body &#123;    content: &quot; &quot; !important;    background: fixed !important;    z-index: -1 !important;    top: 0 !important;    right: 0 !important;    bottom: 0 !important;    left: 0 !important;    background-position: top !important;    background-repeat: no-repeat !important;    background-size: cover !important;    background-image: url(https://img.wkwbk.eu.org/i/WP/PC/058.jpg) !important;    font-family: &quot;LXGW WenKai&quot; !important;  &#125;  /* 导航栏 */  .ui.large.menu &#123;    border: 0 !important;    border-radius: 0px !important;    background-color: rgba(255, 255, 255, 55%) !important;  &#125;  /* 首页按钮 */  .ui.menu .active.item &#123;    background-color: transparent !important;  &#125;  /* 导航栏下拉框 */  .ui.dropdown .menu &#123;    border: 0 !important;    border-radius: 0 !important;    background-color: rgba(255, 255, 255, 80%) !important;  &#125;  /* 登陆按钮 */  .nezha-primary-btn &#123;    background-color: transparent !important;    color: #000 !important;  &#125;  /* 大卡片 */  #app .ui.fluid.accordion &#123;    background-color: #fbfbfb26 !important;    border-radius: 0.6rem !important;  &#125;  /* 小卡片 */  .ui.four.cards &gt; .card &#123;    border-radius: 0.6rem !important;    background-color: #fafafaa3 !important;  &#125;  .status.cards .wide.column &#123;    padding-top: 0 !important;    padding-bottom: 0 !important;    height: 3.3rem !important;  &#125;  .status.cards .three.wide.column &#123;    padding-right: 0rem !important;  &#125;  .status.cards .wide.column:nth-child(1) &#123;    margin-top: 2rem !important;  &#125;  .status.cards .wide.column:nth-child(2) &#123;    margin-top: 2rem !important;  &#125;  .status.cards .description &#123;    padding-bottom: 0 !important;  &#125;  /* 小鸡名 */  .status.cards .flag &#123;    margin-right: 0.5rem !important;  &#125;  /* 弹出卡片图标 */  .status.cards .header &gt; .info.icon &#123;    margin-right: 0 !important;  &#125;  .nezha-secondary-font &#123;    color: #21ba45 !important;  &#125;  /* 进度条 */  .ui.progress &#123;    border-radius: 50rem !important;  &#125;  .ui.progress .bar &#123;    min-width: 1.8em !important;    border-radius: 15px !important;    line-height: 1.65em !important;  &#125;  .ui.fine.progress &gt; .bar &#123;    background-color: #21ba45 !important;  &#125;  .ui.progress &gt; .bar &#123;    background-color: #000 !important;  &#125;  .ui.progress.fine .bar &#123;    background-color: #21ba45 !important;  &#125;  .ui.progress.warning .bar &#123;    background-color: #ff9800 !important;  &#125;  .ui.progress.error .bar &#123;    background-color: #e41e10 !important;  &#125;  .ui.progress.offline .bar &#123;    background-color: #000 !important;  &#125;  /* 上传下载 */  .status.cards .outline.icon &#123;    margin-right: 1px !important;  &#125;  i.arrow.alternate.circle.down.outline.icon &#123;    color: #21ba45 !important;  &#125;  i.arrow.alternate.circle.up.outline.icon &#123;    color: red !important;  &#125;  /* 弹出卡片小箭头 */  .ui.right.center.popup &#123;    margin: -3px 0 0 0.914286em !important;    -webkit-transform-origin: left 50% !important;    transform-origin: left 50% !important;  &#125;  .ui.bottom.left.popup &#123;    margin-left: 1px !important;    margin-top: 3px !important;  &#125;  .ui.top.left.popup &#123;    margin-left: 0 !important;    margin-bottom: 10px !important;  &#125;  .ui.top.right.popup &#123;    margin-right: 0 !important;    margin-bottom: 8px !important;  &#125;  .ui.left.center.popup &#123;    margin: -3px 0.91428571em 0 0 !important;    -webkit-transform-origin: right 50% !important;    transform-origin: right 50% !important;  &#125;  .ui.right.center.popup:before,  .ui.left.center.popup:before &#123;    border: 0px solid #fafafaeb !important;    background: #fafafaeb !important;  &#125;  .ui.top.popup:before &#123;    border-color: #fafafaeb transparent transparent !important;  &#125;  .ui.popup:before &#123;    border-color: #fafafaeb transparent transparent !important;  &#125;  .ui.bottom.left.popup:before &#123;    border-radius: 0 !important;    border: 1px solid transparent !important;    border-color: #fafafaeb transparent transparent !important;    background: #fafafaeb !important;    -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important;    box-shadow: 0px 0px 0 0 #fafafaeb !important;    -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;  &#125;  .ui.bottom.right.popup:before &#123;    border-radius: 0 !important;    border: 1px solid transparent !important;    border-color: #fafafaeb transparent transparent !important;    background: #fafafaeb !important;    -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important;    box-shadow: 0px 0px 0 0 #fafafaeb !important;    -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;  &#125;  .ui.top.left.popup:before &#123;    border-radius: 0 !important;    border: 1px solid transparent !important;    border-color: #fafafaeb transparent transparent !important;    background: #fafafaeb !important;    -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important;    box-shadow: 0px 0px 0 0 #fafafaeb !important;    -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;  &#125;  .ui.top.right.popup:before &#123;    border-radius: 0 !important;    border: 1px solid transparent !important;    border-color: #fafafaeb transparent transparent !important;    background: #fafafaeb !important;    -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important;    box-shadow: 0px 0px 0 0 #fafafaeb !important;    -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;  &#125;  .ui.left.center.popup:before &#123;    border-radius: 0 !important;    border: 1px solid transparent !important;    border-color: #fafafaeb transparent transparent !important;    background: #fafafaeb !important;    -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important;    box-shadow: 0px 0px 0 0 #fafafaeb !important;    -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;  &#125;  /* 弹出卡片 */  .status.cards .ui.content.popup &#123;    min-width: 20rem !important;    line-height: 2rem !important;    border-radius: 0.6rem !important;    border: 1px solid transparent !important;    background-color: #fafafaeb !important;    font-family: &quot;LXGW WenKai&quot; !important;  &#125;  .ui.content &#123;    margin: 0 !important;    padding: 1em !important;  &#125;  /* 服务页 */  .ui.table &#123;    background: RGB(225, 225, 225, 0.6) !important;  &#125;  .ui.table thead th &#123;    background: transparent !important;  &#125;  /* 服务页进度条 */  .service-status .good &#123;    background-color: #21ba45 !important;  &#125;  .service-status .danger &#123;    background-color: red !important;  &#125;  .service-status .warning &#123;    background-color: orange !important;  &#125;  /* 版权 */  .ui.inverted.segment,  .ui.primary.inverted.segment &#123;    color: #000 !important;    font-weight: bold !important;    background-color: #fafafaa3 !important;  &#125;&lt;/style&gt;&lt;!--Logo和版权--&gt;&lt;script&gt;  window.onload = function () &#123;    var avatar = document.querySelector(&quot;.item img&quot;);    var footer = document.querySelector(&quot;div.is-size-7&quot;);    footer.innerHTML = &quot;VPS监控面板&quot;;    footer.style.visibility = &quot;visible&quot;;    avatar.src = &quot;https://img.wkwbk.eu.org/i/favicon.png&quot;;    avatar.style.visibility = &quot;visible&quot;;  &#125;;&lt;/script&gt;&lt;!--禁止右键--&gt;&lt;script type=&quot;text/javascript&quot;&gt;  document.oncontextmenu = function (e) &#123;    return false;  &#125;;&lt;/script&gt;\n","categories":["备忘录"],"tags":["哪吒面板"]},{"title":"宝塔官方安装脚本","url":"/posts/f16d52ba/","content":"宝塔面板是一款服务器管理软件，支持 Windows 和 Linux 系统，可以通过 Web 端轻松管理服务器，提升运维效率。\n\n\n\n开始使用 SSH 连接工具，如堡塔 SSH 终端连接到您的 Linux 服务器后，挂载磁盘，根据系统执行相应命令开始安装（大约 2 分钟完成面板安装）\n官网\n国内版\n\n国际版\n\n\nCentos安装命令# 国内版yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh\n\n# 国际版yum install -y wget &amp;&amp; wget -O install.sh http://www.aapanel.com/script/install_6.0_en.sh &amp;&amp; bash install.sh\n\nUbuntu&#x2F;Deepin安装命令# 国内版wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh\n\n# 国际版wget -O install.sh http://www.aapanel.com/script/install-ubuntu_6.0_en.sh &amp;&amp; sudo bash install.sh\n\nDebian安装命令# 国内版wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh\n\n# 国际版wget -O install.sh http://www.aapanel.com/script/install-ubuntu_6.0_en.sh &amp;&amp; bash install.sh\n","categories":["备忘录"],"tags":["宝塔面板"]},{"title":"打包解压查看 ASAR 文件","url":"/posts/805cd855/","content":"npm 是 nodejs 的包管理工具，我们后续需要通过 npm 安装 asar，因此需要先安装 npm。如果你的电脑之前已经安装了 nodejs 最新版，那么 nodejs 也就为你自动安装了 npm。\n\n\n\n确定已正确安装 NPM可以通过 npm -v 指令是否可以返回版本号来确定是否已经正确安装了 npm。\n全局环境安装 ASAR# 安装命令npm install -g asar# 或者cnpm install -g asar# 查看版本，返回版本号来确定已经正确安装 ASARasar -V\n\n解压缩 ASAR 文件在 asar 文件所在的根目录执行下面的命令\nasar extract app.asar ./\n\nasar extrct 指令有两个参数:\n\n第一个是需要解压缩的 asar 文件名。\n第二个参数是解压缩之后文件存放的路径，./ 是指放在根目录。\n\n打包成 ASAR 文件asar pack your-app app.asar\n\nasar pack 指令有两个参数:\n\n第一个是需要打包的目录名，会将目录下所有文件及文件夹全部打包。\n第二个参数是打包后的 asar 文件名。\n\n读取 ASAR 里面的文件asar list app.asar\n\nasar list 指令有一个参数:\n\n这个参数就是所需要查看的 asar 文件名。\n\n","categories":["备忘录"],"tags":["ASAR"]},{"title":"浏览器快捷键大全","url":"/posts/62c9b5a2/","content":"标签页和窗口快捷键、功能快捷键、网页快捷键、鼠标快捷键。\n\n\n\n标签页和窗口快捷键\n\n\n快捷键\n说明\n\n\n\nCtrl + n\n打开新窗口。\n\n\nCtrl + shift + n\n在隐身模式下打开新窗口。\n\n\nCtrl + t\n打开新的标签页。（常用）\n\n\nCtrl + Shift + t\n重新打开最后关闭的标签页。（常用）\n\n\nCtrl + Tab 或 Ctrl + Pgdn\n跳转到下一个打开的标签页，如果当前为最后一个标签页，则跳转到第一个标签页。\n\n\nCtrl + Shift + Tab 或 Ctrl + Pgup\n跳转到上一个打开的标签页。（常用）\n\n\nAlt + ←\n打开历史记录中的上一页。（常用）\n\n\nAlt + →\n打开历史记录中的下一页。\n\n\nCtrl + 1 到 Ctrl + 8\n跳转到指定索引号的标签页。（常用）\n\n\nCtrl + 9\n跳转到最后一个标签页。（常用）\n\n\nAlt + home\n在当前标签页中打开主页。\n\n\nCtrl + w 或 Ctrl + F4\n关闭当前标签页。（常用）\n\n\nCtrl + Shift + w\n关闭所有已打开的标签页并关闭当前 Chrome 浏览器（如果开了多个浏览器，则只关闭当前的浏览器）。\n\n\nCtrl + Shift + q 或 Alt + F4\n关闭所有 Chrome 浏览器。（慎用）\n\n\n功能快捷键\n\n\n快捷键\n说明\n\n\n\nCtrl + h\n在新标签页中打开”历史记录”页。（常用）\n\n\nCtrl + j\n在新标签页中打开”下载内容”页。（常用）\n\n\nShift + Esc\n打开 Chrome 任务管理器。\n\n\nCtrl + f 或 F3\n打开关键字搜索框。（常用）\n\n\nCtrl + g\n跳转到与关键字搜索框中的文本相匹配的下一条内容。\n\n\nCtrl + Shift + g\n跳转到与关键字搜索框中的文本相匹配的上一条内容。\n\n\nAlt + f 或 Alt + e 或 F10\n打开右上角的菜单栏。F10 只是选择菜单栏的图标，还需要键入回车或空格后，才能完全打开。\n\n\nCtrl + Shift + b\n显示或隐藏书签栏。\n\n\nCtrl + Shift + o\n打开书签管理器。\n\n\nShift + Alt + t\n把焦点放在 Chrome 工具栏的第一项上。\n\n\nF6\n在地址栏与书签栏之间向前切换焦点。（常用）\n\n\nShift + F6\n在地址栏与书签栏之间向后切换焦点。\n\n\nF12 或 Ctrl + Shift + j\n打开 “开发者工具”。（常用）\n\n\nCtrl + Shift + Delete\n打开 “清除浏览数据” 选项。\n\n\nF1\n打开 Chrome 帮助中心。\n\n\nCtrl + Shift + m\n打开 Chrome 账户登陆对话框。\n\n\nCtrl+D\n将当前网页保存为书签。\n\n\nCtrl+Shift+D\n将所有打开的网页以书签的形式保存在新文件夹中。\n\n\n网页快捷键\n\n\n快捷键\n说明\n\n\n\nCtrl + u\n显示当前网页的 HTML 源代码【不可修改】。（常用）\n\n\nCtrl + d\n打开【将当前网页保存为书签】的对话框。（常用）\n\n\nCtrl + Shift + d\n打开【将所有打开的标签页以书签的形式保存在新文件夹】的对话框。\n\n\n空格键或 Pgdn\n向下滚动网页，一次一个屏幕。（常用）\n\n\nShift + 空格键或 PgUp\n向上滚动网页，一次一个屏幕。Shift + 空格键实测不可用。\n\n\nCtrl 和 +\n放大网页。\n\n\nCtrl 和 -\n缩小网页。\n\n\nCtrl + 0\n将网页恢复到默认大小。\n\n\nEsc\n停止加载网页。\n\n\nCtrl + p\n打开打印选项。\n\n\nCtrl + s\n保存当前网页。\n\n\nF5 或 Ctrl + r\n重新加载当前网页。（常用）\n\n\nShift + F5 或 Ctrl + Shift + r\n重新加载当前网页（忽略缓存内容）。\n\n\nTab\n浏览下一个可点击项。\n\n\nShift + Tab\n浏览上一个可点击项。\n\n\nCtrl + o\n打开选择文件框。\n\n\nF11\n开启或关闭全屏模式。（常用）\n\n\nhome\n转到网页顶部。（常用）\n\n\nend\n转到网页底部。\n\n\n按住 Shift 并滚动鼠标滚轮\n在网页上水平滚动。\n\n\n鼠标快捷键\n\n\n快捷键\n说明\n\n\n\n按住 Ctrl 并点击网页链接\n在新的标签页中打开网页。（常用）\n\n\n按住 Alt 并点击网页链接\n下载链接目前的网页。\n\n\n将网页链接拖拽到标签栏的空白位置\n在新的标签页中打开网页。\n\n\n按住 Shift 并点击网页链接\n在新窗口中打开网页。\n\n\n将标签页拖出标签栏\n在新窗口中打开网页。\n\n\n将标签页拖进现有窗口\n将标签页移至当前窗口。\n\n\n双击标签栏的空白区域\n最大化或最小化当前窗口。\n\n\n按住 Ctrl 并向上滚动鼠标滚轮\n放大网页。\n\n\n按住 Ctrl 并向下滚动鼠标滚轮\n缩小网页。\n\n\n","categories":["备忘录"],"tags":["快捷键"]},{"title":"Linux | 学习笔记（待更新）","url":"/posts/c9e20737/","content":"Linux 命令搜索引擎，内容包含 Linux 命令手册、详解、学习、搜集。\n\n\n\nLinux 目录结构\nLinux 中任何东西都是文件。目录是文件，文件是文件，设备也是文件。设备通常被当作节点，但仍然是文件。Linux 文件系统是按树型结构分级组织的。文件系统的最高级别是根目录 &#x2F;，其他文件或目录都在根目录下。例如，&#x2F;home&#x2F;lisir&#x2F;cheeses.odt 表示的是 cheeses.odt 文件的完整路径，而 cheeses.odt 文件是在 lisir 目录下，lisir 又是在 home 目录下，home 则是在根目录下的。\n\n查看根目录下所有文件以及目录（包括隐形文件和隐形目录）:\nls -al /\n\n输出结果：\ndr-xr-xr-x.  18 root root  4096 3月  17 15:36 .dr-xr-xr-x.  18 root root  4096 3月  17 15:36 ..lrwxrwxrwx.   1 root root     7 2月   8 10:15 bin -&gt; usr/bindr-xr-xr-x.   5 root root  4096 2月   8 10:38 bootdrwxr-xr-x   19 root root  2960 3月   4 20:46 devdrwxr-xr-x.  80 root root  4096 3月  17 09:23 etcdrwxr-xr-x.   2 root root  4096 3月  17 09:25 homelrwxrwxrwx.   1 root root     7 2月   8 10:15 lib -&gt; usr/liblrwxrwxrwx.   1 root root     9 2月   8 10:15 lib64 -&gt; usr/lib64drwx------.   2 root root 16384 2月   8 10:15 lost+founddrwxr-xr-x.   2 root root  4096 4月  11 2018 mediadrwxr-xr-x.   2 root root  4096 4月  11 2018 mntdrwxr-xr-x.   3 root root  4096 3月  13 15:31 optdr-xr-xr-x  106 root root     0 3月   4 20:46 procdr-xr-x---.   6 root root  4096 3月  16 23:12 rootdrwxr-xr-x   25 root root   760 3月  13 15:31 runlrwxrwxrwx.   1 root root     8 2月   8 10:15 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root  4096 4月  11 2018 srvdr-xr-xr-x   13 root root     0 3月  17 15:34 sysdrwxrwxrwt.   8 root root  4096 3月  18 03:56 tmpdrwxr-xr-x.  13 root root  4096 2月   8 10:15 usrdrwxr-xr-x.  19 root root  4096 2月   8 02:19 var\n\n\n\n\n路径\n介绍\n\n\n\n&#x2F;bin\nbin 是 Binaries (二进制文件) 的缩写，存放一些常用的可直接执行的二进制文件，比如 ls 指令，普通用户都有权限执行\n\n\n&#x2F;boot\n存放一些系统启动所需要的引导文件\n\n\n&#x2F;dev\ndev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的\n\n\n&#x2F;etc\netc 是 Etcetera(等等) 的缩写，存放系统环境所需要的配置文件和对应的子目录\n\n\n&#x2F;home\n用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的\n\n\n&#x2F;lib\nlib 是 Library(库) 的缩写，这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库\n\n\n&#x2F;lib64\n存放系统需要的内置 64 位库文件\n\n\n&#x2F;lost+found\nlost+found 目录的文件通常是未链接的文件（名字以及被删除），这些文件还被一些进程使用（数据没有删除），在系统突然关机时（内核 panic 或突然断电）出现。 这些文件系统会删除的，你不需要担心。当因为软件或硬件出现错误，导致文件系统不一致，也有可能把有问题的文件放入到 lost+found 目录\n\n\n&#x2F;media\nlinux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下\n\n\n&#x2F;mnt\n系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了\n\n\n&#x2F;opt\nopt 是 optional(可选) 的缩写，给第三方软件包存放的目录，默认是空的\n\n\n&#x2F;proc\nproc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息，这个目录的内容不在硬盘上而是在内存里\n\n\n&#x2F;root\n该目录为系统管理员，也称作超级权限者的用户主目录\n\n\n&#x2F;run\n运行目录，存放当前系统运行的信息\n\n\n&#x2F;sbin\n存放一些系统管理员才可以操作的二级制文件命令\n\n\n&#x2F;srv\n存放和系统服务相关的东西\n\n\n&#x2F;sys\n存放系统硬件信息相关文件\n\n\n&#x2F;tmp\ntmp 是 temporary(临时) 的缩写，这个目录是用来存放一些临时文件的，可以修改删除\n\n\n&#x2F;usr\nusr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录\n\n\n&#x2F;var\nvar 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下，包括各种日志文件\n\n\n&#x2F;selinux\n这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的\n\n\n&#x2F;usr&#x2F;local\n给主机额外安装软件的目录，一般是通过编译源码安装的程序\n\n\n\n可以修改删除的文件目录：home、opt、tem、var。其他文件目录谨慎操作。\n\nLinux 文件基本属性\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在 Linux 系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。因此，Linux 系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。  \n\n从左至右用 0-9 这些数字来表示：\n\n第 0 位确定文件类型\n第 1-3 位确定属主（该文件的所有者）拥有该文件的权限\n第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限\n第 7-9 位确定其他用户拥有该文件的权限\n第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限\n第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限\n第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限\n\n\n第一个字符代表这个文件是目录、文件或链接文件等等：\n\n当为 d 则是目录\n当为 - 则是文件\n若是 l 则表示为链接文档（link file）\n若是 b 则表示为装置文件里面的可供储存的接口设备（可随机存取装置）\n若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标（一次性读取装置）\n接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。\n其中，r 代表可读(read)、w 代表可写(write)、x 代表可执行(execute)。\n要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。\n\n\n权限对于文件和目录的区别：\n\nr：对文件而言，具有读取文件内容的权限，对目录来说，具有浏览目录的权限\nw：对文件而言，具有新增、修改、删除文件内容的权限，对目录来说，具有新建、删除、修改、移动目录内文件的权限\nx：对文件而言，具有执行文件的权限，对目录了来说该用户具有进入目录的权限\n\n\n权限对于目录的意义：\n\n只有只读权限不允许使用 cd 进入目录，必须要有执行的权限才能进入。\n只有执行权限只能进入目录，不能看到目录下的内容，要想看到目录下的文件名和目录名，需要可读权限。\n一个文件能不能被删除，主要看该文件所在的目录对用户是否具有写权限，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外。\n目录没有写权限，即使你拥有目录中某文件的写权限也不能写该文件。\n新建文件默认权限 777，新建目录默认权限 666。\n\n\n\nLinux 常用基本命令文件目录类什么是绝对路径与相对路径：\n\n绝对路径的写法：由根目录 / 写起，例如： /usr/share/doc 这个目录。\n相对路径的写法：不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法。\n\ncd 切换目录# 进入对应路径cd [相对路径或绝对路径]# 进入对应软链接的实际路径cd -P [相对路径或绝对路径]# 进入根目录cd /# 进入 home 目录cd# 或cd ~# 或cd --# 回到上一层目录cd ..# 回到上次访问的目录cd -\n\npwd 显示绝对路径# 查看当前路径pwd# 查看软链接的实际路径pwd -P\n\nls 列出目录及文件名ls -a #列出目录所有文件，包含以.开始的隐藏文件ls -A #列出除.及..的其它文件ls -r #反序排列ls -t #以文件修改时间排序ls -S #以文件大小排序ls -h #以易读大小显示ls -l #除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来ls -F #在列出的文件名称后加一符号；例如可执行档则加 &quot;*&quot;, 目录则加 &quot;/&quot;\n\nmkdir 创建目录# 创建 a 目录mkdir a# 同时创建 b 和 c 目录mkdir b c# 先创建了 d 目录，再创建了 e 目录，最后创建了 f 目录mkdir d d/e d/e/f# 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建mkdir -p /tmp/test/t1/t-m #对新建目录设置存取权限，也可以用 chmod 命令设置;-p #可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。\n\nrmdir 删除目录从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。\n\n注意：不能删除非空目录！\n\n# 删除 a 空目录rmdir a# 删除 b 和 c 空目录rmdir b c# 首先删除最下层的子目录 f，再删除子目录 e，再删除 d 目录rmdir d/e/f/ d/e/ d/# 当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除rmdir -p parent/child/child11\n\ntouch 创建文件# 创建一个名为 hello 的文件touch hello# 在 root 用户目录下创建一个名为 hello 的文件touch /root/hello\n\nrm 删除文件或目录删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。\n# 删除任何 .log 文件，删除前逐一询问确认rm -i *.log# 删除 test 子目录及子目录中所有档案，并且不用逐一确认rm -rf test\n\nmv 移动&#x2F;重命名文件或目录移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。\n当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。\n# 将文件 test.log 重命名为 test1.txtmv test.log test1.txt# 将文件 log1.txt,log2.txt,log3.txt 移动到 home 目录的 test 目录中mv log1.txt log2.txt log3.txt /home/test# 将文件 log1.txt 改名为 log2.txt，如果 log2.txt 已经存在，则询问是否覆盖mv -i log1.txt log2.txt# 移动当前文件夹下的所有文件到上一级目录mv * ../\n\ncp 复制文件或目录将源文件复制至目标文件，或将多个源文件复制至目标目录。\n注意：命令行中，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！\n# 复制 a 文件到 b 目录下，如果没有 b 这个目录则将 a 文件重命名为 b 复制到 a 文件同级目录下，如果 b 是一个文件，则提示是否覆盖 b 文件cp a b-r #复制目录及目录内所有项目，递归复制-a #复制的文件与原文件时间一样\n\ncat 查看文件内容# 查看 a 文件内容，并且显示行号cat -n a-n #显示所有行的行号，包括空行\n\necho 输出内容到控制台# 输出 hello worldecho &quot;hello world&quot;# 输出 hello 换行 worldecho -e &quot;hello\\nworld&quot;-e #支持反斜杠控制的字符（转义字符）转换\n\nhead 显示文件头部内容head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容\n# 显示 a 文件头 10 行内容head a# 显示 a 文件头 20 行内容head -n 20 a-n&lt;行数&gt; #指定显示头部内容的行数\n\ntail 输出文件尾部内容# 显示 a 文件尾部 10 行内容tail a# 显示 a 文件尾部 20 行内容tail -n 20 a# 实时追踪 a 文件的所有更新tail -f a-n&lt;行数&gt; #指定显示尾部内容的行数-f #显示文件最新追加的内容，监视文件变化\n\nln 链接\n命令功能：\n\nLinux 文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种：硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。\n不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。\n\n\n软链接：\n\n软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\n软链接可以 跨文件系统 ，硬链接不可以\n软链接可以对一个不存在的文件名进行链接\n软链接可以对目录进行链接\n\n\n硬链接：\n\n硬链接，以文件副本的形式存在。但不占用实际空间。\n不允许给目录创建硬链接\n硬链接只有在同一个文件系统中才能创建\n\n\n删除软链接：\n\nrm -rf 软链接名，而不是 rm -rf 软链接名&#x2F;\n如果使用 rm -rf 软链接名&#x2F; 删除，就会把软链接对应的真实目录下的内容删掉\n\n\n语法：\n  ln [选项] [源文件或目录] [目标文件或目录]\n\n创建软链接：\n  # 在目录 /usr/liu 下建立一个符号链接文件 abc，使它指向目录 /usr/mengqc/mub1ln -s /usr/mengqc/mub1 /usr/liu/abc-s #对源文件建立符号链接，而非硬链接\n\n创建硬链接：\n  # 为 log1.log 创建硬链接 log1，log1.log 与 log1 的各项属性相同ln log1.log log1\n\nhistory 查看已经执行过历史命令# 查看过去在 Linux 中已经执行过得命令history# 查看过去倒数的 10 个命令history 10# 清理掉历史命令记录history -c# !+历史命令编号，相当于重复执行这个命令!111\n\n用户权限类Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n每个用户账号都拥有一个唯一的用户名和各自的密码。\n用户在登录时键入正确的用户名和密码后，就能够进入系统和自己的主目录。\n实现用户账号的管理，要完成的工作主要有如下几个方面：\n\n用户账号的添加、删除与修改。\n用户密码的管理。\n用户组的管理。\n\n用户管理\nuseradd 新建用户\n  # 语法useradd [选项] [用户名]# 新建 lisir 用户useradd lisir# 新建 lisir 用户，且指定用户所属的用户组为 wheeluseradd -g wheel lisir# 新建 lisir 用户，且指定用户所属的附加组为 wheeluseradd -G wheel lisir# 新建 lisir 用户，且指定用户的主目录为 user1useradd -d /home/user1 lisir-g [用户组] #指定用户所属的用户组-G [用户组] #指定用户所属的附加组-d [目录] #指定用户主目录\n\nuserdel 删除用户\n  # 语法userdel [选项] [用户名]# 删除 lisir 用户userdel lisir# 删除 lisir 用户，同时删除 lisir 主目录userdel -r lisir-r #连同用户的主目录一起删除\n\nusermod 修改用户\n  # 语法usermod [选项] [用户名]\n\n用户组管理\ngroupadd 新建用户组\n  # 语法\n\ngroupdel 删除用户组\n  # 语法\n\ngroupmod 修改用户组\n  # 语法\n\n搜索查找类压缩解压类磁盘管理类进程管理类软件包管理Shell 编程Shell 特殊字符\n; 分号的用法\n\n方式：command1 ; command2\n用 ; 号隔开每个命令，每个命令按照从左到右的顺序依次执行，彼此之间不关心是否失败，所有命令都会执行。\n\n| 管道符用法\n\n上一条命令的输出，作为下一条命令参数\n方式：command1 | command2\nLinux 所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推.\n利用一个管道\nrpm -qa | grep licq\n\n这条命令使用一个管道符“|”建立了一个管道。管道将rpm -qa命令的输出（包括系统中所有安装的RPM包）作为grep命令的输入，从而列出带有 licq 字符的 RPM 包来。\n利用多个管道\ncat /etc/passwd | grep /bin/bash | wc -l\n\n这条命令使用了两个管道，利用第一个管道将 cat 命令（显示 passwd 文件的内容）的输出送给 grep 命令，grep 命令找出含有“&#x2F;bin&#x2F;bash”的所有行；第二个管道将 grep 的输出送给 wc 命令，wc 命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用 bash。\n\n|| 符号用法\n\n逻辑或的功能\n语法格式如下：\ncommand1 || command2 [|| command3 …]\n命令之间使用 || 连接，实现逻辑或的功能。只有在 || 左边的命令返回假（命令返回值 $? &#x3D;&#x3D; 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。只要有一个命令返回真（命令返回值 $? &#x3D;&#x3D; 0），后面的命令就不会被执行。直到返回真的地方停止执行。\n\n&amp; 符号用法\n\n&amp;放在启动参数后面表示设置此进程为后台进程\n方式：command1 &amp;\n默认情况下，进程是前台进程，这时就把 Shell 给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。\n\n&amp;&amp; 符号用法\n\nshell 在执行某个命令的时候，会返回一个返回值，该返回值保存在 shell 变量 $? 中。当 $? &#x3D;&#x3D; 0 时，表示执行成功；当 $? &#x3D;&#x3D; 1 时（我认为是非0的数，返回值在0-255间），表示执行失败。\n有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell 提供了 &amp;&amp; 和 || 来实现命令执行控制的功能，shell 将根据 &amp;&amp; 或 || 前面命令的返回值来控制其后面命令的执行。\n语法格式如下：\ncommand1 &amp;&amp; command2 [&amp;&amp; command3 …]\n\n命令之间使用 &amp;&amp; 连接，实现逻辑与的功能：\n只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? &#x3D;&#x3D; 0），&amp;&amp; 右边的命令才会被执行。\n只要有一个命令返回假（命令返回值 $? &#x3D;&#x3D; 1），后面的命令就不会被执行。\n","categories":["学习笔记"],"tags":["Linux"]},{"title":"Markdown | 入门教程及书写风格","url":"/posts/633af0aD/","content":"现代汉语就像用脏了的人民币，要用 Markdown 洗一洗。Markdown 是一种轻量级标记语言。你不需要关心标题多大字号、段前距多少、列表缩进几格，只要在纯文本前后增加一些标记符号（例如 # - * &gt;），就能毫不费力地写出工整精美的文章。请注意！Markdown 不要写成 MarkDown。\n\n\n\n优势易学易记只要几分钟就可以 学会 Markdown，然后你可能再也不想碰 Word 了。\n专注写作富文本编辑器（例如 Word）是通过点击图形化的功能按钮来实现排版，而 Markdown 则是通过标记字符去赋予文字不同格式。易读易写（easy-to-read and easy-to-write），让任何与文字打交道的人专注于写作，不用操心排版。\n格式统一同一份 Word 文档，在\n\n不同的设备：Windows、macOS、Android、iOS\n不同的版本：旧版 Word 、新版 Word\n不同的软件：Microsoft Office、WPS\n\n可能显示不一样的效果。而 Markdown 可以 Write once, export everywhere。不管在电脑上，还是手机上，用 Markdown 写出来的文章都能带来舒适、统一、美好的阅读体验。\n向外兼容可以导出 PDF、 Word、HTML、图片等格式分享给没有安装 Markdown 编辑器的人。\n入门一开始你只要记住以下符号（英文半角状态），就能写出排版清爽的文章了。\n\n\n\n标记符号\n标记结果\n\n\n\n# + 空格 + 文本\n一级标题\n\n\n## + 空格 + 文本\n二级标题\n\n\n### + 空格 + 文本\n三级标题\n\n\n- + 空格 + 文本\n无序列表\n\n\n1 + . + 空格 + 文本\n有序列表\n\n\n&gt; + 空格 + 文本\n引用\n\n\n文本 + Enter + ==\n一级标题（不建议）\n\n\n文本 + Enter + --\n二级标题（不建议）\n\n\n# + 文本 + #\n一级标题（不建议）\n\n\n## + 文本 + ##\n二级标题（不建议）\n\n\n如果有些文字需要特殊说明：\n\n\n\n标记符号\n标记结果\n\n\n\n** + 加粗 + **\n加粗\n\n\n* + 斜体 + *\n斜体\n\n\n~~ + 删除线 + ~~\n删除线\n\n\n进阶以上就是最基础的 Markdown 语法，普通用户看到这里就可以开始动笔尝试了。下面介绍一些 Markdown 的书写风格，让你的源码和文档更精美，更有条理。你不必一下子全部记住，需要实现哪个功能再来查阅或者问 Google 也不迟。\n标题层级\n\n正文的标题从 ## 开始，# 要留给整篇文章的标题（也可以不写）。这样的大纲结构也可以很方便地转换为思维导图，也符合 SEO（搜索引擎优化）的规则。\n  # 一级标题（h1）：文章的标题## 二级标题（h2）：正文的大标题### 三级标题（h3）：正文的小标题\n\n虽然 Markdown 最大支持 ###### 六级标题，为了保持层级的简单，防止出现过于复杂的章节，请谨慎使用四级标题（除非是长文章）。如果三级标题下有并列性的内容，可以使用加粗、有序列表或无序列表代表末级标题。\n  短文章的标题层级### 正文的小标题**三级标题 A**- 论据 1（五级标题）  - 细分论据 1（六级标题）  - 细分论据 2（六级标题）  - 细分论据 3（六级标题）- 论据 2- 论据 3**三级标题 B**1. 论据2. 论据3. 论据**三级标题 C**- 论据 1- 论据 2- 论据 3\n\n  长文章的标题层级### 正文的小标题#### 正文的三级标题 A#### 正文的三级标题 B#### 正文的三级标题 C\n\n二级标题下，不能直接出现四级标题。\n\n标题要避免孤立编号（即同级标题只有一个）。\n\n标题要简短，结尾不带标点符号。\n\n（源码上）标题前后空一行（段前距和段后距）。\n\n大标题和小标题之间要有内容过渡（引出或概括下文）。\n  # Title开门见山地告诉读者这篇文章讲什么？一级标题作为文章的（页面）标题（H1），并且尽可能和文件名称保持一致。如果文章很长，使用 [TOC] 生成目录。## What先定义问题是什么？……正文从二级标题开始。## Why为什么会出现这样的问题？……## How下一步该怎么办？……## See also文末别忘了贴上参考链接。\n\n列表无序列表使用 ‐ 或 * 或 + 并跟随 1 个空格来表示无序列表。建议使用 ‐（连字符，hyphen）。\n- 我是谁- 我从哪里来- 我到哪里去\n\n不建议\n* 我是谁* 我从哪里来* 我到哪里去+ 我是谁+ 我从哪里来+ 我到哪里去\n\n为什么\n\n星号 * 可能和加粗和斜体符号产生混淆。\n加号 + 不流行。\n\n与其他语法结合使用\n- **《春日》**：等闲识得东风面，万紫千红总是春。- **《春草》**：萋萋总是无情物，吹绿东风又一年。- **《墨梅》**：犹恨东风无意思，更吹烟雨暗黄昏。\n\n预览\n\n《春日》：等闲识得东风面，万紫千红总是春。\n《春草》：萋萋总是无情物，吹绿东风又一年。\n《墨梅》：犹恨东风无意思，更吹烟雨暗黄昏。\n\n有序列表语法一（手动排序）\n1. 斜月沉沉藏海雾，碣石潇湘无限路。2. 不知乘月几人归，落月摇情满江树。3. 春江潮水连海平，海上明月共潮生。\n\n预览\n\n斜月沉沉藏海雾，碣石潇湘无限路。\n不知乘月几人归，落月摇情满江树。\n春江潮水连海平，海上明月共潮生。\n\n对于比较短的、很少修改的有序列表，请按顺序标号，保持源码的可读性。\n语法二（自动排序）\n对于比较长的、可能会修改的列表（尤其是很长的嵌套列表），请使用「懒人编号法」。纵使有新的列表项「插队」，把序号弄乱了也没关系，Markdown 编辑器自动会对序号进行纠错。\n1. Foo.2. Bar.    1. Foofoo.    2. Barbar.    3. Gargar3. Baz.\n\n预览\n\nFoo.\nBar.\nFoofoo.\nBarbar.\nGargar\n\n\nBaz.\n\n嵌套列表缩进 2 ~ 4 个空格或一个 Tab（推荐），可以嵌套列表。\n示例一\n1. 不知乘月几人归，落月摇情满江树。    - 与君吟弄风月，端不负平生。    - 对秋深，离恨苦，数夜满庭风雨。    - 五月畲田收火米，三更津吏报潮鸡。2. 人姝丽，粉香吹下，夜寒风细。    - 弓弦抱汉月，马足践胡尘。    - 寒月悲笳，万里西风瀚海沙。    - 东堂坐见山，云风相吹嘘。3. 沅溪夏晚足凉风，春酒相携就竹丛。    - 白发渔樵江渚上，惯看秋月春风。    - 归来独卧逍遥夜，梦里相逢酩酊天。    - 致君尧舜上，再使风俗淳。\n\n预览\n\n不知乘月几人归，落月摇情满江树。\n与君吟弄风月，端不负平生。\n对秋深，离恨苦，数夜满庭风雨。\n五月畲田收火米，三更津吏报潮鸡。\n\n\n人姝丽，粉香吹下，夜寒风细。\n弓弦抱汉月，马足践胡尘。\n寒月悲笳，万里西风瀚海沙。\n东堂坐见山，云风相吹嘘。\n\n\n沅溪夏晚足凉风，春酒相携就竹丛。\n白发渔樵江渚上，惯看秋月春风。\n归来独卧逍遥夜，梦里相逢酩酊天。\n致君尧舜上，再使风俗淳。\n\n\n\n示例二\n- 栏目    &gt; - 排版美学    &gt; - 数字生活    &gt; - 日志随笔- 联系方式    &gt; - Email：***@gmail.com    &gt; - Telegram：t.me/***    &gt; - WeChat：***\n\n预览\n\n栏目\n\n\n排版美学\n数字生活\n日志随笔\n\n\n\n联系方式\n\n\nEmail：***@gmail.com\nTelegram：t.me&#x2F;***\nWeChat：***\n\n\n\n\nTips\n\nTab 缩进一级\nShift + Tab 提升一级\n\n任务列表语法\n- [ ] 纯牛奶- [x] 西瓜- [ ] 鸡蛋- [x] 保鲜膜- [ ] 猪肉\n\n预览\n\n 纯牛奶\n 西瓜\n 鸡蛋\n 保鲜膜\n 猪肉\n\n引用在每一行使用 &gt; 符号，包括换行的句子。\n&gt; 我们是为人民服务的，所以，我们如果有缺点，就不怕别人批评指出。&gt; by 毛泽东：《为人民服务》（1944 年 9 月 8 日）\n\n\n我们是为人民服务的，所以，我们如果有缺点，就不怕别人批评指出。by 毛泽东：《为人民服务》（1944 年 9 月 8 日）\n\n表格语法\n| 左对齐             |                      居中对齐                       | 右对齐 || :----------------- | :-------------------------------------------------: | -----: || **加粗**           |            [插入链接](/posts/633af0aD/)             |   ￥5.7 || `换行`&lt;br /&gt;下一行 | ![插入图片](https://img.wkwbk.eu.org/i/favicon.png) |  ￥10.4 |\n\n预览\n\n\n\n左对齐\n居中对齐\n右对齐\n\n\n\n加粗\n插入链接\n￥5.7\n\n\n换行下一行\n\n￥10.4\n\n\n注释\n\nMarkdown 是轻量级的标记语言，所以不支持合并和拆分单元格。对于复杂表格，你可以在 Markdown 编辑器中使用 HTML 的 &lt;table&gt; 标签标记。\n输入 &lt;br /&gt; 可以换行（但不建议使用）。\n把 Excel 表格复制粘贴到某些 Markdown 编辑器可以直接转换为 Markdown 形式的表格。\n\n链接语法\n[LISIR](/posts/633af0aD/)\n\n预览：LISIR\n图片语法\n![插入图片](https://img.wkwbk.eu.org/i/favicon.png)\n\n预览\n\nMarkdown 是一种纯文本标记语言，图片功能注定是它的弱项。\n网络图床\n但谁能保证哪个图床服务不倒闭？所以我在写作的时候，力求用文字把事情解释清楚，能不插入图片就不插入图片。我偶尔会用到的 图床 是 sm.ms（免费）。\n代码行内代码用 2 个重音符 `（backtick，在 Tab 键上方）包裹\n`Markdown` 是一种轻量级标记语言。\n\n预览\nMarkdown 是一种轻量级标记语言。\n用两个 ` 包裹，才能显示 `：\nA single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``\n\n预览\nA single backtick in a code span: `\nA backtick-delimited string in a code span: `foo`\n重音符前后空一格\n- 推荐：使用键盘快捷键 `Ctrl + D` 可以将当前网页保存为书签。- 反对：使用键盘快捷键`Ctrl+D`可以将当前网页保存为书签。\n\n预览\n\n推荐：使用键盘快捷键 Ctrl + D 可以将当前网页保存为书签。\n反对：使用键盘快捷键Ctrl+D可以将当前网页保存为书签。\n\n代码块将 3 个重音符 ` 置于代码块的首行和末行。首行的重音符后面可接代码语言名称，例如 &#96;&#96;&#96; python，以达到相应的代码高亮效果。\n```pythonprint &quot;Hello, Python!&quot;\n\n预览\nprint &quot;Hello, Python!&quot;\n\ndiff 代码对比\n```difffunction addTwoNumbers (num1, num2) &#123;-  return 1 + 2+  return num1 + num2&#125;\n\n预览\nfunction addTwoNumbers (num1, num2) &#123;-  return 1 + 2+  return num1 + num2&#125;\n\n换行\n以下键盘快捷键（语法）可能仅支持 Typora。\n\nEnter &#x3D; 换行 + 空行 &#x3D; (Shift + Enter) × 2。\n即按下回车键创建一个新段落（段与段之间加入空行）。\n软换行Shift + Enter &#x3D; 换行（但是不会产生空行）。\n`enticing` [ɪn&#x27;taɪsɪŋ] （事物）诱人的，有吸引力的；迷人的- Her neck was short but rounded and her arms plump and enticing. `Shift` + `Enter`  她的脖子短，但浑圆可爱；两臂丰腴，也很动人。by 《飘》 `Enter`- This was enticing to Wozniak, even more than any prospect of getting rich. `Shift` + `Enter`  这句话对沃兹尼亚克的诱惑太大了，比变成富人的诱惑还要大。by 《乔布斯传》 `Enter`\n\nenticing [ɪn’taɪsɪŋ] （事物）诱人的，有吸引力的；迷人的\n\nHer neck was short but rounded and her arms plump and enticing.\n她的脖子短，但浑圆可爱；两臂丰腴，也很动人。by 《飘》\n\nThis was enticing to Wozniak, even more than any prospect of getting rich.\n这句话对沃兹尼亚克的诱惑太大了，比变成富人的诱惑还要大。by 《乔布斯传》\n\n\n硬换行在行末使用空格（两个以上） + 换行（Enter），就可以实现强制换行，此语法适用于大部分 Markdown 编辑器。\n硬换行在文档被导出时将被保留，且没有换段的段后距。\n假如生活欺骗了你，  （两个空格）不要悲伤，不要心急！  （两个空格）忧郁的日子里须要镇静：  （两个空格）相信吧，快乐的日子将会来临！  （两个空格）心儿永远向往着未来；  （两个空格）现在却常是忧郁。  （两个空格）一切都是瞬息，一切都将会过去；  （两个空格）而那过去了的，就会成为亲切的怀恋。  （两个空格）by 普希金\n\n假如生活欺骗了你，不要悲伤，不要心急！忧郁的日子里须要镇静：相信吧，快乐的日子将会来临！心儿永远向往着未来；现在却常是忧郁。一切都是瞬息，一切都将会过去；而那过去了的，就会成为亲切的怀恋。by 普希金\n其他\n\n\n名称\n语法\n备注\n\n\n\n分割线\n---、***、+++\n不常用\n\n\n内容目录\n[TOC]\nTable of Contents\n\n\n应用Markdown 的用途很广。Write once, export everywhere：写博客、写邮件、排推文、做 PPT 等。\n公众号排版\nMarkdown Nice：让微信排版变 Nice，支持自定义主题 CSS，例如 锤子便签样式。\nMarkdown Devtool：简称 MDTU。是一款基于 bytemd 由山月开发的支持微信样式的 Markdown 编辑器。\n微信 Markdown 编辑器：高度简洁。\n可能吧公众号 Style 一键转换器：老司机禅叔出品。\n\n简历排版\n冷熊简历\nresume.mdnice.com\nResumd\n\n邮件排版Markdown Here 是一个浏览器扩展插件，可以将浏览器中编辑器（例如 email 正文）里的 Markdown 文本转换成渲染过后的 HTML，并且支持自定义 CSS。\n修改 CSS 样式教程：\n\n在富文本在线编辑器中使用 Markdown - Hover\n再谈 Markdown here CSS 渲染及全套分享 - 纵笔浮生\n\n转换为 Mind Map\n对于 Xmind &#x2F; MindNode &#x2F; 百度脑图 等思维导图工具，直接导入 md 文档。\n对于幕布，可以用 Typora 导出 opml 格式，再导入。\nMarkmap：Markdown + Mindmap，使用思维导图可视化 Markdown。\n\n从网页导出 md 格式借助浏览器插件 简约 导出 md 格式的网页，不用 手动添加标记符号。\n导出漂亮的 Markdown 源代码图片\n打开 carbon.now.sh\n语言选择 Markdown\n书写或者粘贴 Markdown 源代码\n导出 PNG 像素图或者 SVG 矢量图\n\n","categories":["学习笔记"],"tags":["Markdown"]},{"title":"中英混排和标点符号的用法","url":"/posts/ee0f0b56/","content":"评价一个科技媒体或者设计师是否专业，我会看中英文之间是否空一格，因为美好的文字值得用更优雅更干净的方式呈现。\n\n\n\n拼写正确尊重专有名词的正确写法，是写作 &#x2F; 排版的第一步：\n\n\n\n✔️\n❌\n\n\n\nApp、app\nAPP\n\n\nApp Store\nAppstore\n\n\na.m.\nam、AM、A.M.（上午）\n\n\nemail\nE-mail、Email\n\n\nGitHub\nGithub、github\n\n\nGoogle\ngoogle\n\n\niOS\nIOS\n\n\niPhone XS Max\nIphone xs MAX\n\n\nmacOS\nMacOS\n\n\nkg\nKG、Kg\n\n\nkm\nKm、KM\n\n\nMarkdown\nMarkDown\n\n\nOK\nok\n\n\nP.S.\nPS、ps、Ps.\n\n\nSiri\nsiri\n\n\nWeChat\nWechat、wechat\n\n\nWhatsApp\nWhatsapp、whatsapp\n\n\nWi-Fi\nWIFI、WiFi、wifi\n\n\nYouTube\nYoutube\n\n\n4K\n4k\n\n\n1080p\n1080P\n\n\n登录\n登陆\n\n\n账号\n帐号、账户、帐户\n\n\n英文拼写错误❗ ️大写有突出强调的作用，意味着这个单词或者句子很重要。\n句首字母大写\n❌ how are you?\n✔️ How are you?\n\n专有名词大写\n❌ Happy mid-autumn festival\n✔️ Happy Mid-Autumn Festival（连字符用最短的 hyphen）\n\nI（我）在任何时候都大写\n❌ I am a slow walker, but i never walk back.\n✔️ I am a slow walker, but I never walk back.\n📝 我走得很慢，但是我从来不会后退。by 亚伯拉罕·林肯（Abraham Lincoln）\n\ninternet 首字母不再大写\n一开始的 Internet 首字母是大写（特殊的专有名词），随着互联网的普及，它不再特殊，所以被降级成 internet。\n\nApp\nApp 念作 [æp] ，而非 A-P-P（爱啪啪）。\n当用于标题或首字母时，写作「App」，当用于正文泛指时写作「app」。\nApp 的复数形式是「apps」。\n\n符号拼写错误罗马数字\n✔️ I、Ⅱ、Ⅲ（它们是一个整体）\n❌ I、II、III（用一个或多个大写字母 I 代替）\n\n乘号\n✔️ ×（微软拼音输入 cheng 即可弹出正宗的乘号）\n❌ 字母 x 或 X 代替\n\n借助搜索引擎、官方网站和维基百科，你不难找到专有名词应该怎么写。\n来自 Anyway.FM 的 UI 行业英文术语聚合：Anyway.ABC 安妮薇术语小词典\n增加空格行文时，请务必在全角字符（汉字）和半角字符（字母、数字或符号）之间空一格（半角空格）。混排时，通过刻意增加空格的方式，会让段落看起来不那么「拥挤」，增加中英混排的美感。\n中文与英文之间增加空格\n✔️ 通过 Google 搜索引擎，你可以更快地找到想要的信息。\n❌ 通过Google搜索引擎，你可以更快地找到想要的信息。\n📝 「豆瓣FM」等专有产品名词，按照官方所定义的格式书写。\n\n中文与数字之间增加空格\n✔️ 2021 年 12 月 20 日，我的博客「LISIR」发出第 1 篇文章。\n❌ 2021年12月20日，我的博客「LISIR」发出第1篇文章。\n\n中文与链接之间增加空格\n✔️ 我的 博客 于 2021 年 12 月 20 日正式运营。\n❌ 我的博客于 2021 年 12 月 20 日正式运营。\n\n数字与单位之间增加空格\n✔️ iPhone XS 显示屏的像素密度是 458 ppi，最大亮度（标准）是 625 cd&#x2F;m²。\n❌ iPhone XS 显示屏的像素密度是 458ppi，最大亮度（标准）是 625cd&#x2F;m²。\n📝 我的手机可用储存空间只剩 1GB 了。（在 Apple 的排版哲学中，这是个特例。是否要空一格，看你的个人选择。）\n\n标点符号长文本中穿插的符号就像湖面上泛起的波澜、绸缎上镶嵌的装饰，为版面带来节奏和纹理。对我来说，这一个理由便足够了——美本身就是值得追求的。\n中文标点符号必须使用全角字符。排版时，它们占用的宽度等于一个中文字符，例如 。；而英文一般使用半角标点符号。排版时，它们占用的宽度等于半个中文字符，例如 .\n\n✔️ 三毛说：「心若没有栖息的地方，到哪里都是在流浪。」\n❌ 三毛说:「心若没有栖息的地方,到哪里都是在流浪. 」\n✔️ 请确认所有的连接（电缆和接插件）均安装牢固。\n❌ 请确认所有的连接(电缆和接插件)均安装牢固。\n📝 请确认所有的连接 (电缆和接插件) 均安装牢固 (Apple 的做法：半角括号 + 前后空格)。\n\n完整的英文句子，用半角标点符号\n\n✔️ 乔布斯说过：「Stay hungry, stay foolish.」\n❌ 乔布斯说过：「Stay hungry，stay foolish。」\n\n中文符号感叹号 ！不到万不得已，坚决不用感叹号。平和地表达，才能发出理性的声音。\n\n✔️ 心平气和地表达自己的看法，尽量避免使用感叹号！\n❌ 心平气和地表达自己的看法，尽量避免使用感叹号！！！（不要重复使用标点符号）\n📝 当句子包含疑问、感叹两种语气都比较强烈时（如带有强烈感情的反问句和带有惊愕语气的疑问句），可在问号后再加叹号，例如「这点困难就能把我们吓倒吗？！」\n\n省略号 ……如何输入：\n\n✔️ 切换到中文输入法， Shift + 6（在主键盘的字母 T 上方）即可输入正确的省略号 ……\n❌ 多个中文句号代替 。。。 或多个英文句点代替 ......\n\n省略号不应与「等」这个词一起使用：\n\n❌ 我们为会餐准备了香蕉、苹果、梨…等各色水果。\n✔️ 我们为会餐准备了各色水果，有香蕉、苹果、梨……\n✔️ 我们为会餐准备了香蕉、苹果、梨等各色水果。\n\n逗号 ，\n逗号表示句子内部的一般性停顿。\n注意避免「一逗到底」，即整个段落除了结尾，全部停顿都使用逗号。\n\n顿号 、并列形容词之间用顿号：\n\n✔️ 这里有自由、民主、平等、开放的风气和氛围。\n❌ 这里有自由，民主，平等，开放的风气和氛围。\n\n最后一项内容前已经用了「及」、「以及」、「和」等字样，则最后一项前不再使用顿号：\n\n✔️ 警方还组织数千民兵专门看护桥梁、过街天桥、涵洞和道口等重点部位。\n❌ 警方还组织数千民兵专门看护桥梁、过街天桥、涵洞、和道口等重点部位。\n\n不能用 ， 代替顿号 、：\n\n✔️ 警方还组织数千民兵专门看护桥梁、过街天桥、涵洞等重点部位。\n❌ 警方还组织数千民兵专门看护桥梁，过街天桥，涵洞等重点部位。\n\n如果并列的是短句，应使用逗号：\n\n✔️ 我问了他很多问题，三年前在干什么，两年前在干什么，今后打算干什么……\n❌ 我问了他很多问题、三年前在干什么、两年前在干什么、今后打算干什么……\n\n标有引号的并列成分之间、标有书名号的并列成分之间通常不用顿号。若有其他成分插在并列的引号之间或并列的书名号之间（如引语或书名号之后还有括注），宜用顿号：\n\n✔️ ️️「日」「月」构成「明」字。\n✔️ 店里挂着「顾客就是上帝」「质量就是生命」等横幅。\n✔️ 《红楼梦》《三国演义》《西游记》《水浒传》是我国长篇小说的四大名著\n✔️ 李白的「白发三千长」（《秋浦歌》）、「朝如青丝暮成雪」（《将进酒》）都是脍炙人口的诗句。\n\n括号 （ ）中文夹用英文注释，用中文全角圆括号标示注释：\n\n✔️ The Beatles（1968）有一首歌，题为《除了我和我的猴子人人都想捂藏一点东西》（Everybody’s Got Something to Hide except Me and My Monkey），这首歌后来音乐家称之为《猴子》。\n❌ The Beatles(1968)有一首歌，题为《除了我和我的猴子人人都想捂藏一点东西》(Everybody’s Got Something to Hide except Me and My Monkey)，这首歌后来音乐家称之为《猴子》。\n\n句子末尾用括号加注时，句号应在括号之外：\n\n✔️ 关于文件的输出，请参照第 1.3 节（见第 26 页）。\n❌ 关于文件的输出，请参照第 1.3 节（见第 26 页。）\n\n波浪号 ～\n梨园乡种植的巨风葡萄今年已经进入了丰产期，亩产 1000 公斤 ~ 1500 公斤。\n\n这句话使用了错误的（半角）波浪号 ~（U+007E TILDE）作为（全角）浪纹号 ～（U+FF5E FULLWIDTH TILDE）来标示数值范围的起止。\n如何输入正确的浪纹号？以微软拼音为例：\n\n切换到全角状态（Shift + Space）\nShift + ~（Esc 的下方）\n切换回半角状态，接着输入其他内容\n\n因此，输入正确的浪纹号是一件很麻烦的事，推荐使用 至 或者 到 代替 ～ ：亩产 1000 公斤至 1500 公斤。\n英文符号使用英文（半角）标点符号\n❌ I’m Tim。（使用中文全角标点符号）\n✔️ I’m Tim.\n\n标点符号后面空一格\n❌ Mr.Zhong\n✔️ Mr. Zhong\n❌ We need seven people:three students,three engineers,and a professor.\n✔️ We need seven people: three students, three engineers, and a professor. （注意 and 前面有一个逗号）\n\n\n每句话与上一句的标点之间一定要有空格。空格是分隔单词用的，如果前后两句话之间没有空格，那么上一句的最后一个词，和下一句的第一个词，就连在一起了。比如 I_am_here._It_is_8:00_now. 如果写成 I am here.It is 8:00 now. 那么 here.it 这样是不规范的，只有同一个词中才会出现这样的写法，比如 a.m. 、U.S.A. 中间没有空格，看做是一个词。上边的 here.it 甚至可能被一些网站当成是链接网址，因为 .it 是一个域名，网址中间是不加空格的。\n\n成对符号（括号和引号）前后空一格\n❌ The screen is 6.46 inches(iPhone XS Max)diagonally.\n✔️ The screen is 6.46 inches (iPhone XS Max) diagonally.\n❌ He said,”I may forget your name,but I never forget a face.”\n✔️ He said, “I may forget your name, but I never forget a face.”\n\n在某些 Style Guide 中，纵使在中文语境下，也会将（中文）全角括号替换为 (英文) 半角括号，并在括号外添加半角空格（两个连续的标点之间不添加空格）：\n\niPhone SE 可防溅、抗水、防尘，在受控实验室条件下经测试，其效果在 IEC 60529 标准下达到 IP67 级别 (在最深 1 米的水下停留时间最长可达 30 分钟)。by Apple\n\n省略号\n❌ Juan thought and thought…and then thought some more.（省略号前后没有空格）\n❌ Juan thought and thought … and then thought some more.（三个英文句号代替省略号）\n✔️ Juan thought and thought … and then thought some more. （省略号是一个整体，不可分割）\n\n表示中文时，英文省略号（⋯）应改为中文省略号（……）：\n\n英文： 5 minutes later⋯\n中文： 5 分钟过去了⋯⋯\n\n⌨️ 如何输入省略号\n\nAndroid（安卓手机）：你肯定能找到它\niOS（苹果手机和苹果平板）：长按英文键盘上的句号\nmacOS（苹果电脑）：Option + ;（分号键）\nWindows 电脑：\n方法一：Alt + 0133（按住 Alt，依次在右侧的小键盘上输入 0 1 3 3）\n方法二：在中文输入状态下，按 Shift + 6（字母 T 上方的 ^），再删除一半，然后再切换回英文输入状态\n\n\n\n小数点不严谨地说，东方世界是万位计数法（1 2345 6789.10），而西方世界则是千位计数法（123 456 789.10）。不管是哪一种计数法，在数额巨大时，插入定界符（delimiter）可以方便读者辨识这串数字到底有多大。而在西文中，由于小数点符号（decimal separator 或 decimal mark）的使用习俗不同，会间接影响到千分位符号（也称千位分隔符，group separator）的选择，所以这些写法在不同国家会代表不同数值：12,345、12.345、12,345.678 与 12.345,678。\n小数点用来分隔数字的整数部分与小数部分。如 3.14 中的 .，但地球是圆的：\n\n汉语地区和大多的英语地区：使用 . 句点（full stop）作为小数点\n大多的其他欧洲国家和其前殖民地：使用 , 逗号（comma）作为小数点\n\n\n\n\n长串数字\n千分位\n小数点\n常用于\n\n\n\n125,124,024.25\n,\n.\n英美\n\n\n125.124.024,25\n.\n,\n欧洲\n\n\n125 124 024,25\n \n,\n国际单位制（逗号地区）\n\n\n125 124 024.25\n \n.\n国际单位制（句点地区）\n\n\n表并列中文：不要用逗号代替顿号\n\n❌ 警方还组织数千民兵专门看护桥梁，过街天桥，涵洞等重点部位。\n✔️ 警方还组织数千民兵专门看护桥梁、过街天桥、涵洞等重点部位。\n\n英文：用逗号表示并列关系（不存在顿号）\n\n❌ We need seven people: three students、three engineers、and a professor.\n✔️ We need seven people: three students, three engineers, and a professor.\n\n不存在的标点符号顿号：\n没有顿号 、，用逗号 , 表并列：She slowly, carefully, and deliberately moved the box.\n书名号：\n英文中没有书名号 《》，用斜体（Italic，意大利体）表示书名：\n\nThe title of Stephen R. Covey’s book is The 7 Habits of Highly Effective People.\n\n英文书名或电影名改用中文表达时，双引号应改为书名号：\n\n英文： He published an article entitled “The Future of the Aviation”.\n中文：他发表了一篇名为《航空业的未来》的文章。\n\n其他符号多空一格运算符\n\n✔️ 20 ± 2%、p &lt; 0.01、1 + 1 &#x3D; 2\n❌ 20±2%、p&lt;0.01、1+1&#x3D;2\n\n版权标识 ©\n\n✔️ Copyright © 2021 LISIR 保留所有权利。\n❌ Copyright©2021 LISIR 保留所有权利。\n\n摄氏度符号与数字之间\n通常情况最好用「°C」，即「度数符号（U+00B0 ° DEGREE SIGN，十进制 176）」然后加上英文大写字母 U+0043 C LATIN CAPITAL LETTER C，而非用兼容概有 CJK 编码的兼容字元 U+2103 ℃ DEGREE CELSIUS，十进制 8451；后者在大部分字型都是全形字元。\n如何输入\n\nWindows\n\n°：按 Alt 不放，然后按 0 1 7 6（数字部分要用键盘右方的数字区输入），完成后放开 Alt 键；或者在微软拼音里输入 du。\nC：再按 Shift + C，就可以打出 °C。\n\n\nmacOS：\n\n°：以「爱尔兰－延伸」输入法为例，按 Alt/Option + Shift + 8。\nC：再按 Shift + C，就可以打出 °C。\n\n\n\n以上内容节选自 维基百科\n\n✔️ 科学家通过分析卫星数据发现地球的最低温出现在南极东部高原，达到零下 100 °C。\n❌ 科学家通过分析卫星数据发现地球的最低温出现在南极东部高原，达到零下 100°C。\n\n不必空格货币符号与数字之间\n\n✔️ 一碗原味猪肉汤饭只要 ￥10。\n❌ 一碗原味猪肉汤饭只要 ￥ 10。\n\n百分号与数字之间\n百分号（%）不是单位，因此应该紧挨在数字后面。\n\n✔️ 去年营业额增长 5%\n❌ 去年营业额增长 5 %\n\n倍数与单位之间\n\n✔️ 2x、3n\n❌ 2 x、3 n\n\n其他规范时间\n✔️ 12:05（半角冒号）\n❌ 12:5（未补零）\n❌ 12：5（全角冒号）\n\n日期样式一：\n\n✔️ 2018-09-07（推荐）\n✔️ 2018.09.07\n❌ 2018-9-7\n\n样式二：\n\n✔️ 2018 年 9 月 7 日（简洁醒目）\n✔️ 二零一八年九月七日（庄重典雅）\n❌ 2018年09月07日\n\n数字农历月日：\n\n✔️：腊月二十三、八月十五中秋节（选用汉字数字）\n❌：腊月23、8月15中秋节\n\n阿拉伯数字与汉字数字同时使用：\n\n如果一个数值很大，数值中的「万」和「亿」单位可以采用汉字数字，其余部分采用阿拉伯数字。例如：我国 1982 年人口普查人数为 10 亿零 817 万 5288 人\n除上面情况之外的一般数值，不能同时采用阿拉伯数字与汉字数字。例如：108 可以写作「一百零八」，但不应写作以「1 百零 8」「一百 08」；4000 可以写作「四千」，但不应写作「4 千」\n\n数值范围表示区间时，保留两端的单位。\n\n✔️ 梨园乡种植的巨风葡萄今年已经进入了丰产期，亩产 1000 公斤至 1500 公斤。（或用 到）\n⚠️ 梨园乡种植的巨风葡萄今年已经进入了丰产期，亩产 1000 公斤 ～ 1500 公斤。（浪纹号 ～）\n❌ 梨园乡种植的巨风葡萄今年已经进入了丰产期，亩产 1000 ~ 1500 公斤。（波浪号 ~）\n✔️ 此事件有 5% 至 10% 的可能性发生。\n❌ 此事件有 5至10% 的可能性发生。\n✔️ 56 mm ± 2 mm、（56 ± 2）mm、（56 ± 1）%\n⚠️ 10 × 15 × 20 mm（特例）\n⚠️ 10 mm × 15 mm × 20 mm（过于冗余？存疑）\n\n连接号\n\n\n（全形）浪纹号（颚化符）\n波浪号\n\n\n\n～\n~\n\n\nU+FF5E FULLWIDTH TILDE\nU+007E TILDE\n\n\n占一个汉字的位置\n占半个汉字的位置\n\n\n全角模式下，Shift + ~（Esc 的下方）\n半角模式下，Shift + ~（Esc 的下方）\n\n\n如何输入正确的浪纹号 ～ 来标示数值范围的起止？以微软拼音为例：\n\n切换到全角状态（Shift + Space）\nShift + ~（Esc 的下方）\n切换回半角状态（Shift + Space），接着输入其他内容\n\n因此，输入正确的浪纹号是一件很麻烦的事，推荐使用 至 或者 到 代替 ～ ：-20°C 至 -10°C。\n有序列表- ✔️ 在小数点后面空一格（参考 Markdown 的写法）  1. 静音  2. 关机  3. 睡觉- ❌ 未在小数点后空一格  1.静音  2.关机  3.睡觉\n\n- ✔️ 顿号后面不用空一格  1、静音  2、关机  3、睡觉- ❌ 顿号后面空一格  1、 静音  2、 关机  3、 睡觉\n\n电话号码\n✔️ 156 1024 1024（3-4-4 的格式，方便记忆和拨号）\n❌ 15610241024\n\n首行顶格\n段落首行缩进 2 个字符是纸媒时代的旧习，文章的排版像狗啃了一样 在数字时代（特别是在移动端）\n首行顶格\n段落之间用空行隔开\n\n\n\n争议之处项目列表句末不加分号或句号✔️\n\n早上吃鸡蛋和水果\n中午吃蔬菜沙拉和鱼\n晚上吃番薯和一小碗饭\n睡前喝一瓶纯牛奶\n\n❌\n\n早上吃鸡蛋和水果；\n中午吃蔬菜沙拉和鱼；\n晚上吃番薯和一小碗饭；\n睡前喝一瓶纯牛奶。\n\n📝（长句例外）\n\n人生第一境界：昨夜西风凋碧树。独上高楼，望尽天涯路。\n人生第二境界：衣带渐宽终不悔，为伊消得人憔悴。\n人生第三境界：众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。\n\n「直角引号」代替“蝌蚪”引号理由：\n\n“蝌蚪”引号在数字世界容易渲染出错，是半角还是全角？是英文还是中文，飘忽不定。\n直角引号与方块字（汉字）更契合，但并未不是国标和主流排版届的共识。\n克制使用引号，避免句子被切得太碎。\n\n输入：\n\n✔️ 如何输入「直角引号」？\n❌ 如何输入“直角引号”？\n\n注意：\n当引号表示讽刺、反语暗示时，使用弯引号：工作使我“快乐”。『』 为二级引号，即 「」 是最外层的引号。\nTa 们\n📝 虽然「他们」在表达上可以泛指男女，但在形式上给人单指男性的印象，-所以我推荐使用「他（她）们 &#x2F; ta 们 &#x2F; Ta 们 &#x2F; TA 们」泛指自己和对方以外的若干人（有男有女）\n✔️ 将来我们有了孩子，给他（她）取名字一定不能草率了。\n✔️ 将来我们有了孩子，给 Ta 取名字一定不能草率了。\n\n其他 VS 其它\n\n其他：指人\n其它：指事件、物、地方等\n\n少用斜体\n西文中有两种形状倾斜的字体：Oblique type 和 Italic type，倾斜后字形也发生的变化的是「意大利体」（Italic Type），而单纯将原字体向右倾斜而没有形变的称为伪斜体（Oblique type）。中文（汉字）的斜体实际上都是单纯将字面从正方形改为平行四边形的“伪斜体”。传统排版中，汉字一般不使用斜体。电脑的普及给字体变形带来了极大方便，才将西文这一习惯延伸到中文。by 维基百科\n\n少用下划线下划线是打字机时代的产物。在当代，它作为 超链接（URL） 的标识，不作为强调。\n风格指南中文风格好文章所具备的 3 个标志：\n\n文字简单清晰\n用词恰如其分\n描写精准、服务主题\n\n用词精确指代明确\n使用代词时（比如 其、该、此、这 等词），必须明确指代的内容，保证只有一个含义。\n\n❌ 从管理系统可以监视中继系统和受其直接控制的分配系统。\n✔️ 从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。\n\n用对 的、地、得\n\n形容词＋的＋名词：她露出了开心的笑容。\n副词＋地＋动词：她开心地笑了。\n动词＋得＋副词：她笑得很开心。\n\n变化程度\n了 表示增量，到 表示定量。\n\n增加到过去的两倍（过去为一，现在为二）\n增加了两倍（过去为一，现在为三）\n\n不能用 降低 N 倍 或 减少 N 倍 的表示法，要用 降低百分之几 或 减少百分之几。因为减少（或降低）一倍表示数值原来为一百，现在等于零。\n用语正式\n在我看来，好的文字应该是长命的，缓释的价值越多，文字越高级。高级的文字并不着力于哗众取宠的爆发，而是有与众不同的角度和观点。我们会本能的高估短期，而低估长期，文字的价值如是，生活工作也是。by 二爷（邱岳）\n\n少用网络流行语或谐音词，比如「蓝瘦香菇」、「吃枣药丸」、「图样图森破」等，因为多年以后，晚辈可能无法领悟这些速朽的辞藻，例如：\n\nLady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！\n\n不推荐只有特定人群才了解的语词，例如：\n\n魔改（即做特殊的优化）。或者插入行话时，列出必要的解释。\n\n此外还有：\n\n粉丝： 不要称呼喜欢我们的用户为「粉丝」，可以换成「用户」或「读者」。因为粉丝的说法显得不平等，而且很多人不喜欢这种称呼，它含有缺乏独立思考的意思。\n你和您：在不是很正式或没有明确的个体指代对象的时候请用「你」，如文档、博客、群发的邮件等；在指代特定个体时请用「您」，如活动邀请函等。\n不使用「温馨提示」一词。\n\n表达干练\n现在你看文件越来越厚，但里面包含的信息量越来越少。我们经常在我们开某一次会以后，出个什么文件，然后又组织好多人去辅导。按理说一般有文字阅读能力的人，有知识的人都应该能看明白，但事实上我们没有办法看明白，就因为这文件里包含着好多的词汇，它与它本身的含义是不一样的。\n\n我们崇尚精练的文风。请在检查中把对表达意思没有明显作用的字、词、句删除，在不影响表达效果的前提下把文案长度减到最短。\n\n单个句子的长度尽量保持在 20 个字以内。\n20 个至 29 个字的句子，可以接受。\n30～39 个字的句子，语义必须明确，才能接受。\n多于 40 个字的句子，在任何情况下都不能接受。\n\n例如：\n\n❌ 本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。\n✔️ 本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。\n\n少用形容词：\n\n❌ 此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。\n✔️ 此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。\n\n少用复合句：\n尽量使用简单句和并列句：\n\n❌ 那个昨天生病的人没有参加会议。\n✔️ 他昨天生病了，没有参加会议。\n\n少用连词：\n连词用得过多，会影响句子的节奏和美感。\n比如，清风徐来，水波不兴，这句话就暗含了因果关系，但我们写的时候，难道要写成，因为清风徐来，所以水波不兴吗？\n再比如，秦末天下大乱，群雄并起，这句话也暗含了因果关系，按照中文写作的习惯，没有必要写成，由于秦末天下大乱，群雄并起。by 涵柏\n少用万能动词：\n比如造成、进行这样的弱动词：\n\n❌ 飞机失事，造成一百多人死亡。\n✔️ 飞机失事，死了一百多人。\n\n结构清晰多用主动语态：\n中文的正常表达，是主语 + 动词 + 名词，要改变句式顺序，一定要有特别的原因。例如强调主语不如意或遇到出乎意料的情况。\n\n❌ 蛇把小王咬了。\n✔️ 小王被蛇咬了。\n\n因为蛇和我们并不同类，很难引起我们的共鸣，把小王放在主语位置，既突出了小王的不如意，也能让读者有一种强烈的代入感。\n想写一篇文章，谈快餐对中国文化的影响：\n\n❌ 中国人越来越喜欢快餐……\n✔️ 快餐逐渐被中国人喜欢……\n\n因为文章主旨就是为了强调快餐。\n更多的例子如下：\n\n❌ 假如此软件尚未被安装……\n✔️ 假如尚未安装这个软件……\n❌ 他被选为议长。\n✔️ 他当选为议长。\n\n多用肯定句：\n同样一个意思，尽量使用肯定句表达，不使用否定句表达。\n\n❌ 请确认没有接通装置的电源。\n✔️ 请确认装置的电源已关闭。\n\n少用双重否定句：\n\n❌ 没有删除权限的用户，不能删除此文件。\n✔️ 用户必须拥有删除权限，才能删除此文件。\n\n英文风格复数英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。\n\n英文：⋯information stored in random access memory (RAMs)⋯\n中文：……存储在随机存取存储器（RAM）里的信息……\n\n缩写第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。\nIOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用「IOC」了。\n译名品牌、产品名、人名、地名等特殊名词，如果来自英文，请使用英文以避免在不同译法之间选择。\n文档名称\n文档的文件名不得含有空格。\n文件名建议只使用小写字母，不使用大写字母（可以提高打字速度）。\n❌ TroubleShooting.md\n✔️ troubleshooting.md📝 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。\n\n\n文件名包含多个单词时，单词之间建议使用半角的连字符（-）分隔。\n❌ advanced_usage.md\n✔️ advanced-usage.md\n\n\n\n文章结构原则\n一个段落只表达一个主题。\n段首：用一个中心句点题，对全段内容进行概述。\n段中：为核心句服务。\n段尾：扣题。\n\n\n一个段落的长度不能超过七行，最佳段落长度小于等于四行。\n\n标题层级:\n\n一级标题（h1）：文章的标题\n二级标题（h2）：文章主要部分的大标题\n三级标题（h3）：二级标题下面一级的小标题\n四级标题（h4）：三级标题下面某一方面的小标题\n\n原则:\n\n一级标题下，不能直接出现三级标题。\n标题要避免孤立编号（即同级标题只有一个）。\n下级标题不重复上一级标题的内容。\n谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。\n\n文章引言文章引言非常重要。它的作用主要是用于网站首页展示和微博分享，它是为了吸引读者阅读文章而存在，它的目的是让读者能够仅通过这一小段话，就能迅速了解到这篇文章的大致内容。因此，引言实际就是文章的「内容概要」，而非文章的开头首段。\n我们建议通常在写完整篇文章后，再结合内容大纲撰写引言。引言务必要讲清两个问题：\n\n是什么？（例如：这是一款什么应用？这篇文章是讲的什么？）\n为什么？（例如：这款应用之所以被推荐，是由于它有哪些特色&#x2F;亮点？）\n\n引言的语言文字务必要清晰、直观、简洁，通常字数需控制在 90 字左右。\n引用规范引用第三方内容时，应注明出处。\n\nOne man’s constant is another man’s variable. — Alan Perlis\n\n如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。\n\n本文转载自 「安卓果酱」的写作规范。\n\n若文章为部分编译，则需在文末注明作者和出处。\n\n本文部分内容编译自 Apple。\n本文部分观点来自「小道消息」的微博。\n\n如果格式不允许超链接，请以文本方式直接给出原文链接。如果原文链接太长影响美观，可以使用短链接服务。\n\n本文转载自 WikiQuote：http://bit.ly/UlHIdN\n\n使用外部图片时，必须在图片下方或文末标明来源。\n\n本文部分图片来自 Wikipedia。\n题图来自：《春娇与志明》截图。\n\n","categories":["学习笔记"],"tags":["写作技巧"]},{"title":"虚拟机中搭建 Hadoop 集群","url":"/posts/9c43781b/","content":"Hadoop 是一个由 Apache 基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop 实现了一个分布式文件系统（ Distributed File System），其中一个组件是 HDFS（Hadoop Distributed File System）。HDFS 有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS 放宽了（relax）POSIX 的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop 的框架最核心的设计就是：HDFS 和 MapReduce。HDFS 为海量的数据提供了存储，而 MapReduce 则为海量的数据提供了计算。\n\n\n\n提前准备系统\nCPU虚拟化：已启用\n\n安装\n运行虚拟机的工具：VMware (激活密钥：MC60H-DWHD5-H80U9-6V85M-8280D)\nSSH 工具：FinalShell\n\n下载\nLinux 镜像：CentOS\nJava 环境：JDK8\nHadoop 环境：Hadoop\n\n配置模板虚拟机安装虚拟机\n虚拟机配置：处理器1C 内存1G 硬盘30G\n\n网络设置\n开始前可以使用 ip addr 查看虚拟机的 IP，然后使用 SSH 工具连接虚拟机方便后续配置信息的修改。\n\n修改镜像源到国内点我查看\n安装 Linux 必备工具\n安装\n  #CentOSyum install -y curl wget vim zip sudo rsync openssh-server openssh-clients#Debianapt install -y curl wget vim zip sudo rsync\n\n关闭防火墙\n查看防火墙的状态\n  systemctl status firewalld.service\n\n关闭防火墙\n  systemctl stop firewalld.service\n\n关闭防火墙自动启动\n  systemctl disable firewalld.service\n\n开启防火墙\n  systemctl start firewalld.service\n\n开启防火墙自动启动\n  systemctl enable firewalld.service\n\n静态 IP 配置\n备份网络配置文件\n  # CentOSsudo cp /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-ens33.bak# Debiansudo cp /etc/network/interfaces  /etc/network/interfaces.bak\n\n编辑网络配置文件\n  # CentOSsudo vim /etc/sysconfig/network-scripts/ifcfg-ens33# Debiansudo vim /etc/network/interfaces\n\nCentOS 参考配置\n  TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;5a646ee0-bc7e-4793-83b9-1784f237c07d&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=192.168.10.102GATEWAY=192.168.10.2NETMASK=255.255.255.0DNS1=114.114.114.114\n\nDebian 参考配置：\n  # The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceallow-hotplug ens33iface ens33 inet staticaddress 192.168.10.100netmask 255.255.255.0gateway 192.168.10.2nameserver 114.114.114.114\n\n修改主机名称\n编辑 hostname 文件\n  sudo vim /etc/hostname\n\n修改主机名称映射\n编辑 hosts 文件\n  sudo vim /etc/hosts\n\n参考配置：\n  127.0.0.1       localhost127.0.1.1       hadoop100192.168.10.100  hadoop100192.168.10.101  hadoop101192.168.10.102  hadoop102192.168.10.103  hadoop103192.168.10.104  hadoop104\n\n重启使配置生效\n  reboot\n\n\n因为设置了静态 IP，所以 SSH 工具中的主机 IP 也需要对应修改。\n\n\n查看是否生效\n  #查看 IPip addr#查看主机名hostname\n\n权限设置\n允许 root 用户以 SSH 方式登录\n  #使用 vim 编辑 sshd_config 文件sudo vim /etc/ssh/sshd_config\n\n  找到下面这一段：\n  #PermitRootLogin prohibit-password\n\n  修改成下面这一段，注意前面的 # 号需要去掉：\n  PermitRootLogin yes\n\n  然后重启 SSH 服务：\n  sudo service sshd restart\n\n配置普通用户具有 root 权限，方便后期使用 sudo 执行 root 权限的命令\n  #使用 vim 编辑 sudoers 文件sudo vim /etc/sudoers\n\n  找到下面这一段：\n  %wheel  ALL=(ALL)       ALL\n\n  在它的下面添加一行：\n  &lt;username&gt;  ALL=(ALL)       NOPASSWD:ALL#替换 &lt;username&gt; 为你自己的用户名\n\n  参考配置：\n  ## Allow root to run any commands anywhere root    ALL=(ALL)       ALL## Allows members of the &#x27;sys&#x27; group to run networking, software, ## service management apps and more.# %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS## Allows people in group wheel to run all commands%wheel  ALL=(ALL)       ALLhadoop  ALL=(ALL)       NOPASSWD:ALL## Same thing without a password# %wheel        ALL=(ALL)       NOPASSWD: ALL\n\n克隆虚拟机\n以上步骤完成后关闭虚拟机，然后进行克隆，克隆方法选择创建完整克隆\n克隆三台名为 hadoop102 到 hadoop104 的虚拟机\n分别修改 hadoop102 到 hadoop104 的静态 IP 地址和主机名称\n\nSSH 连接\n修改 Windows 主机映射文件\n  修改此路径中的 hosts 文件C:\\Windows\\System32\\drivers\\etc\\Windows7 用户可以直接修改此文件Windows10 用户需要复制此文件到其他位置修改，然后再覆盖原始的文件\n\n  参考配置：\n  #将如下内容添加到 hosts 文件最后192.168.10.100 hadoop100192.168.10.101 hadoop101192.168.10.102 hadoop102192.168.10.103 hadoop103192.168.10.104 hadoop104\n\n使用 FinalShell 添加 SSH 连接\n  名称：hadoop102 (可自定义)主机：hadoop102端口：22名称：hadoop103 (可自定义)主机：hadoop103端口：22名称：hadoop104 (可自定义)主机：hadoop104端口：22\n\n安装 JDK &amp; Hadoop\n首先在 hadoop102 上安装，后续可以使用 scp 和 rsync 命令复制或同步到 hadoop103、hadoop104。\n\n创建安装目录#创建安装目录sudo mkdir /opt/module /opt/software#修改目录所有者sudo chown &lt;user&gt;:&lt;group&gt; /opt/module/ /opt/software/#&lt;user&gt;:&lt;group&gt; 需要替换成自己设置的用户名和用户组，例如：sudo chown hadoop:hadoop /opt/module/ /opt/software/\n\n\n使用 SSH 工具上传压缩包到 &#x2F;opt&#x2F;software 目录中\n\n解压\n注意：如果下载的版本不一样，压缩包名称也会不一样，自行修改。\n\ntar -zxvf /opt/software/jdk-8u212-linux-x64.tar.gz -C /opt/moduletar -zxvf /opt/software/hadoop-3.1.3.tar.gz -C /opt/module\n\n配置环境变量#生成 my_env.sh 文件进行编辑sudo vim /etc/profile.d/my_env.sh\n\n参考配置：\n#JAVA_HOMEexport JAVA_HOME=/opt/module/jdk1.8.0_212export PATH=$PATH:$JAVA_HOME/bin#HADOOP_HOMEexport HADOOP_HOME=/opt/module/hadoop-3.1.3export PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbin\n\n更新环境变量source /etc/profile\n\n验证环境变量是否生效#查看版本java -versionhadoop version\n\nscp &amp; rsync 命令定义\nscp 可以实现服务器与服务器之间的数据拷贝 (from server1 to server2)\nrsync 主要用于备份和镜像，具有速度快、避免复制相同内容和支持符号链接的优点\n差异：用 rsync 做文件的复制要比 scp 的速度快，rsync 只对差异文件做更新，scp 是把所有文件都复制过去\n\n基本语法\nscp\n  scp -r $pdir/$fname $user@$host:$pdir/$fname$pdir/$fname #表示要拷贝的文件路径/名称$user@$host:$pdir/$fname #表示目的地的用户@主机:目的地路径/名称#带参数 -r 表示拷贝目录，不带 -r 则拷贝文件\n\nrsync\n  rsync -av $pdir/$fname $user@$host:$pdir/$fname#参数 -a 表示归档模式，表示以递归方式传输文件，并保持所有文件属性#参数 -v 显示过程\n\n实操\nscp\n  #将 hadoop102 中的 /opt/module 拷贝到 hadoop103 上scp -r /opt/module hadoop@hadoop103:/opt#从 hadoop102 中拷贝 /opt/module 到 hadoop103 上scp -r hadoop@hadoop102:/opt/module /opt\n\nrsync\n  #同步 hadoop102 和 hadoop103 中的 /opt/module/hadoop-3.1.4rsync -av /opt/module/hadoop-3.1.4 hadoop@hadoop103:/opt/module/hadoop-3.1.4\n\nxsync 分发脚本#在 /bin 目录下生成 xsync 文件并编辑sudo vim /bin/xsync\n\n参考配置：\n#!/bin/bash#1. 判断参数个数if [ $# -lt 1 ]; then  echo Not Enough Arguement!  exitfi#2. 遍历集群所有机器for host in hadoop102 hadoop103 hadoop104; do  echo =============== $host ===============  #3. 遍历所有目录，挨个发送  for file in $@; do    #4. 判断文件是否存在    if [ -e $file ]; then      #5. 获取父目录      pdir=$(        cd -P $(dirname $file)        pwd      )      #6. 获取当前文件的名称      fname=$(basename $file)      ssh $host &quot;mkdir -p $pdir&quot;      rsync -av $pdir/$fname $host:$pdir    else      echo $file does not exists!    fi  donedone\n\n#让 xsync 具有可执行权限sudo chmod 777 /bin/xsync\n\n#使用 xsync 分发环境变量sudo xsync /etc/profile.d/my_env.sh\n\n#然后在每台主机上运行以下命令更新环境变量source /etc/profile\n\nSSH 免密登录#分别在 hadoop102、hadoop103、hadoop104 中创建 ssh 密钥ssh-keygen -t rsa\n\n#查看 ssh 密钥ssh-keygen -l\n\n#分别将公钥拷贝到 hadoop102、hadoop103、hadoop104 中ssh-copy-id hadoop102ssh-copy-id hadoop103ssh-copy-id hadoop104\n\n集群配置集群部署规划\n注意：NameNode 和 SecondaryNameNode 不要安装在同一台服务器上。ResourceManager 也很消耗内存，不要和 NameNode、SecondaryNameNode 配置在同一台服务器上\n\n\n\n\n\nhadoop102\nhadoop103\nhadoop104\n\n\n\nHDFS\nNameNodeDataNode\nDataNode\nSecondaryNameNodeDataNode\n\n\nYARN\nNodeManager\nResourceManagerNodeManager\nNodeManager\n\n\n自定义配置文件\ncore-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml 四个配置文件都存放在 $HADOOP_HOME&#x2F;etc&#x2F;hadoop 这个目录下，用户可以根据项目需求重新进行修改配置。\n\n核心配置vim $HADOOP_HOME/etc/hadoop/core-site.xml\n\n参考配置：\n&lt;configuration&gt;  &lt;!-- 指定 NameNode 的地址 --&gt;  &lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://hadoop102:8020&lt;/value&gt;  &lt;/property&gt;  &lt;!-- 指定 hadoop 数据的存储目录 --&gt;  &lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/opt/module/hadoop-3.1.3/data&lt;/value&gt;  &lt;/property&gt;  &lt;!-- 配置 HDFS 网页登录使用的静态用户为 hadoop --&gt;  &lt;property&gt;    &lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt;    &lt;value&gt;hadoop&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;\n\nHDFS 配置vim $HADOOP_HOME/etc/hadoop/hdfs-site.xml\n\n参考配置：\n&lt;configuration&gt;  &lt;!-- NameNode Web 访问地址 --&gt;  &lt;property&gt;    &lt;name&gt;dfs.namenode.http-address&lt;/name&gt;    &lt;value&gt;hadoop102:9870&lt;/value&gt;  &lt;/property&gt;  &lt;!-- SecondaryNameNode Web 访问地址 --&gt;  &lt;property&gt;    &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;    &lt;value&gt;hadoop104:9868&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;\n\nYARN 配置vim $HADOOP_HOME/etc/hadoop/yarn-site.xml\n\n参考配置：\n&lt;configuration&gt;  &lt;!-- 指定 MR 走 shuffle --&gt;  &lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;  &lt;/property&gt;  &lt;!-- 指定 ResourceManager 的地址 --&gt;  &lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;hadoop103&lt;/value&gt;  &lt;/property&gt;  &lt;!-- 环境变量的继承 --&gt;  &lt;property&gt;    &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;    &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;\n\nMapReduce 配置vim $HADOOP_HOME/etc/hadoop/mapred-site.xml\n\n参考配置：\n&lt;configuration&gt;  &lt;!-- 指定 MapReduce 程序运行在 YARN 上 --&gt;  &lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;\n\nworkers 配置\n注意：该文件中添加的内容结尾不允许有空格，文件中不允许有空行。\n\nvim $HADOOP_HOME/etc/hadoop/workers\n\n参考配置：\nhadoop102hadoop103hadoop104\n\n分发配置文件xsync $HADOOP_HOME/etc/hadoop\n\n群起集群\n启动集群\n  如果集群是第一次启动，需要在 hadoop102 节点格式化 NameNode\n\n注意：格式化 NameNode，会产生新的集群 id，导致 NameNode 和 DataNode 的集群 id 不一致，集群找不到已往数据。如果集群在运行过程中报错，需要重新格式化 NameNode 的话，一定要先停止 namenode 和 datanode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格化。\n\n  hdfs namenode -format\n\n  在 hadoop102 上启动 HDFS\n  start-dfs.sh\n\n  在 hadoop103 上启动 YARN\n  start-yarn.sh\n\n  查看运行状态\n  jsp\n\n报错解决办法Hadoop 提示 ERROR: Attempting to operate on yarn resourcemanager as root 的解决方法\n在 start-dfs.sh 和 stop-dfs.sh 文件的顶部添加以下参数：\nHDFS_DATANODE_USER=rootHADOOP_SECURE_DN_USER=hdfsHDFS_NAMENODE_USER=rootHDFS_SECONDARYNAMENODE_USER=root\n\n在 start-yarn.sh 和 stop-yarn.sh 文件的顶部添加以下参数：\nYARN_RESOURCEMANAGER_USER=rootHADOOP_SECURE_DN_USER=yarnYARN_NODEMANAGER_USER=root\n\n集群奔溃处理办法\n停止集群\n  stop-dfs.sh\n\n删除 data 和 logs 目录\n\n注意：每台服务器上的 data 和 logs 目录都需要删除\n\n  rm -rf $HADOOP_HOME/data $HADOOP_HOME/logs\n\n格式化集群\n  hdfs namenode -format\n\n启动集群\n  start-dfs.sh\n\n两个常用脚本集群启停脚本#在 /bin 目录下生成 xsync 文件并编辑sudo vim /bin/myhadoop\n\n参考配置：\n#!/bin/bashif [ $# -lt 1 ]; then  echo &quot;No Args Input...&quot;  exitficase $1 in&quot;start&quot;)  echo &quot;=============== 启动 hadoop 集群 ===============&quot;  echo &quot;--------------- 启动 hdfs ---------------&quot;  ssh hadoop102 &quot;$HADOOP_HOME/sbin/start-dfs.sh&quot;  echo &quot;--------------- 启动 yarn ---------------&quot;  ssh hadoop103 &quot;$HADOOP_HOME/sbin/start-yarn.sh&quot;  echo &quot;--------------- 启动 historyserver ---------------&quot;  ssh hadoop102 &quot;$HADOOP_HOME/bin/mapred --daemon start historyserver&quot;  ;;&quot;stop&quot;)  echo &quot;=============== 停止 hadoop 集群 ===============&quot;  echo &quot;--------------- 停止 historyserver ---------------&quot;  ssh hadoop102 &quot;$HADOOP_HOME/bin/mapred --daemon stop historyserver&quot;  echo &quot;--------------- 停止 yarn ---------------&quot;  ssh hadoop103 &quot;$HADOOP_HOME/sbin/stop-yarn.sh&quot;  echo &quot;--------------- 停止 hdfs ---------------&quot;  ssh hadoop102 &quot;$HADOOP_HOME/sbin/stop-dfs.sh&quot;  ;;*)  echo &quot;Input Args Error...&quot;  ;;esac\n\n#让 myhadoop 具有可执行权限sudo chmod 777 /bin/myhadoop\n\n查看 Java 进程脚本#在 /bin 目录下生成 xsync 文件并编辑sudo vim /bin/jpsall\n\n参考配置：\n#!/bin/bashfor host in hadoop102 hadoop103 hadoop104; do  echo &quot;=============== $host ===============&quot;  ssh $host jpsdone\n\n#让 jpsall 具有可执行权限sudo chmod 777 /bin/jpsall\n","categories":["学习笔记"],"tags":["Hadoop","集群","虚拟机"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n\n","categories":["无处安放"],"tags":["Hello World"]},{"title":"中国银行借记卡申请指南","url":"/posts/c8b70a06/","content":"本文信息仅为网络收集，但可以确保均为官方渠道，信息内容不一定准确，本人不承诺信息准确并且不对申请成功与否和时效做任何担保，同时不对文中内容拥有解释权，详细请拨打 95566 或询问银行网点柜台。\n\n\n\n卡面仅收录部分卡面，其他卡面不做收录！\n非人哉两张，竖版，不占用借记卡位，首年免年费，年费10元，只限外币，时效6天\n中银万事达非人哉 小玉&#x2F;白泽 借记卡 申请链接\n莫奈卡一张，横版，占用借记卡位，首年免年费，年费50元，只限外币，为万事达世界卡，支持19种外币，时效未知\n中国银行万事达世界借记卡 申请链接\n冬奥卡一张，竖版，VISA国际联名卡，占用借记卡位，首年免年费，年费50元，只限外币，但支持19种外币，时效2天开始审批\n中国银行VISA冬奥借记卡 申请链接\n冰雪卡一张，横版，占用借记卡位，首年免年费，年费10元，含人民币账户并且支持19种外币，享有银联白金卡权益，时效未知\n中国银行长城冰雪IC借记卡 申请链接\n天依卡一张，横版，占用借记卡位，终身免年费，无年费，为纯银联卡，人民币账户，时效17天\n中国银行天依小柠檬联名借记IC卡 申请链接\n茈绫卡一张，竖版，占用借记卡位（一类卡限首次一张，后续均为二类，上限四张），此卡免年费，无年费，为纯银联卡，人民币账户，时效未知\n中国银行长城CCG联名借记卡 申请链接\n进度查询链接注意事项\n借记卡可以不激活，但永久记录在名下。\n申请时确保中国银行有你的个人信息。\n个人信息更改请在“中银客信通”小程序修改。\n填写地址请精确到**号，不能带有空格。\n除小玉卡外，持中国银行实体借记卡不能超四张。\n信息表明借记卡不激活不收年费，请咨询网点。\n激活外币卡可与任意网点设备激活，无需现金。\n开户网点均为中国银行上海各支行。\n办理销户可以在任意网点。\n办理挂失补卡，换卡业务需到开户行上海办理。\n购汇转账需要中行同名账户下的一类银联卡。\n申请卡位既网申未开的卡最多4张。\n\n","categories":["无处安放"],"tags":["借记卡","结汇购汇"]},{"title":"小米全新 MiSans 字体！","url":"/posts/5c981987/","content":"12月28日，小米推出了全新的小米 12 系列产品以及 MIUI 13 等新品，同时还带来了一款全新系统字体 MiSans。MIUI 13 便是采用了这种全新的系统字体 MiSans。\n\n\n\n字体介绍MIUI 13的字体Mi Sans”和以往字体相比，前者加入了更多椭圆形元素以及更柔和的线条，这让字体看起来更舒适，其共包含29093个字符，支持多种语言。\n按照MIUI 13官方的说法，全新系统字体MiSans，平直有力，极简设计，更有利与屏幕显示。具有丰富的Opentype 特性，可根据特定需求来选择不同形态的字符，例如某些标点符号可以根据周围字母的形态自动调整至合适的位置，让排版更细腻精致。\n并且面向社会大众开放下载，免费可商用。\n字体展示\n字体功能调用及实现font-feature 属于 Opentype 中的高级排版功能，也就是可以让字体排版更加精致，符合实际设计、开发需求，可根据特定设计需求选择不同的字体形态。大部分软件都可以通过 Opentype 面板访问此功能。（部分特性在MIUI系统应用中不会默认生效）\n下载地址MiSans提供了非常多的十种字重，基本涵盖了全部场景。\n\nMiSans-Heavy.ttf\nMiSans-Semibold.ttf\nMiSans-Thin.ttf\nMiSans-Medium.ttf\nMiSans-Normal.ttf\nMiSans-Regular.ttf\nMiSans-Light.ttf\nMiSans-Demibold.ttf\nMiSans-ExtraLight.ttf\nMiSans-Bold.ttf\n打包下载\n\n","categories":["无处安放"],"tags":["字体"]},{"title":"233 一键安装脚本","url":"/posts/7b78e0bd/","content":"V2Ray官网\nV2Ray是一个于Shadowsocks之后非常好用的代理软件，但是由于V2Ray的配置略复杂，GUI客户端不完善，所以V2Ray并没有像Shadowsocks在科学上网人群之中那么流行。\n不过我想，像我这种小小白萌新，更需要的是一个好用的一键安装脚本……\n所以，此脚本是为了方便像我这种小小白萌新更加容易去使用V2Ray，配置V2Ray。希望对你有帮助^_^\n\n\n\n安装或卸载要求：Ubuntu16+&#x2F;Debian8+&#x2F;CentOS7+系统\n推荐使用Debian9系统，脚本会自动启用BBR优化。\n备注：不推荐使用Debian8系统，因为Caddy申请证书可能会出现一些莫名其妙的问题\n使用root用户输入下面命令安装或卸载\nbash &lt;(curl -s -L https://git.io/v2ray.sh)\n\n备注：安装完成后，输入v2ray即可管理V2Ray，如果提示你的系统不支持此脚本，那么请尝试更换系统\n\n","categories":["科学上网"],"tags":["代理搭建"]},{"title":"V2RayN 使用教程","url":"/posts/a7dd8ad0/","content":"v2rayN 是 PC 平台上一个对新手比较友好的 v2ray Windows 客户端。\n写个简单的 v2rayN 使用教程帮助新手。\n\n\n\n下载V2RayN下载链接：https://github.com/2dust/v2rayN/releases/latest\n然后点击v2rayN-Core.zip下载\n\n下载好了之后，解压，然后打开解压的文件夹\n目录结构大概如下图所示：\n\n配置V2RayN双击v2rayN.exe启动，然后在任务栏托盘找到V2RayN图标并双击它\n添加一个VMess服务器\n","categories":["科学上网"],"tags":["v2rayN"]},{"title":"一键搭建 Telegram 的 MTProto 代理","url":"/posts/1079bf71/","content":"MTProto 协议是 Telegram 为了对抗网络封锁开发的专用代理（MTProxy）协议，目前全平台的 TG 客户端中都支持 MTProto 协议和 MTProxy 代理。有了 MTProxy 代理，即使没有 VPN 或者其他代理的情况下，也能顺畅访问 TG。\n\n\n\n一键搭建 Telegram 的 MTProto 代理第一步，请准备一台境外的 VPS，操作系统选 CentOS7&#x2F;8、Ubuntu16&#x2F;18&#x2F;20，或者 Debian8&#x2F;9&#x2F;10；\n第二步，SSH 登录到服务器；\n第三步，执行下面的命令一键搭建 Telegram 的 MTProto 代理：\n#创建文件夹mkdir /home/mtproxy &amp;&amp; cd /home/mtproxy#输入命令回车curl -s -o mtproxy.sh https://raw.githubusercontent.com/ellermister/mtproxy/master/mtproxy.sh &amp;&amp; chmod +x mtproxy.sh &amp;&amp; bash mtproxy.sh\n\n\n按照提示输入一个端口号并回车（端口号随便设置，不和其他软件冲突即可，注意端口是否开启）；\n管理端口随意，伪装域名可设置其他的，TAG 看自己需求，不需要推广可直接回车；\n\n第四步，接下来打开 TG 客户端，参考下图的操作添加自定义代理，选择 MTPROTO，将一键脚本输出的 IP、端口和密钥填上去，点击保存：\n\n接下来，就可以在不开启代理或 VPN 的情况下使用 TG 客户端了。\n注意事项\n目前 MTProto 已经发展到第三代，已经不建议使用 v2ray 内置的 MTProto 来搭建\n本脚本使用了 9seconds 的 docker 镜像搭建；\n因为 docker 访问外网需求，因此禁用了 VPS 的防火墙。如果你的 VPS 用于网站等重要业务，不建议使用本脚本搭建；\n如果有国内 VPS，建议使用中转，防止被封；\n\n","categories":["科学上网"],"tags":["代理搭建"]},{"title":"科学上网工具哪个好？","url":"/posts/4c1543f8/","content":"本文为您科普VPN&#x2F;SS&#x2F;SSR&#x2F;V2Ray&#x2F;Xray&#x2F;Trojan&#x2F;Trojan-Go和WireGuard的前世今生、区别和关系以及梯子软件的前景。自从天朝有了言论管制，科学上网的话题就一直存在，于是大量的梯子软件应运而生。但是GFW与这些梯子软件的斗争从来都没有停止过，一直是此消彼长，墙越来越高，科学上网技术也是持续突破，不断涌现出新技术、新工具。现在最主流的科学上网技术有VPN&#x2F;SS&#x2F;SSR&#x2F;V2Ray&#x2F;Trojan&#x2F;Trojan-Go，还有小众的WireGuard、Brook、Snell和NaiveProxy等，本篇文章不讨论Brook、NaiveProxy以及Snell协议。SS是科学上网代理协议的鼻祖，Snell和Brook是小众协议，Snell协议一直没有开源，是iOS平台非常知名的Surge软件团队开发的专属协议，Brook配套设施不完善；其中，VPN&#x2F;SS&#x2F;SSR最为出名，V2Ray和Trojan&#x2F;Trojan-Go作为新星，正在受到越来越多的关注和使用。\n\n\n\n什么是VPN&#x2F;WireGuard？VPNVPN是英文Virtual Private Network的缩写，中文名称为虚拟专用网络，是一种加密通信技术。VPN只是一个统称，它有很多的具体实现，比如PPTP、L2TP、IPSec和OpenVPN等。VPN是在公用网络上建立专用网络，并对通信进行加密，防止传输数据被识别或篡改，以保障通信的安全。当你在VPN网络中通信，就相当于通过物理的内网专线进行通信。由此可见，VPN绝不是为了科学上网而生，而是更加注重数据信息的安全，很多大型企业和高校的远程SOHO办公使用VPN较多。\nWireGuardWireGuard是最新开发的VPN协议，比主流的VPN技术有明显优势，被誉为下一代VPN。WireGuard有如下特点\nWireGuard的优点\n更轻便：以Linux内核模块的形式运行，资源占用小。更高效：相比目前主流的IPSec、OpenVPN等VPN协议，WireGuard的效率要更高。更快速：比目前主流的VPN协议，连接速度要更快。更安全：使用了更先进的加密技术。更易搭建：部署难度相对更低。更隐蔽：以UDP协议进行数据传输，比TCP协议更低调。不易被封锁：TCP阻断对WireGuard无效，IP被墙的情况下仍然可用。更省电：不使用时不进行数据传输，移动端更省电。\nWireGuard的不足\n处于研发初期，各种功能及支持有待完善。由于使用UDP协议，BBR、锐速等TCP网络加速工具，对WireGuard无效。部分运营商可能会对UDP协议进行QOS限速，WireGuard会受到一定影响。客户端分流功能较弱，对GFWList的支持不足。\nWireGuard虽然有一些不足，但WireGuard的优点更突出，而且可以拯救被封IP的VPS，所以WireGuard是SS&#x2F;SSR&#x2F;V2Ray&#x2F;Trojan等代理工具之外的一个不错的选择。\n什么是Shadowsocks？SS是Shadowsocks的缩写，中文名为影梭，为了避免关键词过滤，网友喜欢将Shadowsocks称为“酸酸”，是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。Shadowsocks由Clowwindy为了自己使用谷歌查资料而编写，Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。后来，他觉得这个东西非常好用、速度也很快，于是他在GitHub上共享了源码。在天朝，本工具被广泛用于突破GFW，以浏览被封锁、遮蔽或干扰的内容，由于Shadowsocks被广泛传播，导致作者被请去喝茶。2015年8月22日，Shadowsocks原作者Clowwindy称迫于天朝内部的压力，宣布停止维护此计划（项目），并移除其个人页面所存储的源代码，而且保证永不再参与维护更新。值得庆幸地是，Shadowsocks仍然有不少国外社区成员在维护更新。后来贡献者Librehat也为Shadowsocks补上了一些数据混淆类特性，甚至增加了类似Tor的可插拔传输层功能。\n什么是ShadowsocksR？SSR是ShadowsocksR的缩写，网民爱称“酸酸乳”，是在Shadowsocks的作者被请去喝茶之后，网名为breakwa11的用户发起的Shadowsocks的一个分支版本，它在Shadowsocks的基础上增加了一些数据混淆方式，修复了部分安全问题并提高QoS优先级。由于ShadowsocksR在协议和混淆方面做了改进，更加不容易被GFW检测到，而且兼容原Shadowsocks，并为新项目取名叫Shadowsocks-R，一开始部分代码由社区人员进行更新。由于不完全开源，也导致后来使用SS和SSR的用户分成两个阵营，互相撕逼，直到开发者Breakwa11(破娃)被人肉出来。Breakwa11(破娃)最终决定删除Shadowsocks-R项目的所有代码，并解散了所有相关群组。\n事件始末澄清：ShadowsocksR的作者一开始曾有过违反GPL，在发布二进制文件时不开放源码的争议。不过后来Shadowsocks-R项目由breakwa11采用了与Shadowsocks相同的GPL、Apache许可证、MIT许可证等多重自由软件许可协议。\n2017年7月19日，ShadowsocksR作者breakwa11在Telegram频道ShadowsocksRnews里转发了深圳市启用SS协议检测的消息并被大量用户转发，在TG圈引发恐慌。7月24日，breakwa11发布了闭源的SS被动检测程序，引发争议。7月27日，breakwa11遭到自称“ESU.TV”的不明身份人士人身攻击，对方宣称如果不停止开发并阻止用户讨论此事件将发布更多包含个人隐私的资料，随后breakwa11表示遭到对方人肉搜索并公开个人资料的是无关人士。为了防止对方继续伤害无关人士，breakwa11将删除GitHub上的所有代码、解散相关交流群组，并停止ShadowsocksR项目。\n从本质上说，Shadowsocks和ShadowsocksR的基本原理相同，都是基于socks5的代理工具，只在本地客户端和服务器端对数据包加解密，然后使用socks5协议转发加密的数据包，而不用在乎使用什么协议，所以Socks5代理比其他应用层代理速度要快得多。\n什么是socks5代理？socks5代理的原理是把你的网络数据请求先发送到你的代理服务器，然后由代理服务器转发给目标；如果目标有反馈发送到代理服务器，那么代理服务器会将数据包直接传回你的本地网络，整个过程只是数据的二次传输，并没有做额外的处理。比如，现在你在深圳，你的代理服务器在日本，如果你想要访问Google，那么你首先要把数据请求通过本地socks5代理客户端发给你在香港的服务器上的socks5代理服务端，然后你在香港的服务器将数据请求发送给Google，再把Google反馈的结果传回你的本地电脑的socks5客户端，这样就可以绕开GFW的检测而实现科学上网。\n显而易见，socks5代理的所有数据走的仍然是公网，而且在公网传输过程中，没有对数据进行任何加密和混淆，这跟VPN在公网建立虚拟专用通道传输过程中，对数据高强度加密的方式完全不同。Shadowsocks和ShadowsocksR只在客户端和服务器端对数据做了简单加密和认证，主要功能是流量转发，过墙才是主要目的。虽然现在ShadowsocksR已经停止更新很久了，而Shadowsocks仍处于社区人员的更新维护之中，不断修复漏洞并增加新功能，所以现在Shadowsocks比ShadowsocksR更强大。\n我在此提醒大家：请不要迷信SSR一定比SS强，也包括现在的V2Ray、Trojan，甚至WireGuard等，因为增加混淆意味着损失速度，混淆加密越是强悍，那么其速度和稳定性损失就越大，另外 SSR 至今已经被研究透了，而且长期没有更新维护，其流量特征是可以被GFW精准识别的，所以用SSR跟用SS没有本质区别，由于SS一直在更新维护，反而更稳定。我们要做的就是爱国爱家爱生活，勿谈国是，专心做好自己的事情就是了。天朝一直都清楚，跨境相关业务一直存在，尤其是近些年跨境电商的蓬勃发展，很多做跨境相关业务的朋友不外出通讯是不可能的一件事情，但所谓的公司备案VPN却非常昂贵，一般用户根本承担不起费用。但我们一定要“做好分内事，勿论他人非”，尤其不发表涉及天朝的言论和行为，做一个天朝的好公民、中华的好儿女，这样天朝是没有必要跟她的好儿女过不去的。\n什么是V2Ray？V2Ray是在Shadowsocks被封杀之后，为了表示抗议而开发的，属于后起之秀，功能更加强大，为抗GFW封锁而生。V2Ray现在已经是Project V项目的核心工具，而Project V是一个平台，其中也包括支持Shadowsocks协议。由于V2Ray早于Project V项目，而且名声更大，所以我们习惯称Project V项目为V2Ray，所以我们平时所说的V2Ray其实就是Project V这个平台，也就是一个工具集。其中，只有VMess协议是V2Ray社区原创的专属加密通讯协议，被广泛应用于梯子软件。\nV2Ray目前支持以下协议（截止到2019年12月）：\n\nBlackhole：中文名称“黑洞”，是一个出站数据协议，它会阻碍所有数据的出站，配合路由（Routing）一起使用，可以达到禁止访问某些网站的效果。\nDokodemo-door：中文名称“任意门”，是一个入站数据协议，它可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。\nFreedom：是一个出站协议，可以用来向任意网络发送（正常的）TCP或UDP数据。\nHTTP：超文本传输协议，是传统的代理协议\nMTProto：Telegram的开发团队开发的专用协议，是一个Telegram专用的代理协议。在V2Ray中可使用一组入站出站代理来完成Telegram数据的代理任务。目前只支持转发到Telegram的IPv4地址。\nShadowsocks：最早被个人开发的科学上网梯子协议，但V2Ray目前不支持ShadowsocksR。\nSocks：标准Socks协议实现，兼容Socks 4、Socks 4a和Socks 5，也是传统的代理协议。\nVMess：是V2Ray专用的加密传输协议，它分为入站和出站两部分，通常作为V2Ray客户端和服务器之间的桥梁。因为增加了混淆和加密，据说比Shadowsocks更安全。现在的机场支持V2Ray，一般是指支持VMess协议。VMess依赖于系统时间，请确保使用V2Ray的系统UTC时间误差在90秒之内，时区无关。在Linux系统中可以安装ntp服务来自动同步系统时间。\n\n截止到2019年12月，V2Ray可选的传输层配置有：TCP、mKCP、WebSocket、HTTP&#x2F;2、DomainSocket、QUIC。其中，mKCP、QUIC和TCP用于优化网络质量；WebSocket用于伪装；HTTP&#x2F;2和DomainSocket用于传输以及TLS加密。\nV2Ray不仅可以在传输层配置TLS使HTTP和SOCKS变成HTTPS和SOCKS over TLS协议，也可以使MTProto、Shadowsocks和VMess通过传输层配置TLS加密伪装成TLS流量。所以，VMess配置TLS加密是最常见的做法，但没人会对Shadowsocks使用TLS加密，因为这完全没意义。\n什么是Trojan&#x2F;Trojan-Go？Trojan，原来多是指特洛伊木马，是一种计算机病毒程序。但是，我们今天所说的Trojan是一种新的科学上网技术，全称为Trojan-GFW，是目前最成功的科学上网伪装技术之一。你可以认为Trojan是V2Ray的“WS+TLS”模式的精简版，速度比V2Ray更快，伪装比V2Ray更逼真，更难以被GFW识别。\nTrojan工作原理：Trojan通过监听443端口，模仿互联网上最常见的HTTPS协议，把合法的Trojan代理数据伪装成正常的HTTPS通信，并真正地完整完成的TLS握手，以诱骗GFW认为它就是HTTPS，从而不被识别。Trojan处理来自外界的HTTPS请求，如果是合法的，那么为该请求提供服务，否则将该流量转交给Caddy、Nginx等web服务器，由Caddy、Nginx等为其提供网页访问服务。基于整个交互过程，这样能让你的VPS更像一个正常的web服务器，因为Trojan的所有行为均与Caddy、Nginx等web服务器一致，并没有引入额外特征，从而达到难以识别的效果。\nTrojan-Go是Trojan-GFW的分支项目，对Trojan进行性能优化，并增加不少新功能，Trojan-Go性能和功能均有大幅度的提升，而且支持分流和CDN。\n什么是Xray？Xray与V2Ray完全类同，Xray是Project X项目的核心模块。因为Xray和XTLS黑科技的作者rprx曾经是V2fly社区的重要成员，所以Xray直接Fork全部V2Ray的功能，然后进行性能优化，并增加了新功能，使Xray在功能上成为了V2Ray的超集，且完全兼容V2Ray。\n简而言之，Xray是V2Ray的项目分支，Xray是V2Ray的超集，就跟Trojan-Go和Trojan-GFW的关系类似，而且Xray性能更好、速度更快，更新迭代也更频繁。由于自V2ray-core 4.33.0 版本起，删除了XTLS黑科技，但仍然支持VLESS，所以是否原生支持XTLS是Xray和V2Ray最大的区别之一。\n它们有什么区别及优缺点原理不同VPN强调对公网传输过程中数据的加解密，SS&#x2F;SSR&#x2F;V2Ray&#x2F;Xray&#x2F;Trojan都是专注于在客户端和服务器端加解密，公网传输数据过程中特征没有VPN明显。\n目的不同VPN是走在公网中自建的虚拟专用通道，使用强大的加解密算法，为数据传输安全性、私密性而生，被广泛应用于企业、高校、科研部门等远程数据传输的领域；SS&#x2F;SSR&#x2F;V2Ray&#x2F;Xray&#x2F;Trojan&#x2F;Trojan-Go是为了数据能够安全通过GFW而生，更强调的是对数据的混淆和伪装，加解密只是为了更好的隐藏数据特征而顺利绕过GFW的检测，数据内容加密可以有效绕过关键词的检测。\n在天朝，如果你想用VPN翻墙几乎是不可能的，在平时不怎么限制还好，特殊时期VPN是断流最惨的。如果要需要匿名安全上网，VPN+TOR或SS&#x2F;SSR+TOR也是不错的选择。当然，现在已经有了新的对抗技术，比如V2Ray&#x2F;Xray、Trojan&#x2F;Trojan-Go、WireGuard等。另外，有一些比较著名的工具，如红杏出墙、蓝灯（Lantern）、Tor Browser、赛风3（Psiphon3）等，都相继被墙，现在已经很少人使用了。\n项目诞生的大致时间顺序VPN&gt;SS&gt;SSR&#x2F;V2Ray&#x2F;WireGuard&gt;Trojan&#x2F;Trojan-Go&gt;Xray\n对科学上网工具的总结VPN虽然天生不是为了做梯子，但却是最出名的梯子软件、众人皆知的科学上网工具，但是由于VPN特征太明显，现在非大陆正规公司的VPN基本被禁的差不多了；SS&#x2F;SSR为科学上网而生，但是加密和混淆较弱，而且已经被GFW精准识别，在科学上网方面的前景堪忧，但是仍然适用于专线，网络速度比V2Ray&#x2F;Trojan&#x2F;Trojan-Go更快；V2Ray&#x2F;Xray为科学上网而生，天生不凡，已经成长为一个平台框架，拥有自研协议VMess和VLESS，功能非常强大；WireGuard被誉为新一代VPN，技术强大，而且已经被写入Linux内核，前景光明，但是在科学上网方面并不够隐蔽，所以不是未来主流的科学上网工具；Trojan&#x2F;Trojan-Go为科学上网而生，天生只为了模仿互联网最流行的HTTPS协议而存在，是目前最成功的伪装工具之一，功能与V2Ray的“Vmess+WS+TLS”模式相当，但是更轻量，伪装更逼真，目前GFW几乎无法识别其特征，而且目前Trojan-Go在性能和速度方面的表现均优于V2Ray的VMess和VLESS协议。所以，我认为Trojan&#x2F;Trojan-Go会跟V2Ray一样成为将来科学上网的主流工具之一，SSR由于长期得不到维护而逐渐退出历史舞台，Shadowsocks&#x2F;SS依然是最轻量的科学上网代理协议，没有之一。\n","categories":["科学上网"],"tags":["代理工具"]},{"title":"让 cmd 使用代理","url":"/posts/91f51ab4/","content":"通过cmd命令行执行某些命令时，如果这些命令去国外站点下载什么文件或是获取点什么信息，却下载不下来的时候，要么报错要么卡在哪一动不动，我们就只能科学上网了。类似于ShadowSocks、V2ray这类工具尽管开启了全局代理，但是cmd里依旧无法下载成功。因为这种全局代理只针对使用IE代理的程序才会全局，不是像VPN那样的全局。当然也更不支持PAC模式了。\n\n\n\n开始cmd如果要设置代理的话，需要在执行其他命令之前，先执行一下\nset http_proxy=http://127.0.0.1:10809set https_proxy=http://127.0.0.1:10809\n\n同理如要设置WSL的代理也是一样的做法\nexport http_proxy=http://127.0.0.1:10809export https_proxy=http://127.0.0.1:10809\n\n\n注意：上面代理地址只是示例，请换成你自己的代理地址。并且只能使用http而不是socks5。\n再次注意：上面的命令只是设置临时的环境变量，关闭窗口后即失效。\n\n测试设置完成后运行如下命令测试是否设置好了而不是ping命令。\ncurl https://www.google.com\n\n应当类似于如下的返回内容：\n\n","categories":["科学上网"],"tags":["科学上网"]},{"title":"全自动领取 Epic 每周赠送游戏","url":"/posts/74ac3ac6/","content":"EpicGames Claimer 是一个 Docker 镜像，能给帮助你全自动、静默领取 Epic 每周赠送的游戏。十分简单易用，使用过程中几乎不需要输入或修改任何参数。众所周知，Epic 每周都能领取游戏，简直是 YYDS！游戏可以不玩，但是不可以不领！每周忘记领游戏仿佛错过了一个亿！如今有了自动领游戏 docker，妈妈再也不用担心我忘记领游戏了！\n由于Epic游戏商城限制了单个IP地址领取免费游戏的总量，所以使用公共IP领取游戏可能会失败。\n\n\n\n食用说明使用简单，这里只介绍如何在 VPS 上安装 docker 来运行 EpicGames Claimer\n注意需提前关闭 Epic 账号的二次验证\n食用方法安装docker：\n#安装dockersudo yum check-updatecurl -fsSL https://get.docker.com/ | shsudo systemctl start dockersudo systemctl status dockersudo systemctl enable docker\n\n安装EpicGames Claimer：\ndocker run -d -e AUTO_UPDATE=true luminoleon/epicgames-claimer -u 登录邮箱 -p 登录密码\n","categories":["薅羊毛"],"tags":["Epic","游戏"]},{"title":"青龙面板从零搭建教程","url":"/posts/51ab6baf/","content":"你需要准备一台VPS，如果没有，推荐阿里云服务器新用户，点击这里如果阿里云不是新用户那就腾讯云，点击这里\n\n\n\n\n\n\n\n\n选择一个1核2G的即可，系统选择CentOS 7等待配置完成，然后重置密码\n\n\n\nSSH连接SSH工具有很多，喜欢哪个就用哪个，我用的是FinalShell\n开始安装\n首先安装docker\n\nsudo yum check-updatecurl -fsSL https://get.docker.com/ | shsudo systemctl start dockersudo systemctl status dockersudo systemctl enable docker\n\n\n安装完成后配置青龙面板\n\ndocker run -dit \\  --name QL \\  --hostname QL \\  --restart always \\  -p 5700:5700 \\  -v $PWD/QL/config:/ql/config \\  -v $PWD/QL/log:/ql/log \\  -v $PWD/QL/db:/ql/db \\  -v $PWD/QL/scripts:/ql/scripts \\  -v $PWD/QL/jbot:/ql/jbot \\  whyour/qinglong:latest\n\n等待一段时间安装好后，在浏览器输入你的ip:5700如：127.0.0.1:5700即可进入青龙面板用户名为admin密码是adminadmin\n重置密码\n使用ssh工具修改在&#x2F;root&#x2F;QL&#x2F;config中找到auth.json\n青龙面板修改\n\n拉库刚安装完青龙面板里面的定时任务应该是什么都没有的在右上角，新建一个任务，定时规则为 0 0 0 * * *\nql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git &quot;jd_|jx_|gua_|jddj_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator_|sign_graphics_validate|ql|JDSignValidator&quot;\n\n\n点击运行，几分钟后刷新页面，你就可以看到很多任务\n添加环境变量也就是你JD账号的Cookie，Cookie的有效时间为一个月，也就是说每个月你都要获取一次\n获取方法\n你需要在手机上安装一个APP，点击这里下载，登录JD复制得到的Cookie然后填入变量值\n或者你也可以F12获取\n\n结尾\n暂时先写到这有什么问题欢迎下方留言\n\n","categories":["薅羊毛"],"tags":["青龙面板"]},{"title":"学习笔记 | 英语语法","url":"/posts/d3f8bfd7/","content":"\n英语语法\n英语语法 | 句子成分\n英语语法 | 简单句\n英语语法 | 词性\n英语语法 | 时态\n英语语法 | 语态\n英语语法 | 语气\n英语语法 | 复合句\n\n\n","categories":["学习笔记"],"tags":["英语语法"]},{"title":"英语语法 | 句子成分","url":"/posts/6f1261c3/","content":"英语九大句子成分：\n\n\n\n成分\n简写\n\n\n\n主语\nS\n\n\n谓语\nV\n\n\n表语\nP\n\n\n宾语\nO\n\n\n宾补\nOC\n\n\n状语\nADV\n\n\n定语\nATT\n\n\n同位语\nAP\n\n\n独立成分\n\n\n\n\n\n\n主语一个句子叙述的主体，一句话主要叙述的对象或者这句话主要讲的内容。\n能作主语的词语：\n\n名词\n数词\n人称代词\n指示代词\n动名词和短语\n动词不定式和短语\n从句\n短语动词\n\n谓语说明主语动作或者状态的词语。\n说明主语做什么或者主语是什么，主语怎么样的词语。\n谓语只跟主语有关，说明主语的情况，跟其他成分没有关系。\n动作型谓语说明主语做什么的，由动词构成的。比如：\n\nI eat an apple every day（我每天吃一个苹果）及物动词 eat 作动作型谓语。\n\n简单谓语简单谓语由实义动词或者短语动词（复合动词）构成。比如：\n\nI run every day（我每天跑步）实义动词 run 作谓语。\nI get up at six（我六点起床）短语动词 get up 作谓语。\n\n复合谓语复合谓语就是由简单谓语加上其他词语共同作谓语的情况。\n\n情态动词 + 实义动词原型&#x2F;短语动词原型：\nI can speak Mandarin（我会说普通话）情态动词 can 和实义动词 speak 构成复合谓语。\nI can look after her（我可以照顾她）情态动词 can 和短语动词 look after 构成复合谓语。\n\n\n助动词 + 实义动词原型&#x2F;短语动词原型：\nI will buy a new book tomorrow（我明天要买一本新书）助动词 will 和实义动词 buy 构成复合谓语。\nI will get up early tomorrow（我明天要早起）助动词 will 和短语动词 get up 构成复合谓语。\n\n\n助动词 + 其他的动词形式：\nI am working now（我现在正在工作）助动词 am 和不及物动词现在分词 working 构成复合谓语。\n\n\n\n状态型谓语说明主语是什么或者怎么样的，由系表结构构成的。比如：\n\nI am happy（我高兴）系动词 am 和形容词 happy 作表语构成状态型谓语。\n\n系动词 + 表语从某种意义上，系动词加表语也是一种复合谓语。\n\nbe + 名词：\nHe is a doctor（他是一名医生）系动词 is 和名词 a doctor 作表语构成状态型谓语。\n\n\nbe + 形容词：\nI am happy（我快乐）系动词 am 和形容词 happy 作表语构成状态型谓语。\n\n\nbe + 介词短语：\nI am in China（我在中国）系动词 am 和介词短语 in China 作表语构成状态型谓语。\n\n\n\n宾语及物动词这个动作的对象或承受着。\n能作主语的词语都可以作宾语，不能作主语的词语同样不能作宾语。\n并列宾语即多个词语并列作宾语。比如：\n\nI like money, beautiful clothes and rich men（我喜欢金钱、漂亮的衣服和有钱的男人）其中 money、beautiful clothes、rich men 并列在一起作并列宾语。\n\n双宾语双宾动词后面跟两个宾语，表示物的叫直接宾语，表示人的叫间接宾语。比如：\n\nI gave her a book（我给她一本书）双宾动词 gave 后面的 a book 是直接宾语，her 是间接宾语。\n\n表语表语属于谓语的范畴，但是不能说表语就是谓语，因为系动词加表语（系表结构）才是谓语，系动词和表语构成状态型谓语。\n表语用来表述主语的身份、状态、性质等信息。\n系动词和表语是不能分开的，没有系动词就没有表语，没有表语就没有系动词。\n能作表语的词语：\n\n名词：\nI am a teacher（我是一个老师）名词 teacher 作表语。\n\n\n形容词：\nI am rich（我有钱）形容词 rich 作表语。\n\n\n介词短语：\nShe is in China（她在中国）介词短语 in China 作表语。\n\n\n名词所有格\n动名词和短语\n动词不定式和短语\n代词\n数词\n分词\n副词\n句子\n\n补语起补充说明作用的成份。\n宾语补足语简称宾补，补充说明宾语，使其意思更完整。\n宾补只跟宾语有关系。比如：\n\nI made her happy（我让她开心）形容词 happy 作宾补。\n\n能作宾补的词语：\n\n名词：\nI call her Mary（我叫她玛丽）名词 Mary 作宾补。\n\n\n数词：\nI put my family first（我把家庭放在第一位）数词 first 作宾补。\n\n\n形容词：\nYou make me mad（你让我发疯）形容词 mad 作宾补。\n\n\n介词短语\n动名词和短语\n动词不定式和短语\n副词\n分词\n句子\n\n主语补足语简称主补。\n定语修饰或限定名词的词语。\n定语只跟名词有关系，哪里有名词哪里就有定语。\n同一个名词可以有多个定语。\n前置定语放在名词前面的定语。\n能作前置定语的词语：\n\n数词：\nthree books（三本书）数词 three 作前置定语。\n\n\n量词：\na bottle of water（一瓶水）量词 a bottle of 作前置定语。\n\n\n名词：\nEnglish book（英语书）名词 English 作前置定语。\n\n\n形容词：\nhappy girl（快乐的女孩）形容词 happy 作前置定语。\n\n\n指示代词：\nthis book（这本书）指示代词 this 作前置定语。\n\n\n名词所有格：\nNick’s house（Nick 的房子）名词所有格 Nick’s 作前置定语。\n\n\n形容词性物主代词：\nmy book（我的书）形容词性物主代词 my 作前置定语。\n\n\n\n后置定语放在名词后面修饰前面的名词的定语。\n能作后置定语的词语：\n\n介词短语\n名词所有格\n动名词和短语\n动词不定式和短语\n句子\n\n状语状语用来修饰谓语，说明谓语的情况。\n状语只跟谓语有关系，一般由副词和介词短语充当放在句子的后面。\n状语的数量是不定的，出现多个状语时，排列顺序为：方式状语 &gt; 地点状语 &gt; 时间状语\n\n时间状语：\nI am happy today（我今天开心）时间副词 today 作时间状语。\n\n\n地点状语：\nI learn English at home（我在家学英语）介词短语 at home 作地点状语。\n\n\n方式状语：\nI speak English slowly（我慢慢地说英语）方式副词 slowly 作方式状语。\n\n\n原因状语\n目的状语\n结果状语\n伴随状语\n\n同位语两个不同的词语都表示同一个人或事物。\n同位语起到强调补充说明的作用。比如：\n\nMy father, the fat man, is drinking（我爸爸，就是那个胖男人，正在喝酒）其中 the fat man 就是 my father 的同位语。\n\n","categories":["学习笔记"],"tags":["英语语法","句子成分"]},{"title":"英语语法 | 复合句","url":"/posts/5b824013/","content":"又称主从复合句，由一个主句和一个及以上的从句构成。从句不能独立存在，必须作整个复合句中的某个句子成分。从句一般需要连接词引导，但有时候可能会被省略。\n\n\n\n名词性从句主语、表语、宾语、同位语从句的构成方式、意思、使用的连接词都一样。\n名词性从句的连接词分为：\n\n\n从属连词\nthat：无词义，在从句中不担任成分。\nif、whether：有词义，在从句中不担任成分。\n\n\n连接代词\nwho、whom、whose、what、which：有词义，在从句中做主语、表语、宾语、或定语。\n\n\n连接副词\nwhen、where、why、how：有词义，在从句中做状语。\n\n\n\n\n感叹句充当名词性从从句：\n\n\n感叹句去掉感叹号可以直接相当于一个名词性从句，在复合句中主要做宾语从句。\n\n\n某些特殊疑问句充当名词性从句：\n\n\nhow many\nhow much\nhow often\nhow long\nhow far\n\n\n主语从句主语从句可以是动作型的句子也可以是状态型的句子。在复合句中，主语从句属于第三人称单数的概念。\n\n主语从句后置的情形：名词性从句做主语时，在结构形式上会给人一种头重脚轻的感觉，为避免这种句式结构的不平衡，常借用代词 it 来代替此名词性从句，而将此从句进行后置，这时的 it 就是形式主语（假主语），真正的主语是后置的主语从句（真主语）。\n\n\n从属连词\nthat：没有意思，在从句中不充当任何句子成分。\nwhether(是否)：在从句中不充当任何句子成分。引导的从句既可以前置也可以后置。\nif(是否)：在从句中不充当任何句子成分。引导的从句只能后置。\n\n\n连接代词\nwho(谁)、whoever(无论谁)：在主语从句中做表语。\nwhat(……的)、whatever(无论什么)：在主语从句中可以做主语、宾语，少数情况可以做表语。\nwhich(哪个)、whose(谁的)：在主语从句中做定语，后面必须修饰一个普通名词。\nwhom(谁)：在从句中只能做宾语。\n\n\n连接副词\nwhen(什么时候)：在从句中做时间状语。\nwhere(在哪里)：在从句中做地点状语。\nwhy(为什么)：在从句中做原因状语。\nhow(如何)：在从句中做方式状语。\n\n\n\n表语从句主语从句的构成方式和连接词跟表语从句一样，可以直接做表语从句。含有表语从句的复合句的主语不能是人或者有生命的事物。\n宾语从句宾语从句是最常用的从句之一。\n宾语从句的时态取决于主句的时态：\n\n\n主句使用现在时态时，宾语从句可以使用任何时态。\n主句用一般过去时态，宾语从句全部要用过去时态。\n例外：当宾语从句表示“真理”，可以用一般现在时态，不受主句时态影响。\n\n\n直接引语和间接引语：\n\n重述别人所说的话时可采用两种方式：\n\n直接引语：即用引号直接引述别人的原话。\n间接引语：即用自己的话转述别人的话。可以直接作宾语从句。\n\n\n注意：\n\nwhat 在主语从句和表语从句中不能翻译为“什么”，在宾语从句中有时候可以翻译为“什么”。\n\n同位语从句当一个从句来充当同位语时，那么这个从句就是同位语从句。所谓同位语就是用不同的方式把一个概念再说一遍，用逗号隔开。其作用与简单句中的同位语一致，用于补充说明名词或代词。同位语从句常在句中修饰抽象的名词，因为抽象，所以才要“另一种方式来再说一遍”。\n形容词性从句在句子中起到形容词作用的句子，相当于一个“大形容词”。对某个人或事物进行描述，修饰某一名词或代词的从句，具有形容词的性质。\n定语从句也称关系从句、形容词性从句。定语从句就是修饰或限定名词和代词，作后置定语的句子。定语从句一般位于被修饰的名词或代词的后面，也就是先行词的后面。连接词作定语从句的主语时，其后的谓语动词的人称和数取决于先行词。\n定语从句的连接词：\n\n\n关系代词：who、whom、whose、which、that、as。\n关系副词：when、where、why。\n\n这些关系代词和关系副词是没有意思的，只起到构成定语从句的作用，但是在定义从句中可以担任一个成分。\n\n关系代词：\n\n\nwho：指代人，在定语从句中作主语。引导的定语从句只能修饰或限定表示人的名词或代词。\nwhom：指代人，在定语从句中作宾语，并且可以省略。引导的定语从句只能修饰或限定表示人的名词或代词。\nwhich：指代事物，在定语从句中作主语或宾语，作宾语时可以省略。引导的定语从句只能修饰或限定表示事物的名词或代词。\nthat：既可以指人也可以指物，在定语从句中作主语或宾语，作宾语时可以省略。引导的定语从句可以修饰或限定表示人或者表示事物的名词或代词。that 可以和 who 或 whom 互换使用，意思不变。但是 who 和 whom 比 that 更常用，that 一般属于非正式用法。\nwhose：在定语从句中作前置定语，将“whose + 名词”做为一个整体，然后在定语从句中作主语或宾语。引导的定语从句可以修饰或限定表示人或者表示事物的名词或代词。whose &#x3D; “先行词’s” 的意思。\n\n\nwhich 和 that 的区别：\n\n\nwhich 可以引导非限定性定语从句，that 不可以。\nwhich 前面可以加介词，that 不可以。which 在从句中所介词宾语时可以把介词放在 which 的前面。\n先行词是不定代词、被序数词修饰、被形容词最高级修饰、被 the very、the only、the just 等修饰的时候，用 that 不用 which。\n先行词明确唯一，没有其他可能时，用 that 不用 which。\n先行词如果是多个同类事物中按限定条件选择，则不一定用 that，也可以用 which。\n\n\n关系副词：\n\n\nwhen：在定语从句中作时间状语。引导的定语从句只能修饰表示时间的名词或代词。\nwhere：在定语从句中作地点状语。引导的定语从句只能修饰表示地点的名词或代词。\nwhy：在定语从句中作状语。引导的定语从句只能修饰 reason 这个名词。\n\n\n关系代词前面带介词的定语从句：\n\n\nwhich 和 whom 在定语从句中作介词的宾语\n作“含介词的短语动词”的宾语\n作“含介词的固定句型”的介词宾语\n介词 + which&#x2F;whom 构成介词短语作定语从句的状语\n\n\n\n\n限定性和非限定性定语从句：\n\n\n限定行定语从句：对先行词具有限定或修饰作用，使该词的含义更具体、更明确。限定性定语从句与先行词之间不能用逗号隔开。限定性定语从句中的关系代词在从句中作宾语时可以省略。限定性定语从句修饰的是名词或代词。\n非限定性定语从句：定语从句有时跟先行词的关系并不十分密切，只是作一些附加说明，不起限定作用，这种从句称为非限定性定语从句，多用于书面语，往往用逗号与主句隔开。非限定性定语从句经常可以修饰人名或地名。which 引导的非限定性定语从句可以代表整个主句所讲的内容。\n\n\n使用定语从句应注意的问题：\n\n\n定语从句有时不直接紧靠着先行词，中间可能由一个定语、状语或谓语隔开。\n关系代词和关系副词在从句中本身已经充当一个成分。\n\n\n副词性从句在句子中起到副词作用的句子，相当于一个“大副词”。\n状语从句在复合句担任状语成分的从句。状语从句的连接词是有意思的，但在状语从句中不充当任何句子成分，只起到链接的作用。\n时间状语从句时间状语从句的时态决定了主句的时态。时间状语从句不能出现将来时态。时间状语从句在复合句中可以放开头也可以放结尾，放开头需要加逗号。\n\n\nwhen(当……的时候)：有意思，但没有作用。\nwhenever(无论什么时候)：用法跟 when 一样。\nwhile(当……的时候)\nas(当……的时候)\nafter(……之后)\nbefore(……之前)\nsince(自从……)：引导的状语从句必须使用一般过去时态，构成复合句的主句必须是完成时态。\nuntil(直到……)\nas soon as(一……就)\nonce(一旦……)\n\n\n主将从现：主句是一般将来时态，时间状语从句用一般现在时态表达将来的时间概念。\n地点状语从句连接副词：\n\nwhere(在哪里)\nwherever(无论在哪里)\nno matter where &#x3D; wherever\n\n原因状语从句最容易的状语从句，因为构成方式非常简单，连接词直接跟一个完整的句子就可以，而且没有时态的要求。\n从属连词：\n\nbecause(因为)：不能和 so 连用。\nas(因为)：语气比 because 弱。\nfor(因为)：语气比 because 弱。\nsince(既然)\n\n条件状语从句从属连词：\n\nif(如果)\nunless(除非)\nas long as(只要)\n\n时态的两种情况：\n\n真实的条件状语从句：跟时间状语从句一样使用主将从现的规则。\n虚拟的条件状语从句：if 引导的条件状语从句可以是其他时态。\n\n方式状语从句方式状语从句只能出现在表示动作的句型中。\n\nas(按照)\njust as(正如)\nas if(好像)：引导的方式状语从句经常使用虚拟语气。\n\n让步状语从句\nthough&#x2F;although(尽管)\neven if&#x2F;even though(即使)\n\neven if 引导的让步状语从句有时有主将从现的规则。\n目的状语从句\nthat(以便)\nso that(以便)\nin order that(为了)\nlest(以免)\n\n结果状语从句\nso that(以至)\nso……that……(如此……以至……)\n\n比较状语从句\nthan(比)\nas……as(和……一样)\nnot so……as(不如……)\nless……than……(不如……)\n\n特殊结构一：\n\nthe + 形容词比较级&#x2F;副词比较级（+ 句子），the + 另一个形容词比较级&#x2F;另一个副词比较级（+ 句子）\n\nthe + 形容词比较级，the + 另一个形容词比较级\n越……，就越……。\n\n\nthe + 形容词比较级 + 主语 + 系动词，the + 另一个形容词比较级 + 主语 + 系动词\n“the + 形容词比较级”相当于“主语 + 系动词”的表语。\n某人或某物越……，就越……。\n\n\nthe + 形容词比较级 + 名词 + 主语 + 及物动词，the + 另一个形容词比较级 + 名词 + 主语 + 及物动词\n“the + 形容词比较级 + 名词”相当于“主语 + 及物动词”的宾语。\n某人越做什么事情，就越……。\n\n\nthe + 方式副词比较级 + 主语 + 谓语（+ 宾语），the + 另一个方式副词比较级 + 主语 + 谓语（+ 宾语）\n“the + 方式副词比较级”相当于“主语 + 谓语（+ 宾语）”的状语\n某人越……，就越……。\n\n\n\n\n特殊结构二：\n\n形容词比较级&#x2F;副词比较级 + and + 同一个形容词比较级&#x2F;同一个副词比较级表示“越来越……”，一般作表语或状语。\n作表语：\n\n主语 + 系动词 + 形容词的比较级 + and + 同一个形容词的比较级\n\n作状语：\n\n主语 + 谓语（+ 宾语）+ 方式副词比较级 + and + 同一个方式副词比较级\n\n\n","categories":["学习笔记"],"tags":["英语语法","复合句"]},{"title":"英语语法 | 时态","url":"/posts/26b33495/","content":"时态是一个动作发生的时间和当时所处的状态。\n\n\n\n现在一般时态表示经常性、习惯性、有规律性的动作和状态。表示真理性、客观性的动作和状态。表示不轻易改变的状态。表示此时此刻的状态。\n\n主语是 I 的情况用 am主语是第三人称单数用 is主语是复数和 you 时用 are\n\n表示状态的句子：\n\n形式一\n肯定句：主语 + is&#x2F;are&#x2F;am + 表语\n否定句：主语 + is&#x2F;are&#x2F;am + not + 表语\n疑问句：Is&#x2F;Are&#x2F;Am + 主语 + 表语 + ？\n\n\n形式二\n肯定句：非三单 + 特殊系动词原型 + 表语\n否定句：非三单 + don’t + 特殊系动词原型 + 表语\n疑问句：Do + 非三单 + 特殊系动词原型 + 表语 + ？\n\n\n形式三\n肯定句：三单 + 特殊系动词三单格式 + 表语\n否定句：三单 + doesn’t + 特殊系动词原型 + 表语\n疑问句：Does + 三单 + 特殊系动词原型 + 表语 + ？\n\n\n\n表示动作的句子：\n\n形式一\n肯定句：非三单&#x2F;名词复数 + 实义动词原型（+ 宾语）\n否定句：非三单&#x2F;名词复数 + don’t + 实义动词原型（+ 宾语）\n疑问句：Do + 非三单&#x2F;名词复数 + 实义动词原型（+ 宾语）+ ？\n\n\n形式二\n肯定句：三单&#x2F;名词单数 + 实义动词三单格式（+ 宾语）\n否定句：三单&#x2F;名词单数 + doesn’t + 实义动词原形（+ 宾语）\n疑问句：Does + 三单&#x2F;名词单数 + 实义动词原型（+ 宾语）+ ？\n\n\n\n过去一般时态表示过去发生的动作或状态。\n\n主语是单数用 was主语是复数或 you 时用 were\n\n表示状态的句子：\n\n形式一\n肯定句：主语 + was&#x2F;were + 表语\n否定句：主语 + was&#x2F;were + not + 表语\n疑问句：Was&#x2F;Were + 主语 + 表语 + ？\n\n\n形式二\n肯定句：主语 + 特殊系动词过去式 + 表语\n否定句：主语 + didn’t + 特殊系动词原型 + 表语\n疑问句：Did + 主语 + 特殊系动词原型 + 表语 + ？\n\n\n\n表示动作的句子：\n\n肯定句：主语 + 实义动词过去式（+ 宾语）\n否定句：主语 + didn’t + 实义动词原型（+ 宾语）\n疑问句：Did + 主语 + 实义动词原型（+ 宾语）+ ？\n\n将来一般时态表示即将要发生的动作和状态的，或者说这些动作和状态还没有发生，但是在将来的某个时间要发生。\n表示状态的句子：\n\n形式一\n肯定句：主语 + will + be + 表语\n否定句：主语 + won’t + be + 表语\n疑问句：Will + 主语 + be + 表语 + ？\n\n\n形式二\n肯定句：I&#x2F;We + shall + be + 表语\n否定句：I&#x2F;We + shan’t + be + 表语\n疑问句：Shall + I&#x2F;we + be + 表语 + ？\n\n\n形式三\n肯定句：主语 + is&#x2F;are&#x2F;am going to + be + 表语\n否定句：主语 + is&#x2F;are&#x2F;am + not + going to + be + 表语\n疑问句：Is&#x2F;Are&#x2F;Am + 主语 + going to + be + 表语 + ？\n\n\n形式四\n肯定句：主语 + will + 特殊系动词原型 + 表语\n否定句：主语 + won’t + 特殊系动词原型 + 表语\n疑问句：Will + 主语 + 特殊系动词原型 + 表语 + ？\n\n\n形式五\n肯定句：主语 + is&#x2F;are&#x2F;am going to + 特殊系动词原型 + 表语\n否定句：主语 + is&#x2F;are&#x2F;am + not + going to + 特殊系动词原型 + 表语\n疑问句：Is&#x2F;Are&#x2F;Am + 主语 + going to + 特殊系动词原型 + 表语 + ？\n\n\n\n表示动作的句子：\n\n形式一\n肯定句：主语 + will + 实义动词原型（+ 宾语）\n否定句：主语 + won’t + 实义动词原形（+ 宾语）\n疑问句：Will + 主语 + 实义动词原形（+ 宾语）+ ？\n\n\n形式二\n肯定句：主语 + is&#x2F;are&#x2F;am going to + 实义动词原型（+ 宾语）\n否定句：主语 + is&#x2F;are&#x2F;am + not + going to + 实义动词原形（+ 宾语）\n疑问句：Is&#x2F;Are&#x2F;Am + 主语 + going to + 实义动词原形（+ 宾语）+ ？\n\n\n\n过去将来一般时态和将来一般时态有关系。表示在过去某时看来将要发生的动作或存在的状态。这个时态基本上用在宾语从句里面。\n表示动作的句子：\n\n形式一\n肯定句：主语 + would + 实义动词原形（+ 宾语）\n否定句：主语 + would + not + 实义动词原形（+ 宾语）\n\n\n形式二\n肯定句：主语 + was&#x2F;were + going to + 实义动词原形（+ 宾语）\n否定句：主语 + was&#x2F;were + not + going to 实义动词原形（+ 宾语）\n\n\n\n表示状态的句子：\n\n形式一\n肯定句：主语 + would + be + 表语\n否定句：主语 + would + not + be + 表语\n\n\n形式二\n肯定句：主语 + was&#x2F;were + going to + be + 表语\n否定句：主语 + was&#x2F;were + not + going to + be + 表语\n\n\n\n现在完成时态表示从过去某时开始一直延续到现在的动作和状态。表示过去发生的某一动作对现在造成的影响和结果。\n表示状态的句子：\n\n肯定句：主语 + have&#x2F;has + been + 表语\n否定句：主语 + haven’t&#x2F;hasn’t + been + 表语\n疑问句：Have&#x2F;Has + 主语 + been + 表语 + ？\n\n表示动作的句子：\n\n形式一\n肯定句：非三单&#x2F;名词复数 + have + 实义动词过去分词（+ 宾语）\n否定句：非三单&#x2F;名词复数 + haven’t + 实义动词过去分词（+ 宾语）\n疑问句：Have + 非三单&#x2F;名词复数 + 实义动词过去分词（+ 宾语）+ ？\n\n\n形式二\n肯定句：三单&#x2F;名词单数 + has + 实义动词过去分词（+ 宾语）\n否定句：三单&#x2F;名词单数 + hasn’t + 实义动词过去分词（+ 宾语）\n疑问句：Has + 三单&#x2F;名词单数 + 实义动词过去分词（+ 宾语）+ ？\n\n\n\n过去完成时态和现在完成时态有关系。表示过去某个时间或某个动作之前已经完成的动作，或者表示从过去某个时间开始一直延续到过去一个时间的动作。\n表示状态的句子：\n\n肯定句：主语 + had + been + 表语\n否定句：主语 + hadn’t + been + 表语\n疑问句：Had + 主语 + been + 表语\n\n表示动作的句子：\n\n肯定句：主语 + had + 实义动词过去分词 （+ 宾语）\n否定句：主语 + hadn’t + 实义动词过去分词 （+ 宾语）\n疑问句：Had + 主语 + 实义动词过去分词（+ 宾语）\n\n现在进行时态表示主语此时此刻正在进行的动作。\n表示状态的句子：\n\n肯定句：主语 + is&#x2F;are&#x2F;am + 特殊系动词现在分词 + 表语\n否定句：主语 + is&#x2F;are&#x2F;am + not + 特殊系动词现在分词 + 表语\n疑问句：Is&#x2F;Are&#x2F;Am + 主语 + 特殊系动词现在分词 + 表语 + ？\n\n表示动作的句子：\n\n肯定句：主语 + is&#x2F;are&#x2F;am + 实义动词现在分词（+ 宾语）\n否定句：主语 + is&#x2F;are&#x2F;am + not + 实义动词现在分词（+ 宾语）\n疑问句：Is&#x2F;Are&#x2F;Am + 主语 + 实义动词现在分词（+ 宾语）+ ？\n\n过去进行时态和现在进行时态有关系。表示过去某一时刻或某段时间内正在进行的动作。过去进行时态的时间状语一般由时间状语从句或一些表达过去某一刻的的词语充当。也可以使用两个时间来构成时间状语。\n\nwas 用于第一人称单数和第三人称单数were 用于其他各种人称\n\n表示动作的句子：\n\n肯定句：主语 + was&#x2F;were + 实义动词现在分词（+ 宾语）\n否定句：主语 + was&#x2F;were + not + 实义动词现在分词（+ 宾语）\n疑问句：Was&#x2F;Were + 主语 + 实义动词现在分词（+ 宾语）\n\n现在完成进行时态和现在完成时态、现在进行时态有关系\n表示动作的句子：\n\n肯定句：主语 + have&#x2F;has + been + 实义动词现在分词（+ 宾语）\n否定句：主语 + haven’t&#x2F;hasn’t + been + 实义动词现在分词（+ 宾语）\n疑问句：Have&#x2F;Has + 主语 + been + 实义动词现在分词（+ 宾语）\n\n","categories":["学习笔记"],"tags":["英语语法","时态"]},{"title":"英语语法 | 简单句","url":"/posts/84c90a91/","content":"由词语或者短语构成各个句子成分的句子。\n\n\n\n基本句型英语中的五种基本句型结构\n\n状态型\n主系表\n\n\n动作型\n主谓\n主谓宾\n主谓双宾\n主谓宾宾补\n\n\n\n状态型主系表结构，表示状态的句型，不能出现实义动词。\n主系表\n主语 + be 系动词 + 表语\nI am happy every day（我每天都很开心）\n\n\n主语 + 特殊系动词 + 表语\nHe looks good（他看起来不错）\n\n\n\n动作型主谓宾结构，表示动作的句型，不能出现系动词。\n主谓\n主语 + 不及物动词\nI work here（我在这里上班）\n\n\n\n主谓宾\n主语 + 及物动词 + 宾语\nI study English at home（我在家里学英语）\n\n\n\n主谓双宾\n主语 + 双宾动词 + 双宾语\nI give her an apple every day（我每天给她一个苹果）\n\n\n\n主谓宾宾补\n主语 + 特定及物动词 + 宾语 + 宾补\nI make her happy every day（我每天都让她开心）\n\n\n\n特殊句型There bethere be 后面的名词是句子的主语，属倒装结构。疑问句形式是将 be 或助动词、情态动词提至 there 之前。否定形式则直接在 be 或助动词、情态动词后加 not。\n\n就近原则：多个主语时，be 系动词用哪个格式取决于靠它近的主语。\n\nthere be 的基本句型：\n\n\n肯定句：There + is&#x2F;are + 主语 + 状语\n否定句：There + is&#x2F;are + not&#x2F;no + 主语 + 状语\n疑问句：Is&#x2F;Are + there + 主语 + 状语 + ？\n\n\n含 there be 的特殊疑问句：\n\n\n疑问词 + 名词 + there be + 状语 + ？\n\n\nthere be 句型的时态变化：\n\n\n一般现在时态：\nThere is&#x2F;are + 主语 + 状语\n\n\n一般过去时态：\nThere was&#x2F;were + 主语 + 状语\n\n\n一般将来时态：\nThere will be + 主语 + 状语\n\n\n现在完成时态：\nThere has&#x2F;have been + 主语 + 状语\n\n\n\n\n含有情态动词的 there be 句型：\n\n\nThere 情态动词 be + 主语 + 状语\n\n\nhave 和 there be 的用法和区别：\n\n\nthere be 表示存在，have 表示拥有、持有。\nhave 有时候还表示包括、包含的意思，这个时候它们可以互换使用。\n用 have 侧重主观存在，用 there be 侧重客观存在。\n\n\nthere be 结构出现主补的情况：\n\n\nThere be + 主语 + 动名词&#x2F;动词不定式&#x2F;过去分词 + 状语\n\n主语后面的动名词、动词不定式和过去分词起到补充说明的作用，所以称为主补。\n\n特殊疑问句特殊疑问句的构成方式：\n\n\n疑问词 + 一般疑问句 + ？\n\n\n特殊疑问词：\n\n\nwhere(在哪里)：在特殊疑问句中作地点状语、表语、介词宾语和宾补。\nwhat(什么)：在特殊疑问句中作宾语、表语和主语，也可以作定语，后面跟一个名词作构成复合疑问词。\nwhy(为什么)：在特殊疑问句中主要作原因状语，偶尔可以在主谓宾结构中作主语。\nwhose(谁的)：在特殊疑问句中作定语和表语，后面跟名词之后可以作宾语和表语。\nwhich(哪一个)：在特殊疑问句中作定语，后面跟名词之后可以作宾语。\nwhen(什么时候)：在特殊疑问句中作时间状语和表语，跟 what time 是同义词，一般可以互换。\nhow(如何、怎样)：在特殊疑问句中作表语和方式状语，后跟形容词或副词可以构成很多新的复合疑问词。\nwhom(谁)：在特殊疑问句中只能作宾语。\nwho(谁)：在特殊疑问句中作主语。\n\n\n疑问词作主语时的句型：\n\n不需要倒装，因为本来主语就是放在开头。\n\n疑问词 + 谓语 + 宾语 + ？\n疑问词 + be + 表语 + ？\n\n\n能作主语的疑问词有：\n\n\nwhich + 名词单数\nwhose + 名词\nhow many + 名词复数\nhow much + 不可数名词\nwhat + 名词\nwhat\nwho\n\n\n被动句感叹句","categories":["学习笔记"],"tags":["英语语法","简单句"]},{"title":"英语语法 | 词性","url":"/posts/78cf5cff/","content":"英语十大词性：\n\n\n\n中文名称\n英文名称\n简写\n例子\n\n\n\n名词\nnoun\nn.\nstudent（学生）\n\n\n代词\npronoun\npron.\nyou（你）\n\n\n形容词\nadjective\nadj.\nhappy（高兴）\n\n\n副词\nadverb\nadv.\nquickly（迅速地）\n\n\n动词\nverb\nv.\ncut（砍、割）\n\n\n及物动词\ntransitive verb\nvt.\nbuy（买）\n\n\n不及物动词\nintransitive verb\nvi.\ncry（哭）\n\n\n数词\nnumeral\nnum.\nthree（三）\n\n\n冠词\narticle\nart.\na（一个）\n\n\n介词\npreposition\nprep.\nat（在……）\n\n\n连词\nconjunction\nconj.\nand（和）\n\n\n感叹词\ninterjection\ninterj.\noh（哦）\n\n\n\n\n\n名词世间万物的名称。\n普通名词指称人或事物的总类的名词。\n可数名词肉眼能分清数量的名词。一个可数名词的单数是不能单独在句子或短语里出现的，需要加限定词或加冠词，或变复数。限定词有形容词性物主代词、指示代词、有生命的名词所有格、数词等。\n单数变复数的规则：\n\n\n以元音字母 + o 或 y 结尾的直接 + s\n以 s、x、ch、sh 结尾的直接 + es\n以辅音字母 + o 结尾的直接 + es\n以辅音字母 + y 结尾的将 y 改为 i 再 + es\n以 f 或 fe 结尾的将 f 或 fe 改为 v 再 + es\n\n\n不可数名词肉眼分不清数量的名词。不可数名词没有复数的格式，只有单数的格式。不可数名词属于单数概念，作主语时后面的谓语动词要考虑变单数格式。\n复数名词只有复数的形式，没有单数的形式。比如：\n\n\npeople（人们）、police（警察）。\n\n\n专有名词人名、地名、国家名、景观名。\n复合名词名词作前置定语可以看作是复合名词。复合名词是由两个或两个以上的词组成的名词，它们作为一个单位共同确定一个人、地方或事物。\n复合名词通常由两个名词或一个形容词和一个名词组成。比如：\n\n\nEnglish book（英语书）、peanut oil（花生油）、chicken paw（鸡爪）。\n\n\n判断一个复合名词是可数或不可数，取决于后面那个名词。比如：\n\n\nEnglish book 中的 book 是可数的，所以这个复合名词就是可数的。\npeanut oil 中的 oil 是不可数的，所以这个复合名词就是不可数的。\n\n\n复合名词中，前面的那个名词即使是可数名词，也不能是复数形式。比如：\n\n\nchicken paw 中的 chicken 只能是单数形式。\n\n\n名词短语前置定语加名词或者名词加后置定语。\n所有格所有格就是所有者与所有物的所属关系。\n名词所有格名词所有格是表示所属关系的一种格式。所有格与名词连用，即表示一个物体与另一物体的从属关系。\n\n\n有生命的名词 + ‘s\nNice’s school bag（Nice 的书包）名词所有格 Nice’s 作前置定语。\nmy friend’s book（我朋友的书）名词所有格 my friend’s 作前置定语。\n\n\nof + 无生命的名词\nthe price of oil（油的价格）名词所有格 of oil 作后置定语。\nthe color of the house（这个房子的颜色）名词所有格 of the house 作后置定语。\n\n\n\n\n双重所有格双重所有格是由无生命的名词所有格与有生命的名词所有格共同构成的。双重所有格主要作后置定语，修饰一个普通名词，表示全体中的一部分。双重所有格有时候也可以加强语气或表示某种感情色彩。双重所有格的使用主要是为了避免名词重复。\n\n\nof + 有生命的名词 + ‘s\nthree books of my friend’s（我朋友的其中三本书）\na student of Nick’s（Nick 的其中一个学生）\n\n\nof + 名词性物主代词\nthree books of mine（我的其中三本书）\na friend of mine（我的其中一个朋友）\n\n\n\n\n代词为了避免重复而代替名词的词语（生活中使用代词的频率非常高）。\n人称代词代替人的代词就叫人称代词，有些人称代词也可以指代事物。人称代词的主格只能作主语，宾格只能作宾语，都能作表语。\n主格作主语的格式。人称代词主格有：\n\n\nI（我）、we（我们）、you（你&#x2F;你们）。\nshe（她）、he（他）、it（它）、they（他们&#x2F;她们&#x2F;它们）。\n\n\n两个或者两个以上的人称代词主格作并列主语的时候，顺序为：\n\n\n单数：you &gt; he(she) &gt; I\n复数：we &gt; you &gt; they\n\n\n宾格作宾语的格式。人称代词宾格有：\n\n\nme（我）、us（我们）、you（你&#x2F;你们）。\nher（她）、him（他）、it（它）、them（他们&#x2F;她们&#x2F;它们）。\n\n\n物主代词表示所有关系的代词叫作物主代词。\n形容词性置于名词前，起修饰作用，表示某人的。具有形容词的特性，常放在名词前面作定语（前置定语）。比如：\n\n\nmy book（我的书）、our house（我们的房子）。\n\n\n名词性名词性物主代词 &#x3D; 形容词性物主代词 + 名词名词性物主代词就相当于一个名词，所以可以作主语、表语或者宾语等，但是只能在前面提到或者避免重复的时候才能用。在物体已经指出的情况下而用来代替已知物体的物主代词，后面不需要加上已知名词。比如：\n\n\nYour book is more expensive than mine（你的书比我的贵）其中 mine 就是表示 my book。\n\n\n指示代词this（这个）和 that（那个）修饰或限定可数名词的单数和不可数名词，不能修饰可数名词的复数。these（这些）和 those（那些）只能修饰或限定可数名词的复数。\nsuch（这样的、如此的）在句子中作主语和前置定语。such 可以修饰复数名词，也可以修饰不可数名词。当 such 做前置定语时，如果修饰的名词前面有不定冠词 a&#x2F;an 则将不定冠词放在 such 后面。\n\n\nsuch was the story（故事就是这样）实际上 such 是表语，倒装句变成主语。\nsuch a beautiful girl（如此漂亮的女孩）\n\n\nsame（同样的）在句子中作主语、表语、宾语、前置定语。same 前面一定要加定冠词 the。same 作前置定语的情况最多，而且多数修饰可数名词单数。\n\n\nthe same place（同一个地方）\nthe same school（同一所学校）\n\n\n不定代词不指明代替任何特定名词或形容词的代词叫不定代词。不定代词具有名词和形容词的性质，并有可数和不可数之分。在句子中可以作主语、表语、宾语、同位语、定语和状语。如果有不定代词修饰可数名词，则可数名词前不能有冠词。\n常见的不定代词有：\n\n\n\n①\n②\n③\n\n\n\nsome（一些）\neach（每个）\nall（全部）\n\n\nany（任何）\nevery（每个）\nmore（更多）\n\n\nboth（两者都）\nmany（很多）\none（某人&#x2F;物）\n\n\nnone（没有人&#x2F;物）\nmuch（很多）\nfew（极少数）\n\n\neither（两者之一）\nanother（另一个）\nlittle（极少量）\n\n\nneither（两者都不）\nother（别的&#x2F;其他）\nno（没有）\n\n\n反身代词表示“某某自己”的代词叫反身代词，一般只作宾语、介词宾语、表语、同位语，不能作主语。\n\n\n第一、二人称\n形容词性物主代词 + self&#x2F;selves\n\n\n第三人称\n人称代词宾格 + self&#x2F;selves\n\n\n\n\n\n\n\n\n单数\n复数\n\n\n\n第一人称\nmyself（我自己）\nourselves（我们自己）\n\n\n第二人称\nyourself（你自己）\nyourselves（你们自己）\n\n\n第三人称\nhimself（他自己）  herself（她自己）  itself（它自己）\nthemselves（他们&#x2F;她们&#x2F;它们自己）\n\n\n相互代词表示相互关系的代词叫相互代词，一般只作宾语、介词宾语，其所有格形式作前置定语。\n\n\neach other（两者之间）\none another（三者及以上）\n\n\n疑问代词连接代词关系代词形容词形容词一般只可以作前置定语、表语和宾补。主要用来修饰名词或代词，表示人或事物的性质、状态和特征的程度好坏与否。\n种类\n\n普通形容词\n单独一个单词的形容词。\n\n\n复合形容词\n两个或多个单词一起构成一个新的形容词词性的复合词。\n复合形容词不能自己随意组合。\n一般复合形容词中的每个单词使用减号（-）连接。\n\n\n\n\n作用作表语：\n\n\n可以直接构成一个句型。\nYou are rich（你是有钱的）形容词 rich 作表语。\n\n\n\n\n作前置定语：\n\n\n不能直接造句，只能修饰一个普通名词，且只和名词有关系，放在名词前面构成短语。\nbusy people（忙碌的人们）形容词 busy 作前置定语修饰名词 people。\n\n\n冠词不属于形容词，但是永远要放在作前置定语的形容词前面。\nShe is my kind teacher（她是我善良的老师）冠词 my 一定放在形容词 kind 前面。\n\n\n两个或者两个以上形容词作前置定语时，顺序为：\n描绘性的形容词、表示形状的形容词、表示年龄或者新旧的形容词、表示颜色的形容词、表示来源出处的形容词、表示材料物质的形容词、表示用途的形容词。\n\n\n形容词之间使用 and 连接，可以不用考虑顺序。\n\n\n作宾补：\n\n\n只有特定的及物动词后面才可以跟形容词作宾补。比如：\nI make you rich（我让你有钱）中 make 是一个特定的及物动词，rich 作宾补。\n\n\n\n\n形式大部分的形容词都有三种形式：原级、比较级、最高级。比较级相当于中文里的更的意思，最高级相当于最的意思。比如：原级 beautiful（漂亮的）、比较级 more beautiful（更漂亮）、最高级 most beautiful（最漂亮）。\n变化规则：\n\n\n单音节形容词：比较级&#x3D;原级+er；最高级&#x3D;原级+est\n以 y 和 ow 结尾的双音节形容词：比较级&#x3D;原级+er；最高级&#x3D;原级+est\n三音节或多于三音节的形容词：比较级&#x3D;more+原级；最高级&#x3D;most+原级\n其他双音节形容词：两种形式均适用\n不规则形式：有少数形容词的比较级和最高级是不规则的\n\n\n用法：\n\n\n形容词的比较级和最高级跟形容词的原级一样，可以作前置定语和表语，甚至宾补。比如：\nI have a better way（我有一个更好的办法）形容词比较级 better 作前置定语。\nShe is my best friend（她是我最好的朋友）形容词最高级 best 作前置定语。\n\n\n\n\n句型：\n\n\nA 超过 B：\nA + be + 形容词比较级 + than + B\nI am taller than him（我比他高）。\nMy book is cheaper than yours（我的书比你的便宜）。\n\n\nA 不如 B：\nA + be not + 形容词比较级 + than + B\nI am not raller than him（我没有他高）。\nMy girlfriend is not more beautiful than her（我女朋友没有她漂亮）。\n\n\nA 和 B 一样：\nA + be + as + 形容词原级 + as + B\nI am as tall as him（我和他一样高）。\nMy girlfriend is as beautiful as her（我女朋友和她一样漂亮）。\n\n\nA 是最什么的：\nA + be + the + 形容词最高级 + 表示范围的词语\nHe is the richest in China（他是中国最有钱的）。\n\n\n\n\n动词表示动作或者心理行为（活动）的词语。比如：\n\n\n动作：eat（吃）、drink（喝）、play（玩）、buy（买）。\n心理行为：think（思考）、like（喜欢）、know（知道）。\n\n\n谓语动词专门充当谓语的动词，谓语动词只能作谓语。谓语动词主要由实义动词充当。\n系动词也称连系动词。只有一个作用，就是跟表语构成系表结构作状态型谓语。系动词是不能单独使用的，必须跟表语一起用。\nbe 系动词：\n\n\n主语决定使用哪个 be 系动词。\n现在一般时态\nam：主语是 I 的情况用 am\nis：主语是第三人称单数用 is\nare：主语是复数和 you 时用 are\n\n\n过去一般时态\nwas：主语是单数用 was\nwere：主语是复数和 you 时用 were\n\n\nbeen：过去分词用 been\nbeing：现在分词用 being\nbe：用于动词不定式或者放在情态动词、助动词后\n\n\n特殊系动词：\n\n\n特殊系动词后面必须跟形容词作表语。\n是从实义动词借过来作系动词，意思会发生变化。比如：\nYou look beautiful（你看起来很漂亮）中 look 作系动词，形容词 beautiful 作表语。\n\n\n\n\n助动词助动词是没有意思的，不能单独使用。它的作用就是帮助实义动词或系动词构成复合谓语，或者构成疑问句、否定句以及成为各种时态、语态和语气。英语没有专门的助动词。\n\n\nbe\ndo&#x2F;did&#x2F;does\nhave&#x2F;has&#x2F;had\nwill\nwould\nshall\nshould\n\n\n实义动词表示有实际意义的动词，用来区别系动词、助动词和情态动词。\n变化规则：\n\n实义动词五种形式都是同一个意思。过去式、过去分词、现在分词和第三人称单数格式都是通过原型变化而成的。\n\n变过去式和过去分词在原型后面 + ed\n词尾是 e 的动词 + d\n词尾只有一个辅音字母的重读闭音节的动词先双写这个辅音字母再 + ed\n词尾是辅音字母 + y 的动词改 y 为 i 再 + ed\n\n\n变现在分词在原型后面 + ing\n以不发音的 e 结尾的动词去掉 e 再 + ing\n以一个辅音字母结尾的重读闭音节的动词先双写此辅音字母再 + ing\n以 ie 结尾的动词把 ie 变为 ying\n\n\n变第三人称单数格式在原型后面 + s\n以 s、x、o、ch、sh 结尾的动词 + es\n以辅音字母 + y 结尾的动词变 y 为 i 再 + es\n\n\n\n\n及物动词：\n\n\n双宾动词（可以有两个宾语的动词）也属于及物动词。\n及物动词后面一定要跟一个动作的对象或者承受者，也就是宾语。比如：\nbuy 就是一个典型的需要加宾语的动词，buy 这个动作需要有一个承受者，不然意思不完整。\n\n\n\n\n不及物动词：\n\n\n本身意义完整，后面不需要加宾语且不能加宾语，但是可以加状语。比如：\nsleep（睡觉）、work（工作）。\n\n\n\n\n情态动词情态动词主要的作用就是加上动词原型构成复合谓语。情态动词本身有意义，但是不完整，必须跟实义动词原形或者系动词原型构成复合谓语，一般不能跟助动词连用，但是特殊的情态动词需要助动词构成时态。\n复合动词复合动词也称短语动词，和实义动词一样分及物和不及物，由动词和另一个或几个单词构成的词组，实际上只表示一个动作，相当于一个动词的作用。比如：\n\n\nlook after（照顾）、look forward to（盼望）、look at（看）、get up（起床）。\n\n\n非谓语动词充当除了谓语以外的其他句子成分。一个动作作主语的时候，这个表示动作的动词就要变成非谓语形式（动词不定式或者动名词）才可以作主语。\n动词不定式动词不定式没有人称和数的变化，不受主语人称和谓语动词的时态变化干扰。动词不定式是动词的一种非谓语形式，是由 to + 动词原形构成。to 只是一个构成动词不定式的一个符号，本身没有意思，是用来区别谓语动词的标志。动词不定式就是为了让动词能作其他句子成分的一种方式。\n\n\nTo eat is important（吃很重要）动词不定式 to eat 作主语。\n\n\n动词不定式可以有自己的宾语和状语，同它的宾语或者状语构成动词不定式短语。动词不定式短语是单数概念。\n\n\nTo learn English is easy（学英语很容易）动词不定式短语 to learn 和动词不定式的宾语 English 作主语。\nTo be rich is a happy thing（有钱是一件快乐的事情）动词不定式短语 to be rich 作主语。\nI hope to be happy（我希望快乐）动词不定式短语 to be happy 作宾语。\n\n\n动名词动名词短语是单数概念。\n\n\nEating is important（吃很重要）动名词 eating 作主语。\nLearning English is funny（学英语是有趣的）动名词 learning 和动名词的宾语 English 作主语。\n\n\n动名词与不定式的区别：\n\n\n动名词表达的是： 状态，性质，心境，抽象，经常性，已发生的\n不定式表达的是： 目的，结果，原因，具体，一次性，将发生的\n\n\n动名词与不定式暗含的时间含义：\n\n\n动名词有正在做、习惯性做的时间含义。\n不定式有还没有做、将要去做的时间含义。\n\n\n过去分词过去分词就是一种动词形式。作谓语动词时不能单独使用，必须跟助动词构成复合谓语，主要用在现在完成时态和被动语态中。作非谓语动词的时候一般表示已经完成或被动意义，只有一种形式。过去分词和它的宾语或状语构成过去分词短语，在句中作定语、表语、宾补和状语，不能作主语和宾语。\n怎么构成过去分词短语：\n\n过去分词短语必须由及物动词构成，必须含有被动意义。\n\n及物动词过去分词 + 状语（可以是时间、地点或方式状语）\nkilled last night（昨晚被杀）\nmade in China（在中国被制造）\n\n\n双宾动词过去分词 + 宾语 + 状语（少数情况）\ngiven a book last night（昨晚被给一本书）\n\n\n特定的及物动词过去分词 + 名词作补语（少数情况）\ncalled Jack（被人叫做杰克）\n\n\n\n\n过去分词及短语作定语：\n\n\n过去分词作前置定语\n相当于形容词的作用，不过意思还是动词的意思，表示已经完成或被动意义。\n单独一个不及物动词过去分词只能表示完成意义，不能表示被动意义。\n\n\n过去分词短语作后置定语\n必须放在被修饰的名词后面作后置定语。\n被修饰的名词和过去分词之间的动作含有被动的关系。\n被修饰的名词一般需要加定冠词 the。\n\n\n\n\n过去分词及短语作表语：\n\n\n只有单独一个过去分词才可以作表语，相当于一个形容词，主语一般是表示人的名词。\n过去分词短语是不能作表语的，因为会变成被动语态。\n\n\n过去分词及短语作宾补：\n\n\n单独一个过去分词或过去分词短语只能在特定的动词后面作宾补。\n宾语和宾补是被动的关系。\n\n\n过去分词短语作状语：\n\n\n修饰谓语，说明动作发生的背景或情况。\n强调被动关系，多数情况放在句首，少数情况放在句尾或者中间。\n将原因状语从句的连接词、主语和被动语态的助动词去掉，就得到了过去分词短语作原因状语。\n\n\n现在分词现在分词跟宾语或状语构成现在分词短语。和动名词一样也是由“动词原形 + ing”构成，作非谓语时可以将现在分词当作动名词。\n现在分词及短语作定语：\n\n\n现在分词作前置定语：\n一个单独的现在分词作前置定语相当于一个形容词的作用。\n其实可以将“现在分词 + 名词”看作一个复合名词。\n\n\n现在分词短语作后置定语：\n表示正在进行或当时正在进行的动作，多修饰表示人的名词。\n表示经常性、习惯性的动作或现在的状态，可以修饰表示人以及其他的名词。\n\n\n\n\n现在分词及短语作表语：\n\n\n现在分词作表语和过去分词作表语一样，都是相当于一个形容词。\n现在分词作表语的时候多是表示主语的特征，且主语通常是没有生命的名词。\n现在分词短语作表语就是动名词作表语。\n\n\n现在分词及短语作宾补：\n\n\n现在分词及短语表示正在发生或进行的动作，其含义相当于进行时态。\n\n\n现在分词短语和不定式短语作宾补的区别：\n\n\n不定式短语作宾补的情况比现在分词短语作宾补的情况多很多。\n能跟不定式短语作宾补的及物动词比能跟现在分词短语作宾补的及物动词多。\n\n\n现在分词短语作宾补特别强调正在进行的动作，不定式短语作宾补只强调一般的动作或状态。\n不定式短语可以用“to be + 表语”的格式作宾补，而现在分词短语不能用“being + 表语”的格式作宾补。\n\n\n\n\n现在分词短语作状语：\n\n\n现在分词短语作状语表示主动意义，大部分情况放在开头然后加逗号。\n跟过去分词短语作状语一样，现在分词短语作状语也相当于某个状语从句。\n\n\n冠词冠词是用在名词前面的一种修饰词，可以用来表明所修饰的名词是特指还是泛指。在特指名词前，须用定冠词，在非特指名词前，须用不定冠词。\n定冠词定冠词有 the（这，这些）。可以修饰可数名词单数&#x2F;复数和不可数名词。凡是特指的名词，都需要加定冠词 the，不管是可数名词单数&#x2F;复数还是不可数名词。\n不定冠词不定冠词有 a 和 an 都表示一的意思。a 和 an 只能跟可数名词单数，不能跟不可数名词，也不能跟可数名词复数。a 用在以辅音开头的名词，an 用在以元音开头的名词。比如：\n\n\na book（一本书）、an apple（一个苹果）、an English book（一本英语书）、an hour（一个小时）、an old man（一个老人）。\n\n\n副词副词是指在句子中表示行为或状态特征的词，用以修饰动词、形容词、其他副词或全句，表示时间、地点、程度、方式等概念。出现多个副词时，排列顺序为：方式副词 &gt; 地点副词 &gt; 时间副词\n时间副词表示某事何时发生。主要作时间状语，大部分情况放在句尾。作时间状语时要特别注意时态问题。\n地点副词表示地点与位置关系，用来说明动作是在什么地方发生的。作地点状语的时候通常不受时态影响。\n方式副词用来表示我们如何做某事的。只能作方式状语，并且只能修饰实义动词。只能用在动作型的句子里。\n程度副词告诉我们某事发生的程度或者发生了多少。主要修饰形容词和方式副词，放在被修饰的形容词和方式副词前面。可以根据表达的需要在形容词或方式副词前加上程度副词。\n频度副词表示事情发生的频率。也是作状语，但位置特殊，放在实义动词前，系动词、助动词、情态动词后面。\n介词表示名词、代词等与句中其它词的关系。介词也叫前置词，是一种虚词，不能单独作句子成分。\n分类：\n\n\n简单介词\n由一个单词组成的介词。\n\n\n复合介词\n由两个单词组成的介词。\n\n\n分词介词\n由分词充当的介词。\n\n\n短语介词\n由几个单词构成的一个很长的介词，不管多么长都当成一个介词。\n\n\n\n\n介词宾语介词后面的词语叫介词宾语。\n介词短语介词短语 &#x3D; 介词 + 介词宾语\n\n\n介词 + 名词\nin China（在中国）\nunder the table（在桌子下）\n\n\n介词 + 人称代词宾格\nbeside me（在我旁边）\nbehind him（在他后面）\n\n\n介词 + 数词\nin 1998（在 1998 年）\nat 6:30（在 6 点 30 分）\n\n\n介词 + 动名词\nbefore having dinner（吃饭前）\nabout learning English（关于学英语）\n\n\n\n\n作用：\n\n\n作状语\nI work in China（我在中国工作）介词短语 in China 作地点状语。\nI was fat in 2015（我在 2015 年很胖）介词短语 in 2015 作时间状语。\nI tell stories in English（我用英语讲故事）介词短语 in English 作方式状语。\n\n\n作后置定语\nThe book on the table is red（桌子上的书是红色的）介词短语 on the table 作后置定语。\n\n\n作表语\nShe is under the tree（她在树下）介词短语 under the tree 作表语。\n\n\n作宾补\nI put the money in the drawer（我把钱放在抽屉里）介词短语 in the drawer 作宾补。\n\n\n作主补\nMy coat was put on the bed by me（我的大衣被我放在床上）介词短语 on the bed 作主补。\n\n\n\n\n数词\n\n基数词\n基本数字。比如：1~9\n\n\n序数词\n有顺序的。比如：第一、第二等\n\n\n\n\n量词构成方式：\n\n\na&#x2F;an&#x2F;one + 可数名词单数 + of\na cup of（一杯）、a bucket of（一桶）、a box of（一箱）。\n\n\n数词 + 可数名词复数 + of\ntwo bottles of（两瓶）、three tins of（三罐）、ten boxes of（十箱）。\n\n\n\n\n构成要求：\n\n\n有内部空间\nbag（袋子）、basket（篮子）、truck（卡车）。\n\n\n容器\ncup（杯子）、glass（玻璃杯）、bottle（瓶子）。\n\n\n符合逻辑\nbar（条）、piece（块）、loaf（条）。\n\n\n\n\n使用规则：\n\n\n修饰不可数名词\na cup of coffee（一杯咖啡）。\ntwo cups of milk（两杯牛奶）。\n\n\n修饰可数名词的复数\na box of apples（一箱苹果）。\ntwo boxes of books（两箱书）。\n\n\n不能修饰可数名词单数\n\n\n","categories":["学习笔记"],"tags":["英语语法","词性"]},{"title":"英语语法 | 语态","url":"/posts/9e47et28/","content":"语态是动词的一种形式，用来表明主语与谓语动词之间的关系。\n\n\n\n主动语态主动语态表示主语是动作的执行者。谓语动词是主动语态的句子叫主动句。\n举个例子：\n\n\nI teach English every day.（我每天学英语）\n\n主语 I 是谓语动词 teach 的动作执行者，teach 的动作是由 I 做的。所以这句话是一个主动句。\n\n被动语态被动语态表示主语是动作的承受者。谓语动词是被动语态的句子叫被动句。只有及物动词才有被动语态，不及物动词是没有的。除了用双宾动词构成的被动句有宾语，其他被动句都没有宾语。\n举个例子：\n\n\nEnglish is learned everywhere.（英语到处被学）\n\n主语 English 是复合谓语 is learned 的动作承受者。所以这句话是一个被动句。\n\n被动语态的构成：\n\n\n主语（+ 情态动词）+ 助动词 be + 及物动词过去分词\n\n助动词 be 没有意思，有时态、人称和数的变化，其变化规律与系动词 be 完全一样。\n\n时态变化：\n\n\n\n时态\n结构\n\n\n\n一般现在时态\n主语 + is&#x2F;are&#x2F;am + 及物动词过去分词\n\n\n一般过去时态\n主语 + was&#x2F;were + 及物动词过去分词\n\n\n一般将来时态\n1. 主语 + will + be + 及物动词过去分词  2. 主语 + be going to + be + 及物动词过去分词\n\n\n现在进行时态\n主语 + is&#x2F;are&#x2F;am + being + 及物动词过去分词\n\n\n现在完成时态\n主语 + has&#x2F;have + been + 及物动词过去分词\n\n\n什么时候使用被动语态：\n\n\n在不知道动作执行者是谁的时候。\n当动作的执行者是泛指或不言自明的时候。\n虽然可以说出动作执行者，但动作的承受者才是谈话的中心或特别需要强调。\n出于礼貌，委婉而避免提及自己或对方。\n用在文章标题、广告、新闻等里面（常常省略 be）。\n当动作的执行者不是人时。\n\n\n双宾动词变成被动语态的情况：\n\n\n间接宾语作主语 + 助动词 be + 双宾动词过去分词 + 直接宾语\n直接宾语作主语 + 助动词 be + 双宾动词过去分词 + to + 间接宾语\n\n\n","categories":["学习笔记"],"tags":["英语语法","语态"]},{"title":"英语语法 | 语气","url":"/posts/b86ba424/","content":"语气是谓语动词的一种形式，表示说话人对某一行为或者事情的看法和态度。主要的三种语气：陈述语气、祈使语气、虚拟语气。其他语气：疑问语气、条件语气、感叹语气。\n\n\n\n陈述语气\n肯定句\n否定句\n感叹句\n\n疑问语气\n一般疑问句\n特殊疑问句\n选择疑问句\n反意疑问句\n\n祈使语气祈使句：\n\n没有主语，谓语动词用原形的句子。\n表示说话人向对方提出的请求、邀请，给予忠告、指示、警告，发出警告等。\n语气强烈的时候，一般用感叹号，其他情况可以用句号。\n通常没有主语，有时候也会加上 you 表示强调。\n\n构成方式：\n\n（Don’t +）及物动词原形 + 宾语（+ 状语）\n（Don’t +）不及物动词原形（+ 状语）\n（Don’t +）be + 表语（+ 状语）\n\n虚拟语气动作或者状态不是客观存在的事实，而是说话人的主观愿望，假设、假想或推测。虚拟语气其实就是那些不真实或者不可能发生的假设。\n假设的情况\n\n\n假设的情况\n主语谓语形式\n从句谓语形式\n\n\n\n与过去事实相反\nshould&#x2F;would&#x2F;could&#x2F;might+have+过去分词\nhad+过去分词\n\n\n与现在事实相反\nshould&#x2F;would&#x2F;could&#x2F;might+动词原形\n动词过去式&#x2F;were\n\n\n与将来事实相反\nshould&#x2F;would&#x2F;could&#x2F;might+动词原形\n1. 动词过去式&#x2F;were  2. should+动词原形  3. were to+动词原形\n\n\n\nshall(原形)——&gt;should(过去式)will(原形)——&gt;would(过去式)can(原形)——&gt;could(过去式)may(原形)——&gt;might(过去式)\n\n与过去的事实相反：\n\n\n主句构成方式：\n主语 + would&#x2F;should&#x2F;could&#x2F;might + have + 实义动词过去分词（+ 宾语）\n主语 + would&#x2F;should&#x2F;could&#x2F;might + have + been + 表语\n\n\n从句构成方式：\nIf + 主语 + had + 实义动词过去分词（+ 宾语）+ 表示过去的时间状语\nIf + 主语 + had + been + 表语 + 表示过去的时间状语\n\n\n\n\n与现在的事实相反：\n\n\n主句构成方式：\n主语 + would&#x2F;should&#x2F;could&#x2F;might + 实义动词原形（+ 宾语）\n主语 + would&#x2F;should&#x2F;could&#x2F;might + be + 表语\n\n\n从句构成方式：\nIf + 主语 + 实义动词过去式（+ 宾语）+ 表示现在的时间状语\nIf + 主语 + were + 表语 + 表示现在的时间状语\n\n\n\n\n与将来的事实相反：\n\n\n主句构成方式：\n主语 + would&#x2F;should&#x2F;could&#x2F;might + 实义动词原形（+ 宾语）\n主语 + would&#x2F;should&#x2F;could&#x2F;might + be + 表语\n\n\n从句构成方式：\nIf + 主语 + 实义动词过去式（+ 宾语）+ 表示将来的时间状语\nIf + 主语 + should + 实义动词原形（+ 宾语）+ 表示将来的时间状语\nIf + 主语 + were + 表语 + 表示将来的时间状语\n\n\n\n\n其他情况主句和从句的动作发生的时间不一致的情况：\n\n\n与过去的事实相反的从句构成方式 + 与现在的事实相反的主句构成方式\n\n\n虚拟条件状语从句省略连接词 if 的情况：\n\n\n书面语中，如果虚拟条件状语从句中有 were、had 或 should，可以把 if 省略，但是要把这几个词移到主语的前面，构成主谓倒装。\n省略 if 的虚拟条件状语从句，句首不能用助动词的缩略否定形式。\n\n\n用介词短语代替虚拟条件状语从句：\n\n\n一些表示“条件”的词或短语，如 with、without、but for、but that、in case of、under more favorable condition、in the absence of 等，可以暗示虚拟条件的存在。\n\n\n省略条件状语从句或主句：\n\n\n表示虚拟语气的主句或者条件状语从句有时可以省略，但是虚拟的意义还在。\n省略主句只保留 if 引导的虚拟条件状语从句，一般表示某种不可能实现的愿望。\n不管句子是省略主句还是从句，谓语动词必须符合虚拟语气的构成方式。\n\n\n特殊情况：\n\n\n有时候虚拟语气只是表示委婉或礼貌一点，不一定是不真实的情况。\n有时候 should 跟 would 是同义词，都是一个助动词，没有意思。\n\n\n其他用法在宾语从句的用法：\n\n\n一般只有 wish 后面跟一个 that 引导的宾语从句才会有虚拟的情况。\n主句中的 wish 不用虚拟，只有宾语从句里面使用虚拟语气的结构。\n复合句句型为：主语 + wish + that 引导的虚拟宾语从句\n一般情况下，宾语从句通常省略 that 连接词。\n\n\n虚拟宾语从句三种情况：\n\n\n与现在的事实相反\n主语 + wish&#x2F;wishes +（that +）主语 + 实义动词过去式（+ 宾语）+ 状语\n主语 + wish&#x2F;wishes +（that +）主语 + were + 实义动词现在分词（+ 宾语）+ 状语\n主语 + wish&#x2F;wishes +（that +）主语 + were + 表语 + 状语\n\n\n与过去的事实相反\n主语 + wish&#x2F;wishes +（that +）主语 + had + 实义动词过去分词（+ 宾语）+ 表示过去的时间状语\n主语 + wish&#x2F;wishes +（that +）主语 + had + been + 表语 + 表示过去的时间状语\n\n\n对将来的主观愿望\n主语 + wish&#x2F;wishes +（that +）另一个主语 + would + 实义动词原形（+ 宾语）+ 表示将来的时间状语\n主语 + wish&#x2F;wishes +（that +）另一个主语 + would+ be + 表语 + 表示将来的时间状语\n\n\n\n\n在其他状语从句中的用法：\n\n\neven if&#x2F;even though 引导的让步状语从句也可以出现虚拟语气，主句和让步状语从句都用虚拟结构，构成方式和含有虚拟条件状语从句的复合句一样。\nas if&#x2F;as though 引导的方式状语从句也可以出现虚拟语气，主句不需要虚拟，从句和虚拟条件状语从句构成方式一样。\n\n\n","categories":["学习笔记"],"tags":["英语语法","语气"]},{"title":"英语语法","url":"/posts/81c4e30a/","content":"\n《英语阅读参考手册》为主，点此下载电子书。  《柯林斯 COBUILD 英语语法大全》为辅。  不想看书，就看英语兔的视频吧：一个视频说清整个英语语法体系（重塑你的语法认知框架）- 哔哩哔哩 bilibili\n\n\n\n\n英语时态英语语法：16 种时态终极详解合集 by 英语兔 - 哔哩哔哩 bilibili\n\n过去时：I had lunch already. 我吃过午饭。\n现在时：I am having lunch. 我正在吃午饭。\n未来时：I am going to have lunch. 我（将要）去吃饭了。\n现在完成时（Present Perfect Tense）：I have had lunch. 我吃完午饭了。\n\n现在完成时（Present Perfect Tense）：\n\n\n\n\nJust\nYet\nStill\nAlready\n\n\n\n意思\n刚刚、刚好、刚才\n还未完成\n原本预计内应该要完成，但还未完成\n已经完成，比预期内提早完成\n\n\n位置\n放在助动词 Have 与动词之间\n句末\n句中\n放在助动词 Have 与动词之间\n\n\n语气\n–\n中立\n批判\n–\n\n\n否定型\n–\n√\n√\n–\n\n\n例句\nI have just handed in my homework. (我刚刚递交了功课。)\nI have not yet handed in my homework. (我还未递交功课。) (暗藏意味：尚未完成某些事，也不知道什么时候会完成，时间点比较模糊)\nI still have not handed in my homework. (我仍然未递交功课。) (暗藏意味：期限已经过了，但是我还是没有交功课。)\nI have already handed in my homework. (我已经递交了功课。) (暗藏意味：我在限期前交了功课。)\n\n\n\n什么是一般：简单的，默认的，普通的。\n一般现在时：用来表述习惯或者客观事实。（和现在没啥关系）\n什么是将来：非常确定会发生的事。\n\n虚拟语气\n英语虚拟语气就是这么简单 by 英语兔 - 哔哩哔哩 bilibili\n\n英语分 3 种语气：\n\n陈述语气：陈述事实（现实）、提出看法或问题等。所说的是真的。\nI like this book the best.\nIf you get up earlier, you will be able to catch the first bus.\n\n祈使语气：表示请求、命令或警告等。希望所说的成真。\nDon’t be so careless.\n\n虚拟语气：表示假想或主观愿望。所说的与事实不符。\nI suggest that we should go tomorrow.\nIf you dropped the glass, it would break.\n\n\nHow to 虚拟语气：\n\n以动词的过去式作为表达「非事实」的手段。\n过去式并不是过去时。虚拟语气中的过去式只是一个表示虚拟语气的形式，而不是表示过去的时态的形式。\n\n表示相反虚拟现在\n条件从句的谓语：用过去式（be 用 were）\n主句谓语：should &#x2F; would &#x2F; could &#x2F; might + 动词原形\n\ne.g. (example given)\n\nIf I were you, I would not tell him the truth.\nIf we left now, we should arrive in good time.\n\n虚拟过去因为时间本来就是过去，若还要用过去形态来表达非事实语气，就必须用过去完成的形态。\n\n条件从句的谓语：had+ 过去分词\n主句谓语：should &#x2F; would &#x2F; could &#x2F; might + have+ 过去分词\n\ne.g.\n\nIf you had got up earlier, you would have caught the first bus.\nIf he had been in that train then, he might have been killed in that accident.\n\n虚拟将来\n条件从句的谓语：用过去式（be 用 were）\n主句谓语：should &#x2F; would &#x2F; could &#x2F; might + 动词原形\n\ne.g.\n\nIf he went, would you go too.\nIf I asked him, I’m sure he’d help us.\n可能性特别低：should If I should win the lottery, I would buy you a car.\n不可能发生：were to If I were to lie to her, I would lose her.\n\n表示愿望hope 中性\nwish 可能小\n\n与现在相反 wish + 过去式： I wish (that) I were a rabbit\n与过去相反 wish + 过去完成式：I wish (that) I had eaten the carrot.\n与将来相反 wish + woud &#x2F; should &#x2F; could &#x2F; might + 动词原形：I wish (that) I could eat the carrot.\n\nwould rather 与 wish 有类似的用法：\n\nI would rather that you didn’t eat the carrot.\n\n表示请求demand &#x2F; suggest &#x2F; insist &#x2F; would rather + (should) + 动词原形\n\nI suggest that you (should) eat a carrot. (宾语从句)\nIt is suggested that you (should) eat a carrot. (主语从句)\nThe suggestion is that you (should) eat a carrot. (表语从句)\nIt is (high) time that you ate a carrot. (定语从句)\n\n倒装结构\nIf I were a boy, I might be very handsome. &#x3D; Were I a boy, I might be very handsome.\nbe 动词因虚拟语气变为过去式时只会变为 were，而永远不会变成 was。\n混合时态会有一个明显的时间标识，例如 now：If I had finished my work earlier, I could have dinner now.If you’d listened to me, you wouldn’t be in such trouble now.\n混合语气\nI could have caught that bus, only that I forgot to get any money out.\n句子分类以下特指陈述句的分类。\n简单句主谓宾主语 + 谓语 + 宾语，例如：I love her.\n主谓主语 + 谓语，例如：I gave up.\n主系表主语 + 系动词 + 表语，例如：Tom is shrewd.表语之所以叫表语，意思是：表示主语状态或性质的语法成分。\n主谓 + 双宾语如果你和我一样，经常分不清间接宾语和直接宾语，就记住上面这个例子，I gave you a book，我给了你一本书。当我拿着书递到你手上时，我直接接触的是书，所以叫直接宾语，间接接触你，所以叫间接宾语。\n间接宾语和直接宾语的区别一般在疑问句里才有用，比如 Who did you buy the car for? 这句话翻译成汉语是「这辆车是你买给谁的？」，其中 who 充当了间接宾语，需要后面补出介词 for。即你不能这样问 Who did you buy the car?【误】\n主谓宾 + 宾补主语 + 谓语 + 宾语 + 宾语补足语，例如：Tom viewed Jerry as a hero.\n宾语补足语🆚后置定语\n\n宾语补足语：宾语在承受动作（谓语）之后才产生的属性，例如 We consider the answer correct.\n后置定语：表明的属性和谓语体现的动作无关，例如 Tom love the girl operating the machine.\n\n简单句 &#x3D; 主干成分 + 非主干成分\n\n主干成分即五大基本句型的语法成分：主语、谓语（包括系动词）、宾语（包括直接宾语和间接宾语）、表语、宾语补足语。\n非主干成分指修饰限定成分，通常指定语和状语。\n\n提取句子主干的步骤\n\n找出句子谓语动词\n动作的发出者：主语\n动作的接受者：宾语\n描述主语状态或属性的成分：表语\n补充说明宾语的成分：宾语补足语\n\n\n所有英语从句, 一个视频合集搞定 by 英语兔 - 哔哩哔哩 bilibili\n\n并列复合句并列复合句指若干个结构、功能、性质相同的简单句用并列连词或表示并列的标点符号（通常是分号和冒号）连接所形成的句子。例如：\n\nThe girl looked at me intently, and she invited me to her wedding.\n\n这句话中 and 这个并列连词连接了两个不同的简单句，分别是：\n\nThe girl looked at me intently.\nShe invited me to her wedding.\n\n形成了一个并列复合句。\n并列连词\n\nfor\nand\nnor (neither…nor…)\nbut\nor (either … or…)\nyet\nso\nnot only … but also …\n\n首字母缩写为 fanboys（迷弟）。只有并列的对象是句子时，它才是并列复合句。\n主从复杂句主从复合句指若干个简单句用从属连词、关系代词、关系副词连接所形成的句子。例如：\n\nShe said that the President went to the hospital yesterday.\n\n这句话由两个简单句组成，其中一个是 she said …，另一个是 the President went to the hospital yesterday，其中 that 引导了第二个句子，整体作为前面这个句子的宾语，即宾语从句。\n定语从句也叫形容词从句或关系从句。\n其指代对象就是先行词。\n关系代词引导\nwhich &#x2F; that &#x2F; who &#x2F; whom &#x2F; as …+ 非完整句（有时可以省略关系代词）\nwhose …+ 完整句\n介词 + 关系代词（非 that &#x2F; as）… + 完整句\n\nthat vs which\n\nthat：先行词是唯一的，有明确的对象，没得选 The rabbit ate the largest carrot that I’ve ever seen. All the rabbits that ate a carrot. The only rabbit that ate a carrot. The first rabbit that ate a carrot.\nwhich：先行词多选一，可替换为 that The rabbit ate a carrot which i bought. The rabbit ate a carrot that bought.\n\n非限定性形容词从句作插入语\n\nMy head, which is big, is useful when it rains. 我有大头，下雨不愁。\nThe biggest carrot, which the rabbit ate, was on the table. 最大的那根胡萝卜曾在桌上，兔子吃了它。\n\n非限定性形容词从句指代整句话\n\nThe rabbit ate the carrot, which was not surprising. 兔子吃了胡萝卜，这事儿不令人吃惊。\n\n关系副词引导\nwhen &#x2F; where &#x2F; why … + 完整句\n\n主语从句\nThat &#x2F; Whether &#x2F; How &#x2F; Where &#x2F; When + 完整句 + 谓语动词 + …\nWhat &#x2F; Who + 非完整句 + 谓语动词 + …\n\n主语从句太长，让整个句子头重脚轻，就可以用 It 做形式主语：\n\nIt（形式主语）+ 谓语动词 + … + that + 完整句\nIt is suggested &#x2F; important &#x2F; essential &#x2F; necessary &#x2F; demanded &#x2F; insisted &#x2F; ordered that you (should) eat a carrot. （虚拟语气）\nThat you (should) eat a carrot is suggested &#x2F; important &#x2F; essential &#x2F; necessary &#x2F; demanded &#x2F; insisted &#x2F; ordered.\n\n\n\n宾语从句\n主语 + 及物动词 &#x2F; 系动词 + that &#x2F; whether &#x2F; if &#x2F; how … + 完整句\nthat 有时可省略：I know (that) the rabbit ate a carrot.\nthat 不可省略：I know, just like you do, that the rabbit ate the carrot.\n\n\n主语 + 及物动词 &#x2F; 系动词 + what &#x2F; who &#x2F; whom … + 非完整句\n\n否定加在谓语动词前，而非从句中\n\n正确：I don’t think (that) the rabbit is smart.\n错误：I think (that) the rabbit isn’t smart\n\n主从时态一致（主句时态 &#x3D; 宾语从句时态）\n\nI don’ t think (that) you’re right.\nI didn’t think (that) you were right.\nI knew (that) the rabbit liked carrots.\n永恒 &#x2F; 客观 &#x2F; 不变现象是例外：I knew (that) the sun rises in the east.\n\n表语从句主语 + 用（连）系动词 + 表语（主语补语）\n\n主语从句 + 表语：That the rabbit ate a carrot is a secret.\n主语 + 表语从句：The secret is that the rabbit ate a carrot.\n\n系动词是非 be 动词\n\nIt seems that the rabbit is hungry. It 是形式主语\nIt feels that you’re not telling the truth.\n\n同位语从句名词性成分 + that &#x2F; whether &#x2F; who … + 完整句\n\nThe fact that the rabbit ate the carrot did not surprise me. 兔子吃了胡萝卜这个事实并没让我吃惊。\nThe question whether the rabbit will eat the carrot is on all our minds. 兔子是否会吃胡萝卜这个问题萦绕在我们所有人心中。\nI have no idea who ate the carrot. 我不知道谁吃了那胡萝卜。\n\n状语从句也叫副词从句。\n状语从句通常会出现在主句的前面或后面，有时插入主句中间也会被两个逗号隔开，因此相对来说比较好拆分。其形式也很简单：连词 + 完整句。\n时间状语从句\n\n\n连词\n用法\n\n\n\nbefore\n之前\n\n\nwhen\n某个时间点，突然\n\n\nwhile\n一个时间段\n\n\nas\n同时\n\n\nafter\n之后\n\n\nsince\n从之前某一个时间点开始算，一般用完成时态\n\n\nuntil\n直到某一时间点\n\n\nas soon as\n一……就……\n\n\nthe next time\n下次\n\n\n地点状语从句The rabbit ate the carrot where he found it.\n\n地点状语从句 where he found it &#x3D; 地点\n\nThe rabbit ate the carrot at the place where he found it\n\n定语从句 where he found it 修饰先行词 place\n\n引导词 whee 的强调形式有 wherever、everywhere、anywhere\n比较状语从句口语中可以省略句末的 be 动词。\n更\n\nHe is smarter than me &#x2F; l (am) .\nThis carrot is bigger than that one (is) .\nShe is more beautiful than Snow White (is).\n\n同样\n\nHe is as smart as I am &#x2F; me.\nThis carrot is as big as that one (is).\nShe is as beautiful as Snow White (is).\n\n越……越……\n\nThe more you practice English, the more fluent you become.\n\n条件状语从句条件句总是比主句在时态上落后一个时间段。\n\n真实条件句：If I saw a carrot. I would eat it.\n虚拟条件句：If I had seen a carrot, I would have eaten it. (虚拟语气表示与事实相反)\n\n其它引导词：\n\nUnless you like (&#x3D; If you don’t like) this video, you will not give it a thumbs-up.\nProvided that my video is excellent, you will give it a thumbs-up.\nAs long as I make excellent videos you will remain my follower.\nIn case you don’t understand, please comment below.\n\n让步状语从句具体情况\n\n假设：Even if I see a carrot, i will not eat it.\n\n事实：Although I see a carrot, i will not eat it.\n\n引导词 Although &#x3D; Though &#x3D; Even though，后面主句不能加 but\n\n\n\n未知情况\n\nNo matter what happens, I will not eat the carrot.\n引导词 No matter &#x3D; Regardless of\n\n方式状语从句假设发生\n\n方式状语从句：You spend (so much) money as if you were a millionaire.\n主句 You spend (so much) money 已发生\n\n\n虚拟语气：If you were a millionaire, you would spend a lot of money.\n从句 If you were a millionaire 未发生\n\n\n\n正在发生\n\nEat the carrot as i do.\n\n方式（the way）状语从句换成定语从句：\n\nYou spend money the way (in which) millionaires do.\nEat the carrot the way (in which) I eat it.\n\n由此可见，方式状语从句的表达更简洁。\n原因状语从句Because（引导从句，用在复杂句）和 so（连词，用在复合句）不能同时使用：Because the rabbit was hungry, so he ate the carrot.\n语气程度：Because &gt; Since &gt; As\n\nBecauseL：实实在在的因果关系\nSince：众所周知的原因（只能放在主句之前）\nAs：显而易见的事实（只能放在主句之前）\n\nBecause（主从句）vs for（并且句，放在后面）\n\nBecause：直接的因果关系\nfor：先果后因，一般前面是猜测，后面 for 提供依据\n\n目的状语从句In order that I could finish the video in time, I pulled an all-nighter.\n等于\nI pulled an all-nighter so that I could finish the video in time. (so that 不能放在开头)\n结果状语从句I ate a lot of carrots for lunch so that I wasn’t hungry at all in the afternoon.\nI ate so many carrots for lunch that I felt sick afterwards.\nIt was such a tasty carrot that I ate it all at once. (such + 名词)\nIt was so tasty a carrot that I ate it all at once. (so + 形容词)\n其它语法非谓语动词谓语动词是被主语限定的供动词（finite verbs），作为句子的核心，表示主语怎么样。它有三大本领：\n\n表示动作的时间\n表示动作的状态\n表示动作的语气（假设、情感等）\n\n非谓语动词不会被主语限定（non-finite verbs），不用学（没有）以上三个本领。\n动词不定式infinitive 是无限的意思，不受时间和人称的限制。\n形式：to（可省略）+ 动词原形\nfull infinitive（保留 to）\nTo be or not to be, that is the question.生存还是毀灭，这是一个问题。\nbare infinitive（省略 to）\nYou helped me (to) cook the carrot.你帮我烧（做菜）了胡萝卜。\n动词不定式作主语\nTo eat a carrot every day is good for the rabbit.一天吃一根胡萝卜对兔子有好处\n头重脚轻，改为：it（形式主语） is + 形容词 + for sb. + to do sth.\nIt is good for the rabbit to eat a carrot every day.\n等于主语从句：It is good that the rabbit eats a carrot every day.\n动词不定式作宾语\nThe rabbit likes to eat carrots.兔子喜欢吃胡萝卜。\nI consider it（形式宾语） important to eat a carrot every day.我发现每天吃一个胡萝卜很重要。\n动词不定式作宾语补足语\nThe rabbit expected the wolf to eat a carrot.兔子指望狼吃一根胡萝卜。\n使役动词 see、find、watch、have、make、let……可省略 toCarrots make the rabbit feel happy.胡萝卜使兔子感到快乐。\nThe wolf helped the rabbit (to) grow carrots狼帮兔子种胡萝卜。\n动词不定式作定语\nThe rabbit has a lot of carrots to eat.兔子有很多胡萝卜要吃。\n动词不定式作状语\n表原因I was surprised to get a thumbs-up. &#x3D; I was surprised because I got a thumbs-up.我很开心（因为）得到一个赞。\n表目的I will do anything to get a thumbs-up. &#x3D; I will do anything in order that I get a thumbs-up.我为了得到一个赞会做任何事。\n表结果I got enough thumbs-up to make another video. &#x3D; I got enough thumbs-up so that I made another video.我得到足够的赞，可以去做另一个视频啦！\n动名词相当于名词。\n动词不定式作主语\nEating carrots is healthy for the rabbit.吃胡萝卜（这个行为）对兔子来说很健康.\n动名词作主语补语（表语）\nThe rabbit’s hobby is growing carrots.兔子的爱好是种胡萝卜。\nSeeing is believing.眼见为实。\n动名词作定语\n说明被修饰词的性质，功能或用途。\na sleeping pill &#x3D; a pill for sleeping\n动名词作宾语\nThe rabbit likes eating carrots.兔子喜欢吃胡萝卜。\nThe rabbit enjoys eating carrots.兔子喜欢吃胡萝卜。动词后面只能接动名词的单词或者短语：\n\nenjoy\navoid\nadvise\nconsider\nescape\nmind\npractice\ninsist on\ngive up\nfeel like\nput off\n……\n\n介词 + 宾语（动名词）\nThe rabbit is fond of eating carrots.兔子喜欢吃胡萝卜。\nThe rabbit is looking forward to（介词） seeing the wolf again.兔子期望再次见到狼。\n现在分词相当于形容词。\n现在分词作定语\n表明被修饰词的状态，但并不一定表明发生在现在。a sleeping rabbit ≠ a rabbit for sleeping\n现在分词作表语\nThe game is exciting.游戏是刺激的。\n现在分词作宾语补足语\nThe wolf saw the rabbit eating a carrot.狼之前看到兔子正在吃一根胡萝卜。\n现在分词作状语\n表时间Hearing the news, the rabbit became excited.听到这个消息，兔子很激动。When he heard the news, the rabbit became excited.听到这个消息时，兔子很激动。\n表原因Not knowing what to eat, the rabbit skipped lunch.不知道吃什么，兔子没吃中饭。Because he didn’t know what to eat, the rabbit skipped lunch.听到这个消息时，兔子很激动。\n过去分词不一定表示过去；暗含被动的意思。\n过去分词作定语\na minced carrot一根绞碎的胡萝卜\n过去分词短语作定语，要后置\nThe carrot cake eaten by the rabbit is delicious.被兔子吃了的胡萝卜很美味。\n过去分词作表语\nThe rabbit is interested.被动 兔子很有兴趣。The story is interesting.主动 故事很有趣。The rabbit was frightened.被动 兔子感到害怕。The rabbit was frightening.主动 兔子令人感到害怕。\n过去分词作宾语补足语\nThe rabbit found his carrot stolen.兔子发现他的胡萝卜被偷了。\n过去分词作状语\n表地点Seen from the hill, the carrot field looks beautiful.从山上看，胡萝卜田看上去很美。Seeing the carrot field, the rabbit ran towards it.看到胡萝卜田，兔子朝着它跑去。\n表原因Born in a rabbit family, the rabbit’s only work is growing carrots.由于出生在一个兔子家庭里，兔子的唯一工作就是种胡萝卜。\n表条件Given another chance, the rabbit would go to the wolf’s party.如果再给兔子一次机会，他会去参加狼的聚会。\n倒装句Here comes the rain again &#x3D; The rain comes here again.\n不定式表结果\nI hurried to the railway station to find my train is gone.\n✔️ 我匆忙地赶到火车站（结果）却发现我的车已经出发了。\n❌ 我匆忙地赶到火车站，是为了发现我的车已经走了（目的）。\n\n\n🌰 A Pittsburgh-area woman with car trouble popped the hood of her vehicle to find squirrels had hidden more than 200 walnuts in the car’s body.\n🌰 He survived to see the end of the war.\n\n特殊结构的句子\nShe was the only person to survive the air crash.\n\n关联阅读\n\n博客：Liam Huang 的语法笔记：通俗易懂。\nApp：百词斩里的三分钟语法栏目。\n\n","categories":["学习笔记"],"tags":["英语语法"]},{"title":"Java | 常用类","url":"/posts/9f0878d8/","content":"Java 的常用类有包装类、字符串类、Math 类、Arrays 类、System 类、大数字类、日期类。\n\n\n\n包装类Java 有 8 种基本数据类型，Java 中的每个基本数据类型都被包装成了一个类，这些类被称为包装类。\n包装类可以分为 3 类：Number、Character、Boolean。\n包装类的架构图如下所示：\n\n\n\n\n基本数据类型\n对应的包装类\n\n\n\nboolean\nBoolean\n\n\nchar\nCharacter\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nfloat\nFloat\n\n\ndouble\nDouble\n\n\n除了 int 对应的包装类名称为 Integer 以及 char 对应的包装类名称 Character，其他 6 种数据类型对应的包装类，命名都为其基本数据类型的首字母的大写。\n装箱和拆箱什么是装箱和拆箱：\n\n装箱就是基本数据类型向包装类转换。\n\n拆箱就是包装类向基本数据类型转换。\n\n装箱和拆箱又有自动和手动之分。\n\n\njdk 5 以前需要手动装箱和手段拆箱，jdk 5 以后（含 jdk 5）实现了自动装箱和自动拆箱。\n手动装箱和拆箱：\npublic class Main &#123;    public static void main(String[] args) &#123;        int n1 = 100;        // 手动装箱 int -&gt; Integer        Integer integer = Integer.valueOf(n1); // Integer integer = new Integer(n1);        // 手动拆箱 Integer -&gt; int        int n2 = integer.intValue();    &#125;&#125;\n\n自动装箱和拆箱：\npublic class Main &#123;    public static void main(String[] args) &#123;        int n1 = 100;        // 自动装箱 int -&gt; Integer 底层仍然是使用 valueOf() 方法        Integer integer = n1;        // 自动拆箱 Integer -&gt; int 底层仍然是使用 intValue() 方法        int n2 = integer;    &#125;&#125;\n\n包装类常用方法包装类和 String 类型的相互转换：\npublic class Main &#123;    public static void main(String[] args) &#123;        // 包装类（Integer） -&gt; String        // 其他包装类方法类似        Integer n1 = 100;        String str1 = n1 + &quot;&quot;; // 方式一        String str2 = n1.toString(); // 方式二        String str3 = String.valueOf(n1); // 方式三        // String -&gt; 包装类（Integer）        String str4 = &quot;1234&quot;;        Integer n2 = Integer.parseInt(str4); // 方法一        Integer n3 = new Integer(str4); // 方法二    &#125;&#125;\n\n字符串类在 Java 中字符串属于对象，Java 提供了 String、StringBuffer 和 StringBuilder 三种类来创建和操作字符串。\n字符串的基本概念：\n\n字符串常量就是双引号括起的字符序列。\n\n字符串的字符使用 Unicode 字符编码，一个字符（不区分字母还是汉字）占两个字节。\n\n\n三种字符串类的共同点：\n\n都由 final 修饰，即都不能被其他的类继承。\n\n都实现了 CharSequence 接口。\n\n都实现了 Serializable 接口，可以串行化即可以在网络传输。\n\n\n三种字符串类的效率比较：\n一般情况下 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。\n三种字符串类的使用的原则：\n如果字符串存在大量的修改操作，一般使用 StringBuffer 或 StringBuilder，并在单线程的情况，使用 StringBuilder，多线程的情况，使用 StringBuffer。如果我们字符串很少修改，且被多个对象引用，则使用 String，例如配置信息等。\nString 类\nString 类是不可变字符串类，效率较低，但是复用率高。\n\nString 类实现了 Comparable 接口，对象可以比较大小。\n\nString 类是不可变的，对 String 对象进行任何操作，其实都是创建一个新的对象，再把引用指向该对象，效率较低。\n\n\n两种创建 String 对象的区别：\n\n直接赋值：String str = &quot;abc&quot;;\n 先从常量池查看是否有 &quot;abc&quot; 数据空间，如果有，直接指向，如果没有则重新创建，然后指向。str 最终指向的是常量池中 &quot;abc&quot; 的地址。\n\n调用构造器：String str = new String(&quot;abc&quot;);\n 先在堆中分配对象所需内存空间，里面有 value 属性，并指向常量池中 &quot;abc&quot; 的地址。如果常量池没有 &quot;abc&quot;，则重新创建，如果有，直接通过 value 指向。str 最终指向的是堆中的空间地址。\n\n\nString 类常用方法：\n\n\n\n方法名称\n描述\n\n\n\nequals()\n判断内容是否相等（区分大小写）\n\n\nequalsIgnoreCase()\n判断内容是否相等（忽略大小写）\n\n\nlength()\n获取字符的个数，字符串的长度\n\n\nindexOf()\n获取字符在字符串中第一次出现的索引，索引从 0 开始，如果找不到，返回 -1\n\n\nlastIndexOf()\n获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回 -1\n\n\nsubstring()\n截取指定范围的子串\n\n\ntrim()\n去前后空格\n\n\ncharAt()\n获取某索引处的字符，注意不能使用数组下标这种方式\n\n\ntoUpperCase()\n把字符串转换为大写\n\n\ntoLowerCase()\n把字符串转换为小写\n\n\nconcat()\n拼接字符\n\n\nreplace()\n替换字符串中的字符\n\n\nsplit()\n分割字符串\n\n\ntoCharArray()\n转换成字符数组\n\n\ncompareTo()\n比较两个字符串的大小，前者大则返回正数，后者大则返回负数，相等则返回 0\n\n\nString.format()\n格式化的字符串\n\n\nStringBuffer 类\nStringBuffer 类是可变字符串类，效率较高，线程安全。\n\nStringBuffer 类的直接父类是 AbstractStringBuilder。\n\nStringBuffer 对象保存的是字符串变量，里面的值可以更改，每次 StringBuffer 对象的更新实际上可以更新内容，不用每次都创建新对象，效率较高\n\n\nString 和 StringBuffer 类的相互转换：\npublic class Main &#123;    public static void main(String[] args) &#123;        // String -&gt; StringBuffer        String str1 = &quot;Hello World!&quot;;        // 方式一：使用构造器        StringBuffer stringBuffer1 = new StringBuffer(str1);        // 方式二：使用 append 方法        StringBuffer stringBuffer2 = new StringBuffer();        stringBuffer1.append(str1);        // StringBuffer -&gt; String        StringBuffer stringBuffer3 = new StringBuffer(&quot;Hello World!&quot;);        // 方式一：使用构造器        String str2 = new String(stringBuffer3);        // 方式二：使用 toString 方法        String str3 = stringBuffer3.toString();    &#125;&#125;\n\nStringBuilder 类\nStringBuilder 类是可变字符串类，效率最高，线程不安全。\n\nStringBuilder 类的直接父类是 AbstractStringBuilder。\n\nStringBuilder 类中的方法没有做互斥的处理，因此在单线程的情况下才使用。\n\n\nStringBuffer 和 StringBuilder 类常用方法：\n\n\n\n方法名称\n描述\n\n\n\nappend()\n追加指定字符串\n\n\ndelete()\n删除指定字符串\n\n\nreplace()\n替换指定字符串\n\n\nindexOf()\n查找指定的字符串在字符串第一次出现的索引，如果找不到则返回 -1\n\n\ninsert()\n指定一个位置插入字符串\n\n\nlength()\n获取字符的个数，字符串的长度\n\n\nMath 类Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。\nMath 类常用方法：\n\n\n\n方法名称\n描述\n\n\n\nMath.abs()\n求绝对值\n\n\nMath.pow()\n求幂\n\n\nMath.ceil()\n向上取整\n\n\nMath.floor()\n向下取整\n\n\nMath.round()\n四舍五入\n\n\nMath.sqrt()\n求开方\n\n\nMath.random()\n返回 0~1 的随机小数\n\n\nMath.min()\n求最小值\n\n\nMath.max()\n求最大值\n\n\nArrays 类Arrays 类里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）。\nArrays 类常用方法：\n\n\n\n方法名称\n描述\n\n\n\nArrays.toString()\n返回数组的字符串形式\n\n\nArrays.sort()\n排序（自然排序和定制排序）\n\n\nArrays.binarySearch()\n二分搜索进行查找，要求数组必须是有序的\n\n\nArrays.copyOf()\n数组元素的复制\n\n\nArrays.fill()\n数组元素的填充\n\n\nArrays.equals()\n比较两个数组元素内容是否完全一致\n\n\nArrays.asList()\n将一组值转换为 List\n\n\nSystem 类System 类代表当前 Java 程序的运行平台，系统级的很多属性和控制方法都放置在该类的内部。由于该类的构造方法是 private 的，所以无法创建该类的对象，也就是无法实例化该类。\nSystem 类常用方法：\n\n\n\n方法名称\n描述\n\n\n\nSystem.exit()\n退出当前程序\n\n\nSystem.arraycopy()\n复制数组元素，比较适合底层调用\n\n\nSystem.currentTimeMillis()\n用于获取当前系统时间，以毫秒为单位\n\n\nSystem.gc()\n运行垃圾回收机制\n\n\n大数字类BigInteger 类如果要存储比 Integer 更大的数字，Integer 数据类型就无能为力了。因此，Java 中提供 BigInteger 类来处理更大的数字。\nBigDecimal 类BigInteger 和 BigDecimal 都能实现大数字的运算，不同的是 BigDecimal 加入了小数的概念。BigDecimal 类支持任何精度的浮点数，可以用来精确计算货币值。\nBigInteger 和 BigDecimal 类常用方法：\n\n\n\n方法名称\n描述\n\n\n\nadd()\n加法运算\n\n\nsubtract()\n减法运算\n\n\nmultiply()\n乘法运算\n\n\ndivide()\n除法运算\n\n\n日期类第一代日期类\nDate 类用来封装当前的日期和时间。日期格式是国外的格式，因此通常需要对格式进行转换。\n\nSimpleDateFormat 类用来格式化和解析日期，它允许进行日期到文本的格式化，文本到日期的解析。\n\n\n使用 SimpleDateFormat 类格式化日期：\nimport java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Main &#123;    public static void main(String[] args) throws ParseException &#123;        // 获取当前系统时间        Date date = new Date();        // 创建 SimpleDateFormat 对象，可以指定相应的格式        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E&quot;);        // 使用 format 方法转换成指定格式的字符串        String format = simpleDateFormat.format(date);        System.out.println(format);        // 将一个格式化后的字符串转成对应的 Date        // 字符串的格式需要和 simpleDateFormat 格式一样，否则会抛出异常        String str = &quot;2023年05月01日 12:41:34 星期一&quot;;        Date parse = simpleDateFormat.parse(str);        System.out.println(simpleDateFormat.format(parse));    &#125;&#125;\n\nSimpleDateFormat 类的格式化编码：\n\n第二代日期类\nCalendar 类是一个抽象类，且构造器是 protected 的，需要使用 getInstance() 方法来获取对象。\n\nCalendar 没有提供对应的格式化类，因此需要自己自定义组合来输出。\n\n\n自定义组合输出：\nimport java.util.Calendar;public class Main &#123;    public static void main(String[] args) &#123;        // 创建 Calendar 对象        Calendar calendar = Calendar.getInstance();        // 组合输出        System.out.println(calendar.get(Calendar.YEAR) + &quot;年&quot; +                (calendar.get(Calendar.MARCH) + 1) + &quot;月&quot; +                calendar.get(Calendar.DAY_OF_MONTH) + &quot;日 &quot; +                calendar.get(Calendar.HOUR_OF_DAY) + &quot;:&quot; +                calendar.get(Calendar.MINUTE) + &quot;:&quot; +                calendar.get(Calendar.SECOND));    &#125;&#125;\n\n第三代日期类\nLocalDate 类只包含日期。\n\nLocalTime 类只包含时间。\n\nLocalDateTime 类包含日期和时间。\n\n三种类的构造器都是 private 的，都只能使用 now() 方法来获取对象。\n\nDateTimeFormatter 类用来格式化和解析日期。\n\nInstant 类是处理时间戳的，其构造器也是 private 的，需要使用 now() 方法来获取对象。\n\n\n三种类的使用：\nimport java.time.LocalDate;import java.time.LocalTime;import java.time.LocalDateTime;public class Main &#123;    public static void main(String[] args) &#123;        // 获取日期        LocalDate date = LocalDate.now();        System.out.println(date);        // 获取时间        LocalTime time = LocalTime.now();        System.out.println(time);        // 获取日期和时间        LocalDateTime dateTime = LocalDateTime.now();        System.out.println(dateTime);    &#125;&#125;\n\n使用 DateTimeFormatter 类格式化日期：\nimport java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class Main &#123;    public static void main(String[] args) &#123;        // 获取日期和时间        LocalDateTime dateTime = LocalDateTime.now();        // 创建 DateTimeFormatter 对象        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String format = dateTimeFormatter.format(dateTime);        System.out.println(format);    &#125;&#125;\n\nInstant 和 Date 类的相互转换：\nimport java.util.Date;import java.time.Instant;public class Main &#123;    public static void main(String[] args) &#123;        // 创建 Instant 对象        Instant instant = Instant.now();        // 通过 from 方法将 Instant 类转成 Date 类        Date date = Date.from(instant);        // 通过 toInstant 方法将 Date 类转成 Instant 类        Instant instant1 = date.toInstant();    &#125;&#125;\n","categories":["学习笔记"],"tags":["Java"]},{"title":"Java | 异常处理","url":"/posts/3459c33c/","content":"异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。\n\n\n\n异常的概念public class Main &#123;    public static void main(String[] args) &#123;        int num1 = 10;        int num2 = 0;        try &#123;            int res = num1 / num2;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;程序继续执行……&quot;);    &#125;&#125;\n\nJava 语言中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常）。\n执行过程中所发生的异常事件可分为两大类：\n\nError（错误）：Java 虚拟机无法解决的严重问题。如：JVM 系统内部错误、资源耗尽等严重情况。比如 StackOverflowError（栈溢出）和 OOM（out of memory），Error 是严重错误，程序会崩溃。\n\nException：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等。Exception 分为两大类：运行时异常（程序运行时，发生的异常），编译时异常（编程时，编译器检查出的异常）。\n\n\nJava 异常层次结构图：\n\n运行时异常运行时异常，编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n常见的运行时异常包括：\n\nNullPointerException 空指针异常：当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n\nArithmeticException 数学运算异常：当出现异常的运算条件时，抛出该异常。\n\nArraylndexOutOfBoundsException 数组下标越界异常：用非法的索引访问数组时，抛出该异常。\n\nClassCastException 类型转换异常：当试图将对象强制转换为不是实例的子类时，抛出该异常。\n\nNumberFormatException 数字格式不正确异常：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当的格式时，抛出该异常。\n\n\n编译时异常编译时异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。\n常见的编译时异常包括：\n\nSQLException 操作数据库时，查询表可能发生异常。\n\nIOException 操作文件时，发生的异常。\n\nFileNotFoundException 当操作一个不存在的文件时，发生异常。\n\nClassNotFoundException 加载类，而该类不存在时，发生异常。\n\nEOFException 操作文件，到文件末尾，发生异常。\n\nIllegalArguementException 参数异常。\n\n\n处理异常过程\n当程序运行到某一语句时，发生了异常，那么程序会先停下来；\n\n程序会在这句代码处查看原因，生成一个合理“异常对象”，然后“抛”出；\n\nJVM 会检测这句代码的外围是否有 try...catch 结构可以“捕获”它；\n\n如果可以捕获，那么程序在处理完异常后，继续下面的运行，不会崩溃；\n\n如果不能捕获，那么会把这个异常继续抛给“上级”；\n\n如果“上级”能处理，那么程序从“上级”处理完的代码后面继续运行；\n\n如果“上级”也不能处理，那么继续往上抛，一直到达 JVM，那么就“崩溃”；\n\n\n异常处理机制异常处理就是当异常发生时，对异常处理的方式。处理方式有以下两种：\n\ntry-catch-finally：程序在代码中捕获发生的异常，自行处理。\n\nthrows：将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理着就是 JVM。\n\n\n捕获异常\ntry 和 catch 都不能单独使用，必须连用；finally 不能单独使用，必须和 try 一起使用。\n\n如果没有发生异常，则顺序执行 try 块，不会进入到 catch 块。\n\n如果发生了异常，则 try 块剩下的语句不再执行，直接进入到 catch 块。\n\n如果有 finally 块，不论 try 块是否发生了异常，finally 块中的语句都会被执行。\n\nfinally 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放。\n\n可以有多个 catch 块，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，如果发生异常，只会匹配一个 catch 块。\n\n当只有在 try 或者 catch 中调用退出 JVM 的相关方法 System.exit(0);，此时 finally 才不会执行，否则 finally 永远会执行。\n\n可以进行 try-finally 配合使用，这种用法相当于没有捕获异常，因此程序会直接崩溃。应用场景就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。\n\n\n抛出异常\n对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理。\n\n在 throws 过程中，如果使用了 try-catch，就相当于处理了异常，就不必再 throws。\n\n在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\n\n子类重写父类的方法时，对抛出异常的规定：子类重写的方法所抛出的异常类型，要么和父类方法抛出的异常类型一致，要么为父类方法抛出的异常类型的子类型。\n\n如果一个方法抛出了一个运行时异常，调用者可以不用显示处理，因为 Java 有默认的处理机制。如果抛出了一个编译时异常，则调用者必须显示处理，否则程序就不能编译通过。\n\n如果一个方法或者方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。\n\n\n自定义异常当程序出现了某些“错误”，但该错误信息并没有在 Throwable 子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。\n自定义异常的步骤：\n\n定义类：自定义异常类名（程序员自己写）继承 Exception 或 RuntimeException。\n\n如果继承 Exception，属于编译时异常。\n\n如果继承 RuntimeException，属于运行时异常。\n\n一般情况下，自定义异常建议继承 RuntimeException，因为可以使用 Java 默认的处理机制。\n\n\nthrow 和 throws 的区别：\n\nthrow 是具体向外抛异常的动作，所以它是抛出一个异常实例。\n\nthrows 主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。\n\n\n实现代码：\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.print(&quot;输入年龄：&quot;);        int age = scanner.nextInt();        // 要求年龄范围在 18-120 之间，否则抛出自定义异常        if (!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;            // 通过构造器设置信息            throw new AgeException(&quot;年龄需要在 18-120 之间！&quot;);        &#125;        System.out.println(&quot;你的年龄范围正确。&quot;);    &#125;&#125;class AgeException extends RuntimeException &#123;    public AgeException(String message) &#123;        super(message);    &#125;&#125;\n","categories":["学习笔记"],"tags":["Java","异常处理"]},{"title":"Java | 泛型","url":"/posts/62ea5aff/","content":"泛型在 Java 中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。\n\n\n\n泛型说明泛型是一种“代码模板”，可以用一套代码套用各种类型。\n\n泛型的作用：\n\n泛型其实就是将类型参数化，从而提高参数类型的表达能力。\n泛型可以使用在类、接口和方法上，分别被称为泛型类、泛型接口和泛型方法。\n泛型可以在类声明时通过一个标识符表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。\n\n使用泛型的优势有：\n\n泛型可以使得程序在编译期间就发现类型匹配问题，而不是在运行期间发现问题。\n泛型可以明确特定对象实例化时的类型信息，避免不必要的类型转换。\n泛型可以提高代码重用性。\n\n泛型语法泛型的标识是在一对尖括号“&lt;&gt;”中包含类型形参，其中的类型形参可以有一个或多个，如：&lt;T&gt;、&lt;T, U&gt;、&lt;K, V&gt;。从语法上来说，类型形参可以是任意字符。但是从开发规范的角度来讲，一般都是采用简短的大写字母来表示：\n\n用 E 表示集合元素；\nK 和 V 分别表示键和值；\nT 可以表示任意类型，如果有多个任意类型时，可以使用和 T 相邻的字母，如：U、S。\n\n使用细节：\n\n泛型的类型实参只能使用引用类型，不能使用基本数据类型。\n在指定泛型的类型实参后，可以传入该类型或其子类型。\n泛型没有继承性。\n\n// 错误示范// ArrayList&lt;int&gt; list = new ArrayList&lt;&gt;();// 错误示范// ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;String&gt;();\n\n泛型类使用细节：\n\n泛型类的类型形参是在创建对象时确定的。\n泛型类中可以定义泛型的数组但不能初始化。\n普通成员（属性、方法）可以使用泛型变量。\n静态成员（属性、方法）不能使用类中的泛型变量，因为静态成员在类加载时还无法获得泛型变量的类型。\n如果泛型类被继承或者被实例化时，没有指定类型实参，则默认为 Object 类。\n\nclass Test&lt;K, V&gt; &#123;    private K key;    private V value;    public Test(K key, V value) &#123;        this.key = key;        this.value = value;    &#125;    public K getKey() &#123;        return key;    &#125;    public void setKey(K key) &#123;        this.key = key;    &#125;    public V getValue() &#123;        return value;    &#125;    public void setValue(V value) &#123;        this.value = value;    &#125;&#125;\n\n泛型接口使用细节：\n\n泛型接口的类型形参是在继承接口和实现接口时确定的。\n静态成员（属性、方法）不能使用接口中的泛型变量。\n如果泛型接口被继承或被实现时，没有指定类型实参，则默认为 Object 类型。\n\ninterface Test&lt;K, V&gt; &#123;    V get(K key);    V put(K key, V value);&#125;\n\n泛型方法使用细节：\n\n泛型方法的类型形参在被调用时确定。\n泛型方法既可以定义在普通类中也可以定义在泛型类中。\n泛型方法的形参列表既可以使用类声明的泛型也可以使用自己声明的泛型。\n\npublic class Main &#123;    public static void main(String[] args) &#123;        getObject(&quot;abc&quot;, 123);    &#125;    public static &lt;K, V&gt; void getObject(K key, V value) &#123;        System.out.println(key.getClass());        System.out.println(value.getClass());    &#125;&#125;\n\n泛型的通配符泛型的表达能力是非常强的，在某些场景下，如果需要限定一个类型范围，而不是某个具体类型的时候，就需要使用类型限定符或类型通配符。\n类型限定符可以归结为下面几种类型：\n\n&lt;?&gt;，表示无限制通配符。\n\n&lt;? extends Type&gt;，表示限定的类型只能是 Type 本身或它的子类，限定了泛型的上限。\n\n&lt;? super Type&gt;，表示限定的类型只能是 Type 本身或它的父类，限定了泛型的下限。\n\n\n","categories":["学习笔记"],"tags":["Java"]},{"title":"Java | 类的五大成员","url":"/posts/f9e936dc/","content":"类的五大成员：属性、方法、构造器、代码块、内部类。\n\n\n\n属性属性也称为成员变量。\n\n声明属性的语法格式：[修饰符] 数据类型 属性名;\n\n在其他类中属性的赋值：对象.属性名 = 值;\n\n声明属性的位置：必须在类中，其他成员（方法、构造器等）的外面。\n\n\n属性的特点\n属性有默认值。\n\n每一个对象的属性是独立的。\n\n\n属性的默认值基本数据类型：\n\nbyte, short, int, long 默认值为 0\n\nfloat, double 默认值为 0.0\n\nchar 默认值为 \\u0000\n\nboolean 默认值为 false\n\n\n引用数据类型：\n\n类、数组、接口默认值为 null\n\n变量的分类按照变量声明的“位置”分为可分为：\n\n局部变量\n\n成员变量\n\n实例变量：没有 static 修饰的属性。\n\n类变量：使用 static 修饰的属性。\n\n\n\n\n局部变量\n局部变量的声明的位置：方法的形参列表、方法体、代码块中。\n\n局部变量的初始化：形参的初始化，必须在调用时，由实参赋值；其他的局部变量，必须手动初始化。\n\n局部变量存放位置：栈。\n\n局部变量的生命周期：当代码执行到局部变量的声明处开始，到它的作用域结束而结束。\n\n局部变量可用的修饰符：final。\n\n\n成员变量\n成员变量的声明的位置：类中、方法和代码块等外面。\n\n成员变量的初始化：有默认值。可以显式初始化、使用构造器初始化，或者定义 set 方法可以再次修改值。\n\n成员变量存放位置：实例变量存放在堆中；类变量存放在方法区中。\n\n成员变量的生命周期：随着对象的创建而创建，随着对象被垃圾回收而消亡。每一个对象的成员变量是独立的。\n\n成员变量可用的修饰符：访问修饰符（private，默认，protected，public）、static、final、volatile 等。\n\n\n方法方法（method），又称为函数（function），代表的是一个独立的功能。例如：\n\nMath.sqrt(m) 这个 sqrt(m) 方法，返回 m 的平方根。\n\nSystem.out.println() 这个 println() 方法打印 () 中的内容。\n\n\n把代码封装到一个方法中的目的，简单的实现功能的复用。\n方法的要求和特点\n必须先声明后使用。\n\n不调用不执行，调用一次执行一次。\n\n调用时必须遵循一定的格式。\n\n方法声明的位置必须在类中，并且在方法外。\n\n\n方法的参数传递机制\n当形参的数据类型是基本数据类型时，实参给形参传递的是“数据值”，“形参”是“实参”的一个“副本”，对形参的修改不会影响实参。主方法和你所定义的方法在内存中是两个互相独立的空间，当你调用自己定义的方法执行完之后，它就会撤掉，变成垃圾准备回收了。\n\n当形参的数据类型是引用数据类型时，实参给形参传递的是“地址值”，意味着“形参”和“实参”同时指向同一个对象，那么“形参”修改了它的属性，也意味着“实参”的属性也被修改了。\n\n\n方法的重载在同一个类中，出现了两个或多个“方法名称相同”、“形参列表不同”的方法，这些方法我们称为“方法的重载”，和返回值类型无关。\n形参列表不同：个数、数据类型不同。\n构造器构造器，又称为构造方法，构造器可以在创建对象的同时，为属性初始化，或赋初始值。\n构造器的特点\n所有的类都有构造器。\n\n构造器可以重载。\n\n如果没有声明构造器，那么编译器将会自动生成一个默认的无参构造器。\n\n如果手动声明了构造器，那么编译器就不会再自动生成无参构造了，如果你还需要无参构造，那么必须自己定义。\n\n构造器的名称必须与类名相同，并且没有返回值类型，也不需要写 void。\n\n\n代码块代码块的作用：为属性初始化。\n代码块分为以下两种：\n\n静态代码块：为静态属性初始化，或者说辅助类初始化。\n\n非静态代码块：为非静态属性初始化，或者说辅助实例（对象）初始化。\n\n\n代码块执行\n静态代码块：在类初始化时执行，只执行一次。\n\n非静态代码块：在实例初始化时执行，创建一个对象，执行一次。\n\n\n类初始化每一个类，编译器会自动生成一个 clinit()，称为类初始化方法。子类初始化时，如果父类没有初始化，会先初始化父类。\n这个方法的方法体由以下两部分组成：\n\n静态变量的显式赋值语句。\n\n静态代码块中的语句。\n\n\n这两个部分，谁在上面谁先执行。\n实例初始化每一个构造器，编译器会自动生成一个对应的 init()，称为实例初始化方法。创建子类对象时，也会导致父类的实例初始化方法执行。\n这个方法的方法体由以下三部分组成：\n\n非静态变量的显式赋值语句。\n\n非静态代码块中的语句。\n\n对应构造器的语句。\n\n\n第一部分和第二部分仍然是谁在上面谁先执行，构造器永远是最后执行。\n初始化顺序父类初始化 clinit &gt;&gt;&gt; 子类初始化 clinit &gt;&gt;&gt; 父类的实例初始化 init &gt;&gt;&gt; 子类的实例初始化 init\n一开始都是静态的先初始化。\n内部类一个类的内部又完整的嵌套了另外一个类结构。被嵌套的类称为内部类，嵌套其他类的类称为外部类。内部类是类的五大成员之一，其最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。\n内部类的分类定义在外部类的局部位置上：\n\n局部内部类\n\n匿名内部类\n\n\n定义在外部类的成员位置上：\n\n成员内部类\n\n静态内部类\n\n\n局部内部类局部内部类是定义在外部类的局部位置，比如方法体、代码块中，并且有类名。\nclass OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...        class InnerClass &#123; // 局部内部类            // ...        &#125;    &#125;&#125;\n\n特点：\n\n可以直接访问外部类的所有成员，包含私有的。\n\n不能添加访问修饰符，但可以使用非访问修饰符 final 来修饰。\n\n如果外部类和局部内部类的成员重名时，默认遵循就近原则。\n\n\n作用域：\n\n仅在定义它的方法体或代码块中。\n\n成员的访问方法：\n\n局部内部类访问外部类的成员：直接访问。如果成员重名，需要用&lt;外部类类名&gt;.this.&lt;成员名&gt;去访问。\n\n只能在其作用域中访问局部内部类的成员和创建局部内部类的对象。\n\n\n匿名内部类局部内部类是定义在外部类的局部位置，比如方法体、代码块中，并且没有类名。\ninterface Product &#123; // 接口    // ...    void show();&#125;public class Main &#123;    public static void main(String[] args) &#123;        // ...        m1(new Product() &#123; // 匿名内部类            @Override            public void show() &#123;                // ...            &#125;        &#125;);    &#125;    public static void m1(Product product) &#123;        // ...        product.show();    &#125;&#125;\n\n特点：\n\n没有名字，不能有构造方法。\n\n匿名内部类可以当作实参直接传递。\n\n匿名内部类使用单独的块表示初始化块\n\n匿名内部类是与继承或实现合并在一起的没有名字的内部类。\n\n匿名内部类不利于代码的重用，一般在确定此内部类只会使用一次时，才会使用匿名内部类。\n\n\n语法格式：\nnew 实现接口() &#123;    //匿名内部类类体部分&#125;\n\nnew 父类构造器(实参列表) &#123;    //匿名内部类类体部分&#125;\n\n这两种格式分别对应两种实现，一种是接口的实现，另一种是抽象类的实现。对于实现接口，由于接口是没有构造函数的，所以实参列表一定是空的。\n成员内部类成员内部类是定义在外部类的成员位置，并且没有 static 修饰。\nclass OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...    &#125;    class InnerClass &#123; // 成员内部类        // ...    &#125;&#125;\n\n特点：\n\n可以直接访问外部类的所有成员，包含私有的。\n\n可以添加任意访问修饰符。\n\n如果外部类和成员内部类的成员重名时，默认遵循就近原则。\n\n\n作用域：\n\n和外部类的其他成员一样，为整个类体。\n\n成员的访问方法：\n\n成员内部类访问外部类的成员：直接访问。如果成员重名，需要用&lt;外部类类名&gt;.this.&lt;成员名&gt;去访问。\n\n外部类访问成员内部类的成员：先创建成员内部类对象，再访问。\n\n\n在外部其他类创建成员内部类对象的方法：\n/** * 第一种方法 */public class Main &#123;    public static void main(String[] args) &#123;        // 创建外部类对象        OuterClass outerClass = new OuterClass();        // 使用外部类对象创建一个成员内部类对象        OuterClass.InnerClass innerClass = outerClass.new InnerClass();    &#125;&#125;class OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...    &#125;    class InnerClass &#123; // 成员内部类        // ...    &#125;&#125;\n\n/** * 第二种方法 */public class Main &#123;    public static void main(String[] args) &#123;        // 创建外部类对象        OuterClass outerClass = new OuterClass();        // 调用外部类的 getInnerClass 方法获取成员内部类对象        OuterClass.InnerClass innerClass = outerClass.getInnerClass();    &#125;&#125;class OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...    &#125;    class InnerClass &#123; // 成员内部类        // ...    &#125;    public InnerClass getInnerClass() &#123;        return new InnerClass(); // 返回成员内部类对象    &#125;&#125;\n\n/** * 第三种方法 */public class Main &#123;    public static void main(String[] args) &#123;        // 创建外部类匿名对象，紧接着创建成员内部类对象，其本质和第一种方法一样，但这样更加简洁        OuterClass.InnerClass innerClass = new OuterClass().new InnerClass();    &#125;&#125;class OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...    &#125;    class InnerClass &#123; // 成员内部类        // ...    &#125;&#125;\n\n静态内部类静态内部类是定义在外部类的成员位置，并且有 static 修饰。\nclass OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...    &#125;    static class InnerClass &#123; // 静态内部类        // ...    &#125;&#125;\n\n特点：\n\n可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员。\n\n可以添加任意访问修饰符。\n\n如果外部类和静态内部类的成员重名时，静态内部类访问时，默认遵循就近原则。\n\n\n作用域：\n\n和外部类的其他成员一样，为整个类体。\n\n成员的访问方法：\n\n静态内部类访问外部类的成员：直接访问所有静态成员。如果成员重名，需要用&lt;外部类类名&gt;.&lt;静态成员名&gt;去访问。\n\n外部类访问静态内部类的成员：先创建静态内部类对象，再访问。\n\n\n在外部其他类创建静态内部类对象的方法：\n/** * 第一种方法 */public class Main &#123;    public static void main(String[] args) &#123;        // 无需创建外部类对象，直接通过 &lt;外部类类名&gt;.&lt;静态内部类类名&gt; 创建        OuterClass.InnerClass innerClass = new OuterClass.InnerClass();    &#125;&#125;class OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...    &#125;    static class InnerClass &#123; // 静态内部类        // ...    &#125;&#125;\n\n/** * 第二种方法 */public class Main &#123;    public static void main(String[] args) &#123;        // 调用外部类的 getInnerClass 静态方法获取静态内部类对象        OuterClass.InnerClass innerClass = OuterClass.getInnerClass();    &#125;&#125;class OuterClass &#123; // 外部类    // ...    public void method() &#123;        // ...    &#125;    static class InnerClass &#123; // 静态内部类        // ...    &#125;    public static InnerClass getInnerClass() &#123;        return new InnerClass(); // 返回静态内部类对象    &#125;&#125;\n","categories":["学习笔记"],"tags":["Java","面向对象"]},{"title":"Java | 集合框架","url":"/posts/c7f47f99/","content":"集合就是由若干个确定的元素所构成的整体。\n\n\n\n集合体系图List、Set 集合体系图：\n\nMap 集合体系图：\n\n单列集合Iterator 接口迭代器（Iterator）主要用来操作 Java 中的集合对象（Collection），迭代器提供了统一的语法进行集合对象遍历操作，无需关心集合对象内部的实现方式，迭代器只能向前移，无法后退。\nIterator 接口的特点：\n\nIterator 接口的对象称为迭代器，主要用于遍历 Collection 集合中的元素。\n\nIterator 接口的对象仅用于遍历集合，它本身并不存放对象。\n\n\nIterator 接口的方法：\n\n\n\n方法名称\n描述\n\n\n\nhasNext()\n判断是否还有下一个元素\n\n\nnext()\n返回下一个元素\n\n\n\n注意：在调用 next() 方法之前必须要调用 hasNext() 进行检测。若不进行检测，且下一条记录无效，直接调用 next() 会抛出 NoSuchElementException 异常。\n\nCollection 接口Collection 接口是 List、Set 和 Queue 接口的父接口，通常情况下不被直接使用。Collection 接口定义了一些通用的方法，通过这些方法可以实现对集合的基本操作。定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。\nCollection 接口的特点：\n\nCollection 的实现类可以存放多个元素，每个元素可以是 Object。\n\nCollection 的实现类，有些可以存放重复的元素，有些不可以。\n\nCollection 的实现类，有些是有序的（List），有些是无序的（Set）。\n\nCollection 接口没有直接的实现子类，是通过它的子接口 List 和 Set 来实现的。\n\n所有实现了 Collection 接口的集合类都有一个 iterator() 方法，用于返回一个迭代器。\n\n\nCollection 接口的方法：\n\n\n\n方法名称\n描述\n\n\n\nadd()\n添加单个元素\n\n\naddAll()\n添加多个元素\n\n\nremove()\n删除指定元素\n\n\nremoveAll()\n删除多个元素\n\n\ncontains()\n查找元素是否存在\n\n\ncontainsAll()\n查找多个元素是否都存在\n\n\nsize()\n获取元素个数\n\n\nisEmpty()\n判断是否为空\n\n\nclear()\n清除所有元素\n\n\nList 接口List 是一个有序、可重复的集合，集合中每个元素都有其对应的顺序索引。\nList 接口的特点：\n\nList 接口是 Collection 接口的子接口。\n\nList 集合中的元素有序（添加顺序和取出顺序一致）、且可重复。\n\nList 集合中的每个元素都有其对应的顺序索引（从 0 开始），即支持索引。\n\nList 集合中的元素都对应一个整数型的序号记载元素在集合中的位置，可以根据序号存取集合中的元素。\n\n\nList 接口的方法：\n\n\n\n方法名称\n描述\n\n\n\nget()\n获取此集合中指定索引位置的元素\n\n\nset()\n替换此集合中指定索引位置的元素\n\n\nindexOf()\n返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1\n\n\nlastIndexOf()\n返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1\n\n\nsubList()\n截取集合中的一部分形成一个新的集合并返回\n\n\nList 接口的遍历方式：\nimport java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        // 以 ArrayList 类为例，其他 List 接口的实现类同理        List list = new ArrayList();        list.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));        list.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));        list.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));        // 方式一：使用迭代器        System.out.println(&quot;========== 第一种方式 ==========&quot;);        Iterator iterator = list.iterator(); // 获取 arrayList 的迭代器        while (iterator.hasNext()) &#123;            Object book = iterator.next(); // 返回下一个元素，使用 Object 类接收            System.out.println(book);        &#125;        iterator = list.iterator(); // 重置迭代器        // 方式二：使用增强 for 循环遍历集合，其底层任然是迭代器        System.out.println(&quot;========== 第二种方式 ==========&quot;);        for (Object book : list) &#123;            System.out.println(book);        &#125;                // 方式三：使用普通 for 循环        System.out.println(&quot;========== 第三种方式 ==========&quot;);        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.println(list.get(i));        &#125;    &#125;&#125;class Book &#123;    private String name;    private String author;    private double price;    public Book(String name, String author, double price) &#123;        this.name = name;        this.author = author;        this.price = price;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getAuthor() &#123;        return author;    &#125;    public void setAuthor(String author) &#123;        this.author = author;    &#125;    public double getPrice() &#123;        return price;    &#125;    public void setPrice(double price) &#123;        this.price = price;    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nArrayList 类ArrayList 和 Vector 类的特点：\n\n两者几乎是一样的，区别在于 Vector 类是线程安全的，因此效率差于 ArrayList 类。\n\n底层都是使用 Object 类型的数组 elementData 来存储元素。\n\n底层都实现了可变长数组，可以添加任意元素且可以重复，包括 null 值。\n\n\nArrayList 和 Vector 类的扩容机制：\n\n如果使用无参构造器创建对象时，初始 elementData 容量为 0，第一次添加元素则扩容 elementData 为 10。\n\n如需再次扩容，ArrayList 类扩容为原来大小的 1.5 倍，Vector 类则是扩容为原来的 2 倍。\n\n如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小，扩容机制不变。\n\n\nLinkedList 类LinkedList 类的特点：\n\nLinkedList 类是线程不安全的。\n\n底层使用 Node（静态内部类）类型的结点来存储元素。\n\n底层有两个属性 first 和 last 分别指向头结点和尾结点。\n\n每个结点中又有三属性，prev 指向直接前驱结点，next 指向直接后继结点，item 存储真正的元素。\n\n底层实现了双向链表和双端队列，可以添加任意元素且可以重复，包括 null 值。\n\n底层采用双向链表的结构保存元素，这种结构的优点是便于向集合中插入或者删除元素。\n\n\n两者的区别ArrayList 和 LinkedList 类的区别：\n\n需要频繁修改和查询元素时，使用 ArrayList 类。\n\n需要频繁插入和删除元素时，使用 LinkedList 类。\n\nArrayList 是底层基于可变长数组，增删效率较低（扩容需要大量拷贝），改查效率较高（通过索引直接定位）。\n\nLinkedList 是底层基于双向链表，增删效率较高（元素通过指针连接），改查效率较低（查询需要依次遍历）。\n\nArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。\n\n\nSet 接口Set 是一个无序、不可重复的集合，且没有索引。\nSet 接口的特点：\n\nSet 接口是 Collection 接口的子接口。\n\nSet 集合中的元素无序（添加顺序和取出顺序不一致，但是取出顺序是固定的），且不可重复。\n\nSet 集合中的元素不按特定的方式排序，只是简单地把元素加入集合。\n\nSet 集合中不能包含重复的元素，并且只允许包含一个 null 值。\n\n\nSet 接口的方法：\n和 List 接口一样，Set 接口也是 Collection 的子接口，因此常用方法和 Collection 接口一样。\nSet 接口的遍历方式：\n和 Collection 的遍历方式一样，可以使用迭代器和增强 for 循环，但不能使用索引的方式来获取。\nHashSet 类HashSet 类的特点：\n\nHashSet 类是线程不安全的。\n\n底层使用 Node（静态内部类）类型的结点数组 table 来存储元素。\n\n底层实际上是 HashMap 类，是由数组和链表以及红黑树构成的。\n\nHashSet 类是按照 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。\n\n\nHashSet 类添加元素的底层机制：\n\n添加元素时会先计算哈希值，再将哈希值转换为索引值。\n\n找到 table 数组，查看该索引的位置是否有元素。\n\n如果没有则直接加入元素。如果有，则比较两个元素是否相同。\n\n相同就放弃添加，不相同就以链表的方式添加到尾部，形成数组加链表的模式。\n\n注意：比较两个元素是否相同是通过 equals() 方法和 hashCode() 方法的返回值来一同决定的；equals() 方法和 hashCode() 方法可以重写来修改比较的标准；只有在哈希值相同的情况下才会使用 equals() 方法进行比较。\n\n\n\nHashSet 类扩容和转成红黑树的底层机制：\n\n第一次添加元素时，table 数组扩容到 16，且临界值设为 16 * 0.75 = 12（0.75 是加载因子）。\n\n当集合中的元素个数达到临界值 12 时，table 数组就会扩容到 16 * 2 = 32。\n\n新的临界值就是 32 * 0.75 = 24，以此类推。\n\n注意：这里的扩容机制判断的是整个集合中的元素个数，并非一定是 table 数组中的元素个数。\n\n\n如果单条链表中元素达到 8，同时 table 数组的大小达到 64 时，就会进行树化（红黑树），若 table 数组大小未达到 64，则采用数组扩容机制进行扩容，直到 table 数组大小达到 64，再树化。\n\n注意：这里的扩容机制主要是为了防止单条链表上的元素过多，所以会进行扩容，加快树化的进度。\n\n\n\nLinkedHashSet 类LinkedHashSet 类的特点：\n\nLinkedHashSet 类继承了 HashSet 类。\n\n底层实际上是 LinkedHashMap 类，是由数组和双向链表构成的。\n\n底层使用 Entry（静态内部类）类型的结点来存储元素。\n\n每个结点中有 before 和 after 属性，before 指向直接前驱结点，after 指向直接后继结点。\n\n底层是根据元素的哈希值决定元素的存储位置，同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。\n\n\nLinkedHashSet 类添加元素的底层机制：\n\nLinkedHashSet 类和 HashSet 类的机制大同小异。\n\nLinkedHashSet 类在添加元素时不仅会执行 HashSet 类同样的操作，同时还会将元素加入到双向链表。\n\n\n双列集合Map 接口Map 是一种键值对（key-value）集合，Map 集合中的每一个元素都包含一个键（key）对象和一个值（value）对象。用于保存具有映射关系的数据。\nMap 接口的特点：\n\nMap 集合中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap 类中的 Node 静态内部类对象中。\n\nMap 集合中的 key 不允许重复，但 value 可以重复；key 可以有一个为 null 值，value 可以多个为 null 值。\n\nMap 集合中的 key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value。\n\n\nMap 接口的方法：\n\n\n\n方法名称\n描述\n\n\n\nput()\n添加键值对\n\n\nremove()\n根据键删除映射关系\n\n\nget()\n根据键获取值\n\n\nsize()\n获取键值对个数\n\n\nisEmpty()\n判断键值对个数是否为 0\n\n\ncontainsKey()\n查找键是否存在\n\n\nclear()\n清除所有键值对\n\n\nkeySet()\n获取所有的键\n\n\nvalues()\n获取所有的值\n\n\nentrySet()\n获取所有的键值对\n\n\nMap 接口的遍历方式：\nimport java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        Map map = new HashMap();        map.put(&quot;No.1&quot;, &quot;张浩太&quot;);        map.put(&quot;No.2&quot;, &quot;刘思诚&quot;);        map.put(&quot;No.3&quot;, &quot;王强文&quot;);        map.put(&quot;No.4&quot;, &quot;李国量&quot;);        map.put(&quot;No.5&quot;, &quot;王路路&quot;);        // 第一组：先取出所有的 key，通过 key 取出对应的 value        Set keySet = map.keySet();        // 使用增强 for 循环        System.out.println(&quot;========== 第一种方式 ==========&quot;);        for (Object key : keySet) &#123;            System.out.println(key + &quot;:&quot; + map.get(key));        &#125;        // 使用迭代器        System.out.println(&quot;========== 第二种方式 ==========&quot;);        Iterator iterator1 = keySet.iterator();        while (iterator1.hasNext()) &#123;            Object key = iterator1.next();            System.out.println(key + &quot;:&quot; + map.get(key));        &#125;        // 第二组：直接取出所有的 value        Collection values = map.values();        // 使用增强 for 循环        System.out.println(&quot;========== 第三种方式 ==========&quot;);        for (Object value : values) &#123;            System.out.println(value);        &#125;        // 使用迭代器        System.out.println(&quot;========== 第四种方式 ==========&quot;);        Iterator iterator2 = values.iterator();        while (iterator2.hasNext()) &#123;            Object value = iterator2.next();            System.out.println(value);        &#125;        // 第三组：通过 entrySet() 方法获取键值对        Set entrySet = map.entrySet();        // 使用增强 for 循环        System.out.println(&quot;========== 第五种方式 ==========&quot;);        for (Object entry : entrySet) &#123;            Map.Entry m = (Map.Entry) entry;            System.out.println(m.getKey() + &quot;:&quot; + m.getValue());        &#125;        // 使用迭代器        System.out.println(&quot;========== 第六种方式 ==========&quot;);        Iterator iterator3 = entrySet.iterator();        while (iterator3.hasNext()) &#123;            Object entry = iterator3.next();            Map.Entry m = (Map.Entry) entry;            System.out.println(m.getKey() + &quot;:&quot; + m.getValue());        &#125;    &#125;&#125;\n\nHashMap 类HashMap 类的特点：\n\nHashMap 类是线程不安全的。\n\n底层使用 Node（静态内部类）类型的结点数组 table 来存储元素。\n\n每个结点中又有四个属性，key 存放键，value 存放值，hash 存放键的哈希值，next 存放直接后继结点。\n\n\nHashMap 类添加元素的底层机制：\n\n添加元素时，通过 key 的哈希值得到在 table 数组的索引。\n\n判断该索引处是否有元素，如果没有则直接添加。\n\n如果该索引处有元素，则判断该元素的 key 是否和准备加入的元素的 key 相等。\n\n如果相等，则直接替换 value，如果不相等，则需要判断是树结构还是链表结构，做出相应的处理。\n\n如果添加时发现容量不够，则需要扩容。HashMap 类的扩容和转成红黑树的底层机制和 HashSet 类相同。\n\n\nHashtable 类Hashtable 类的特点：\n\nHashtable 类是线程安全的。\n\n底层使用 Entry（静态内部类）类型的结点数组 table 来存储元素。\n\nHashtable 类的使用方法基本上和 HashMap 类一样。\n\nHashtable 类的键和值都不能为 null，否则会抛出 NullPointerException 异常。\n\n\nHashtable 类扩容的底层机制：\n\n首次添加元素时，初始化 table 数组为 11。\n\n临界值为 table 数组的大小乘以 0.75。\n\n当集合中的元素达到临界值时，则按照原 table 数组大小的两倍再加 1 进行扩容。\n\n\nProperties 类Properties 类的特点：\n\nProperties 类继承了 Hashtable 类。\n\nProperties 类的键和值都不能为 null，否则会抛出 NullPointerException 异常。\n\n\nTreeMap 类TreeMap 类的特点：\n\n底层是由二叉树构成，实现了红黑树的结构。\n\nTreeMap 类默认会对键进行排序，所以键必须实现自然排序和定制排序中的一种。\n\n\n集合选型规则在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类的特性进行选择。\n\n先判断存储的类型：一组对象（单列）还是一组键值对（双列）。\n\n一组对象：Collection 接口\n\n允许重复的：List 接口\n\n增删操作多：LinkedList 类\n改查操作多：ArrayList 类\n\n\n不允许重复的：Set 接口\n\n无序的：HashSet 类\n可排序的：TreeSet 类\n插入和取出顺序一致的：LinkedHashSet 类\n\n\n\n\n一组键值对：Map 接口\n\n键是无序的：HashMap 类\n键是可排序的：TreeMap 类\n键的插入和取出顺序一致的：LinkedHashMap 类\n可读取文件的：Properties 类\n\n\n\nCollections 工具类Collections 类是一个操作 Set、List 和 Map 等集合的工具类。Collections 类中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作。\nCollections 工具类的常用方法：\n\n\n\n方法名称\n描述\n\n\n\nCollections.reverse()\n反转 List 集合中元素的顺序\n\n\nCollections.shuffle()\n对 List 集合中的元素进行随机排序\n\n\nCollections.sort()\n根据元素的自然顺序对指定的 List 集合中的元素按升序排序\n\n\nCollections.swap()\n将指定 List 集合中的两个元素进行交换\n\n\nCollections.frequency()\n返回指定集合中指定元素的出现次数\n\n\n","categories":["学习笔记"],"tags":["Java"]},{"title":"编程语言 | Java","url":"/posts/976385a6/","content":"\nJava | 类的五大成员\nJava | 异常处理\nJava | 常用类\nJava | 集合框架\nJava | 泛型\n\n\n\n\n","categories":["编程语言"],"tags":["Java"]},{"title":"计算机二级 | MS Office","url":"/posts/cb4ab6ca/","content":"本文记录本人考计算机二级 MS Office 等级证书的一些笔记。\n\n\n\n介绍是什么？\nNCRE 全称：全国计算机等级考试\n由教育部考试中心主办，面向社会，用于考查应试人员计算机应用知识与能力的全国性计算机水平考试体系。证书式样用中、英两种文字书写，证书编号全国统一，证书上印有持有人身份证号码和照片。该证书全国通用，终生有效，是持有人计算机应用能力的证明，是用人单位干部录用、职位晋升、职称评定的主要依据。全国报考人数约 600 万&#x2F;年。\n\n\n我要考的科目全称：计算机二级 MS office 高级应用与设计\nNCRE 考试 → 二级 → 办公软件高级应用 → MS Office 高级应用与设计\n计算机二级考试 2021 年改革，从 2021 年 3 月考次开始，MS Office 二级的考试软件由原来的 office 2010 升级为 office 2016。（鉴于 2016 版本和 2010 版本相差较大，建议大家使用 2016 版本进行备考）\n\n\n\n考什么？\n选择题（20 分）\n公共基础（10 分）\nOffice 基础（10 分）\n\n\n操作题（80 分）\nWord（30 分）\nExcel（30 分）\nPPT（20 分）\n\n\n\n怎么学？\n安装\nOffice 各版本安装教程。点击前往\n\n\n选择题\n建议大家最后（考前半个月）再复习选择题。前往笔记\n\n\nWord\n非常琐碎，知识点非常多，建议以选项卡为单位整理思维导图。前往笔记\n\n\nExcel\n表格部分分为两大板块，一是基础操作（比较简单），二是函数部分（比较难，也是我比较不擅长的部分，希望大家不要有畏难情绪，多练习多总结）。前往笔记\n\n\nPPT\n整体简单，有极少部分较生僻，建议大家加强练习，争取幻灯片满分。前往笔记\n\n\n\n笔记Word考点汇总\n加粗表示重点难点且常考\n\n\n字体考点汇总\n\n字体（中、英文字体）、字号、加粗、倾斜、字体颜色\n上下标、下划线、突出显示、字符边框、字符底纹\n文本效果、字符缩放、字符间距的加宽和缩紧\n\n\n段落常规考点汇总\n\n文档的五种对齐方式\n文档的大纲级别、文档缩进（特殊格式：首行缩进、悬挂缩进）\n段落间距（可以手动输入单位行、磅）、行距（多倍行距、固定值）\n对齐到网格线\n换行和分页（与下段同页）\n\n\n段落进阶考点汇总\n\n项目符号（设置符号、符号大小、设置图片符号）\n项目编号（自定义项目编号、调整列表缩进）\n中文版式（双行合一、调整宽度）\n段落排序（按照拼音、笔画排序、会结合大纲视图进行考核）\n边框和底纹（自定义边框、边框距正文的距离、插入横线）\n制表位（位置、对齐方式、前导符）\n多级列表（定义新多级列表、定义新列表样式）\n\n\n样式考点汇总\n\n样式的新建\n样式的修改\n样式的复制\n样式的删除\n样式的赋予\n样式集的设置\n\n\n替换考点汇总\n\n批量修改字符（手动换行符改成段落标记）\n批量删除字符（删除西文空格、全角空格、空行、索引）\n批量修改样式\n\n\n封面考点汇总\n\n系统型封面\n利用文本框自制封面\n\n\n图形考点汇总\n\n形状（形状填充、形状轮廓、形状效果、对齐方式、环绕方式）\n图片（删除背景、压缩图片、设置透明色、图片样式、裁剪图片、图片大小）\n\n\nSmartArt考点汇总\n\n插入SmartArt，添加&#x2F;删除形状\n设置SmartArt颜色和样式\n输入SmartArt文本内容并设置格式\n根据文本转换成SmartArt\n\n\n表格考点汇总\n\n插入表格、文本转换成表格\n设计选项卡（表格样式、边框底纹）\n布局选项卡（表格元素选择、属性、行列的添加与删除、合并拆分单元格、拆分表格、表格的自动调整、分布行列、对齐方式、单元格边距、表格排序、重复标题行、公式）\n表格首列自动编号、列表缩进\n\n\n图表考点汇总\n\n设计选项卡（图表样式、编辑数据、选择数据、切换行列）\n图表元素设置（坐标轴、坐标轴标题、图表标题、数据标签、数据表、误差线、网格线、图例、趋势线）\n格式选项卡\n\n\n超链接考点汇总\n\n插入超链接\n批量删除超链接\n设置超链接访问前后的颜色\n\n\n文本考点汇总\n\n文本框（系统自带、自定义文本框）\n文档部件\n首字下沉\n艺术字\n对象\n\n\n页眉页脚考点汇总\n\n统一型（下框线）\n奇偶页不同（对齐、奇偶页水印）\n分节型\nStyref域\nNumpages域\n\n\n页面设置考点汇总\n\n页边距、装订线、多页\n纸张方向、纸张大小\n页眉页脚距边界的距离、添加&#x2F;删除行号\n指定行网格\n\n\n分栏考点汇总\n\n栏数、栏间距、分隔线\n最后一页均分两栏\n分栏符\n\n\n页面背景考点汇总\n\n水印（文字水印、图片水印、奇数页水印）\n页面颜色（颜色、图片）\n页面边框（打印页面边框）\n\n\n分隔符考点汇总\n\n分页符、分栏符、自动换行符\n分节符（下一页、连续、奇数页、偶数页）\n\n\n目录考点汇总\n\n自动生成目录\n插入特定级别的目录\n设置目录格式\n批量删除目录的超链接\n\n\n脚注尾注考点汇总\n\n插入脚注、尾注\n脚注、尾注的编号格式\n脚注转换为尾注\n尾注分隔符\n\n\n多级列表考点列汇总\n\n链接到样式\n编号格式\n编号对齐方式和位置\n正规形式编号\n编号之后的分隔符号\n\n\n\n引用选项卡\n目录功能区\n平时都习惯说“插入目录”，其实目录在“引用”不在“插入”，目录的本质是各个标题。\n一般使用“自动目录”和“自定义目录”，一般常考“自定义目录”。\n大纲级别：文章中肉眼可见明明是标题但格式是正文，我们可以选中文字设置大纲级别。\n\n\n\nExcelPPT选择题建议\n不建议大家直接刷题库\n这是最大的误区，如果连知识点都没弄明白，就直接题海战术，其实备考效率是非常低的。\n\n\n备考顺序\n先操作题后选择题，操作题占80分，选择题占20分，操作题才是复习的重点。\n\n\n刷真题策略\n先看题目自己想思路，然后看视频记住操作步骤，最后自己动手练习，遇到不会的再去看视频，切记不可边看视频边刷题。\n\n\n选择题备考策略\n考前15天左右开始复习。选择题大多数是记忆性内容，过早复习容易遗忘。\n\n\n考试做题策略\n先整体看一下抽到的题目，先易后难，合理分配时间。\n\n\n\n叨叨计算机二级证书其实是一个很基础的证书，含金量的确不高。但如果不设置这样的考试，我相信大部分同学很难自觉去学习办公软件的，那工作以后处理文档表格就会效率很低，所以学习计算机还是很有必要的。\n不一定要考证，但是一定要学，学好技能，顺带考证\n","categories":["证书考试"],"tags":["计算机二级","MS Office"]},{"title":"证书考试 | 软件设计师","url":"/posts/3d3a7fb3/","content":"\n软件设计师 | 计算机系统\n软件设计师 | 程序设计语言\n软件设计师 | 数据流图\n软件设计师 | 知识产权\n软件设计师 | 数据库\n软件设计师 | 面向对象\n软件设计师 | UML\n软件设计师 | 设计模式\n软件设计师 | 操作系统\n软件设计师 | 结构化开发\n软件设计师 | 软件工程\n软件设计师 | 计算机网络\n软件设计师 | 数据结构（待更新）\n软件设计师 | 算法（待更新）\n\n\n\n\n考试介绍软考即计算机技术与软件专业技术资格（水平）考试，是由国家人事部和信息产业部领导下的国家级考试，其目的是，科学、公正地对全国计算机与软件专业技术人员进行职业资格、专业技术资格认定和专业技术水平测试。\n\n从整个方向来看，可以分为五个方向的考试。像计算机软件方向，网络方向，计算机应用技术，信息系统，信息服务，把软考划分了五个方向这样的一个考试。而这五个方面中又划分了初中高这三个级别。\n软件设计师考试的前身是高级程序员考试。软件设计师考试考的是广度。\n推荐视频zst_2001 制作的软件设计师学习路线\n考试大纲\n掌握计算机内的数据表示、算术和逻辑运算方法；\n掌握相关的应用数学及离散数学基础知识；\n掌握计算机体系结构以及各主要部件的性能和基本工作原理；\n掌握操作系统、程序设计语言的基础知识，了解编译程序的基本知识；；\n热练掌握常用数据结构和常用算法；\n熟悉数据库、网络和多媒体的基础知识；\n掌握 C 程序设计语言，以及 C++、Java 中的一种程序设计语言；\n熟悉软件工程、软件过程改进和软件开发项目管理的基础知识；\n掌握软件设计的方法和技术；\n了解信息化、常用信息技术标准、安全性，以及有关法律、法规的基础知识；\n正确阅读和理解计算机领域的英文资料；\n\n考试形式考试一共分两科，上午考科目一下午考科目二，每一科分数为 75 分，合格分数线为 45 分。\n\n科目一：计算机与软件工程知识（150 分钟，笔试，选择题）\n75 个选择题，每空一分。\n\n\n科目二：软件设计（150 分钟，笔试，问答题）\n一共有六个大题，每一个大题 15 分，试题五和试题六是选答。\n试题一：结构化开发方法 – DFD 数据流图\n试题二：数据库 – E-R 图\n试题三：软件工程 – UML 图（类图+其他图）\n试题四：C 语言 – 算法分析与设计\n试题五、六：C++/Java 语言 – 二十三种设计模式（代码填空）\n\n\n\n分值分布\n计算机与软件工程知识\n\n软件设计\n\n\n","categories":["证书考试"],"tags":["软考","软件设计师"]},{"title":"软件设计师 | UML","url":"/posts/da952he3/","content":"UML 即统一建模语言，是面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言；UML 作为一种模型语言，它使开发人员专注于建立产品的模型和结构，而不是选用什么程序语言和算法实现。\n\n\n\nUML 概述UML 描述了一个系统的静态结构和动态行为。\nUML 由 3 个要素构成：UML 的基本构造块、支配这些构造块如何放置在一起的规则和运用与整个语言的一些公共机制。\nUML 的词汇表包含 3 种构造块：事物、关系和图。事物是对模型中最具有代表性的成分的抽象；关系把事物结合在一起；图聚集了相关的事物。\nUML 事物UML 中有 4 种事物：结构事物、行为事物、分组事物和注释事物。\n结构事物结构事物是 UML 模型中的名词。它们通常是模型的静态部分，描述概念或物理元素。\n\n类：具有相同的属性、相同的方法、和相同关系的一组对象的集合。\n接口：指类或组件所提供的、可以完成特定功能的一组操作的集合（接口描述类或组件对外的、可见的动作）。\n协作：定义了交互的操作，是一些角色和其他元素一起工作，提供一些合作的动作。\n用例：定义系统执行的一组操作，对特定的用户产生可以观察的结果。\n活动类：对拥有线程并可发起控制活动的对象。\n构件：构件是系统中物理的、可替代的部件，它遵循且提供一组接口的实现。\n结点：是一个物理元素，在运行时存在，代表一个可计算的资源（如数据库服务器）。\n\n行为事物行为事物是 UML 模型的动态部分。它们是模型中的动词，描述了跨越时间和空间的行为。行为事物包括交互（Interaction）、状态机（State Machine）和活动（Activity）。在 UML 中交互的消息通常画成带箭头的直线，状态机是对象的一个或多个状态的集合。\n\n交互：在特定语境中共同完成一定特定任务的一组对象之间交换的消息组成。\n状态机：描述了一个对象或一个交互在生命期内响应事件所经历的状态序列。\n活动：是描述计算机过程执行的步骤序列，注重步骤之间的流而不关心哪个对象执行哪个步骤。\n\n分组事物分组事物是 UML 模型的组织部分，是一些由模型分解成的“盒子”。在所有的分组事物中，最主要的分组事物是包（Package）。\n\n包：包是把元素组织成组的机制，这种机制具有多种用途。结构事物、行为事物甚至其他分组事物都可以放进包内。\n\n注释事物注释事物是 UML 模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素。注解（Note）是一种主要的注释事物。\n\n注解：是一个依附于一个元素或一组元素之上，对它进行约束或解释的简单符号。\n\nUML 关系UML 中有 4 中关系：依赖、关联、泛化和实现。\n类关系涉及依赖、关联、聚合、组合和泛化这五种关系，耦合度依次递增。关于耦合度，可以简单地理解为当一个类发生变更时，对其他类造成的影响程度，影响越小则耦合度越弱，影响越大耦合度越强。\n依赖依赖是两个事物间的语义关系，其中一个事物（独立事物）发生变化会影响另一个事物（依赖事物）的语义。对于两个对象 X、Y，如果对象 X 发生变化，可能会引起对另一对象 Y 的变化，则称 Y 依赖于 X。\n依赖关系用一条带箭头的虚线表示，如下图所示：\n\n学生在学习生活中经常使用电脑，于是对电脑产生了依赖。依赖关系是五种关系中耦合最小的一种关系。类 A 要完成某个功能引用了类 B，则类 A 依赖类 B。依赖在代码中主要体现为类 A 的某个成员函数的返回值、形参、局部变量或静态方法的调用，则表示类 A 引用了类 B。\n关联关联是一种结构关系，它描述了一组链，链是对象之间的连接。\n关联关系使用实线加箭头表示，如下图所示：\n\n类之间的关系比依赖要强。学生与老师是关联的，学生可以不用电脑，但是学生不能没有老师。\n关联与依赖的对比：\n\n相似之处：\n关联暗示了依赖，二者都用来表示无法用聚合和组合表示的关系。\n\n\n区别：\n发生依赖关系的两个类都不会增加属性。其中的一个类作为另一个类的方法的参数或者返回值，或者是某个方法的变量而已。\n发生关联关系的两个类，类 A 成为类 B 的属性，而属性是一种更为紧密的耦合，更为长久的持有关系。\n从关系的生命周期来看，依赖关系是仅当类的方法被调用时而产生，伴随着方法的结束而结束。关联关系当类实例化的时候产生，当类对象销毁的时候关系结束。相比依赖，关联关系的生存期更长。\n\n\n\n关联关系有单向关联、双向关联、自身关联、多维关联等等。其中后三个可以不加箭头。\n单向关联：\n\n双向关联：\n\n自身关联：\n\n多维关联：\n\n聚集是一种特殊类型的关联，它描述了整体和部分间的结构关系。聚集又分为聚合和组合。\n聚合聚合关系使用实线加空心菱形表示。聚合用来表示集体与个体之间的关联关系。\n例如班级与学生之间存在聚合关系，类图表示如下：\n\n组合组合（又叫复合）关系使用实线加实心菱形表示，用来表示个体与组成部分之间的关联关系。\n例如学生与心脏之间存在复合关系，类图表示如下：\n\n聚合与组合的对比：\n\n聚合关系没有组合紧密。\n学生不会因为班级的解散而无法存在，聚合关系的类具有不同的生命周期。\n而学生如果没有心脏将无法存活，组合关系的类具有相同的生命周期。\n聚合类的构造函数中包含另一个类的实例作为参数，因为构造函数中传递另一个类的实例，因此学生可以脱离班级体独立存在。\n组合类的构造函数包含另一个类的实例化。因为在构造函数中进行实例化，因此两者紧密耦合在一起，同生同灭，学生不能脱离心脏而存在。\n\n\n信息的封装性不同。\n在聚合关系中，客户端可以同时了解 Classes 类和 Student 类，因为他们是独立的。\n在组合关系中，客户端只认识 Student 类，根本不知道 Heart 类的存在，因为心脏类被严密地封装在学生类中。\n\n\n\n理解聚合与组合的区别，主要在于聚合的成员可独立，组合的成员必须依赖于整体才有意义。\n泛化泛化是一种特殊/一般关系，特殊元素（子元素）的对象可替代一般元素（父元素）的对象。用这种方法，子元素共享了父元素的结构和行为。在图形上，把一个泛化关系画成一条带有空心箭头的实线，它指向父元素。\n泛化是学术名称，通俗来讲，泛化指的是类与类之间的继承关系和类与接口之间的实现关系。\n继承关系使用直线加空心三角形表示。类图结构如下：\n\n实现实现是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。在两种情况下会使用实现关系：一种是在接口和实现它们的类或构件之间；另一种是在用例和实现它们的协作之间。在图形上，把一个实现关系画成一条带有空心箭头的虚线。\n类接口的实现关系使用虚线加空心三角形表示。类图结构如下：\n\nUML 中的图静态建模：类图、对象图、用例图。\n动态建模：序列图（顺序图，时序图），通信图（协作图），状态图，活动图。\n物理建模：构件图（组件图）、部署图。\n\n交互图包含：序列图（顺序图，时序图）、通信图（协作图）。\n类图类图展现了一组对象、接口、协作和它们之间的关系。\n类图组成元素：类、接口、协作、依赖、泛化和关联关系。\n\n当对系统的静态设计视图建模时，通常以下述 3 种方式之一使用类图：\n\n对系统的词汇建模\n对简单的协作建模\n对逻辑数据库模式建模\n\n对象图对象图展现了某一时刻一组对象以及它们之间的关系，描述了类图中所建立的事物的实例的静态快照。\n对象图组成元素：对象和链。\n\n用例图用例图展现了一组用例（使用案例）、参与者以及它们之间的关系。\n用例图组成元素：用例、参与者、用例之间的扩展关系和包含关系，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系。\n\n\n\n当对系统的静态用例视图建模时，可以用下列两种方式来使用用例图：\n\n对系统的语境建模\n对系统的需求建模\n\n序列图序列图，又名顺序图、时序图。用于描述对象之间的传递消息的时间顺序（包括发送消息、接收消息、处理消息、返回消息等）。\n序列图组成元素：对象、生命线、消息。其中消息又分为同步消息（调用消息）、异步消息、返回消息、自关联消息。\n对象可以在交互过程中创建，它们的生命线从接收到构造型为 create 的消息时开始。对象也可以在交互过程中撤销，它们的生命线在接收到构造型为 destroy 的消息时结束（并且给出一个大 X 的标记表明生命的结束）。\n\n序列图有两个不同于通信图的特性：\n\n序列图有对象生命线。对象的生命线是一条垂直的虚线，表示一个对象在一段时间内存在。\n序列图有控制焦点。控制焦点是一个瘦高的矩形，表示一个对象执行一个动作所经历的时间段。\n\n通信图通信图，又名协作图。用于强调收发消息的对象的结构组织。通信图强调参加交互的对象的组织。\n通信图描述的是对象和对象之间的调用关系，体现的是一种组织关系。\n通信图组成元素：对象、链、消息。连接对象的链表示为图的弧。\n通信图和时序图有点类似。但时序图着重于时间顺序，而通信图则关注的是对象之间的组织关系，通信图中的时间顺序可以从消息序号中获得。在语义上这两个图是等价的可以互相转换而不会丢失信息。\n\n通信图有两个不同于序列图的特性：\n\n通信图有路径。为了指出一个对象如何与另一个对象链接。\n通信图有顺序号。为了表示一个消息的时间顺序。\n\n状态图状态图展现了一个状态机，它由状态、转换、事件和活动组成。状态图通常是对反应型对象建模。\n状态图主要用于描述对象具有的各种状态、状态之间的转换过程以及触发状态转换的各种事件和条件。\n状态图通常包括简单状态和组合状态、转换（事件和动作）。\n\n状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式，状态主要有初态、终态和中间状态。\n事件是在某个特定时刻发生的事情，它是对引起系统做动作或（和）从一个状态转换到另一个状态的外界事件的抽象。\n转换包含源状态和目标状态以及触发事件、监护条件和动作。\n活动（动作）可以在状态内执行，也可以在状态转换（迁移）时执行。\n\n活动图活动图是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。活动图专注于系统的动态视图，它对于系统的功能建模特别重要，并强调对象间的控制流程。\n活动图一般包括活动状态和动作状态、转换和对象。活动图可以表示分支、合并、分岔和汇合。\n\n当对一个系统的动态方面建模时，通常有两种使用活动图的方式：\n\n对工作流建模\n对操作建模\n\n构件图构件图，又称组件图，展现了一组构件（组件）之间的组织和依赖。构件图专注于系统的静态实现视图。它与类图相关，通常把构件映射为一个或多个类、接口或协作。\n\n部署图部署图是用来对面向对象系统的物理方面建模的方法，展现了运行时处理结点以及其中构件（制品）的配置。部署图对系统的静态部署视图进行建模，它与构件图相关。通常，一个结点是一个在运行时存在并代表一项计算资源的物理元素，至少拥有一些内容，常常具有处理能力，包含一个或多个构件。\n部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。部署图通常是在开发过程中的实现（实施）阶段准备的。\n\nUML 杂题选讲https://www.bilibili.com/video/BV1a44y1K7HH?p=77\n","categories":["证书考试"],"tags":["软考","软件设计师","UML"]},{"title":"软件设计师 | 操作系统","url":"/posts/eb3d0f85/","content":"计算机系统由硬件和软件两部分组成。通常把未配置软件的计算机称为裸机。直接使用裸机不仅不方便，而且将严重降低工作效率和机器的利用率。操作系统（Operating System）目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。\n\n\n\n操作系统在计算机系统中的地位：\n\n进程管理进程管理也称处理机管理。在多道程序批处理系统和分时系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了进程。进程是资源分配和独立运行的基本单位。进程管理重点需要研究诸进程之间的并发特性，以及进程之间相互合作与资源竞争产生的问题。\n程序与进程程序顺序执行的特征前趋图是一个有向无循环图，由结点和有向边组成，结点代表各程序段的操作，而结点间的有向边表示两个程序段操作之间存在的前趋关系。\n例如，下图三个程序段，其中输入是计算的前驱（计算是输入的后继），输入结束才能进行计算；计算是输出的前驱，计算结束才能进行输出。\n\n序顺序执行时的主要特征包括顺序性、封闭性和可再现性。\n程序并发执行的特征若在计算机系统中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。对于上述有 3 个程序段的作业类，虽然每个作业有前趋关系的各程序段不能在 CPU 和输入/输出各部件并行执行，但是同一个作业内没有前超关系的程序段或不同作业的程序段可以分别在 CPU 和各输入/输出部件上并行执行。\n下图为三个作业的各程序段并发执行的前驱图，从图中可以看出， 与  并行执行；、 与  并行执行； 与  并行执行。\n\n程序并发执行时的特征如下：\n\n失去了程序的封闭性。\n程序和机器的执行程序的活动不再一一对应。\n并发程序间的相互制约性。\n\n进程的状态三态模型在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化，因此进程一般有 3 种基本状态：运行、就绪和阻塞。下图显示了进程基本状态及其转换，也称三态模型。\n\n\n运行：当一个进程在处理机上运行时，则称该进程处于运行状态。显然，对于单处理机系统，处于运行状态的进程只有一个。\n就绪：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。\n阻塞：阻塞也称等待或睡眠状态，一个进程正在等待某一事件发生（例如请求 I/O 等待 I/O 完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。\n\n五态模型事实上，对于一个实际的系统，进程的状态及其转换更复杂。例如，引入新建态和终止态构成了进程的五态模型，如下图所示：\n\n其中，新建态对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息。因为创建进程时分为两个阶段，第一个阶段为一个新进程创建必要的管理信息，第二个阶段让该进程进入就绪状态。由于有了新建态操作系统，往往可以根据系统的性能和主存容量的限制推退新建态进程的提交。\n进程中的通信在多道程序环境的系统中存在多个可以并发执行的进程，故进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。\n同步与互斥同步是合作进程间的直接制约问题，互斥是申请临界资源进程间的间接制约问题。\n\n进程间的同步\n 在计算机系统中，多个进程可以并发执行，每个进程都以各自独立的、不可预知的速度向前推进，但是需要在某些确定点上协调相互合作进程间的工作。例如，进程 A 向缓冲区送数据，进程 B 从缓冲区取数据加工，当进程 B 要取数据加工时，必须是进程 A 完成了向缓冲区送数据的操作，否则进程 B 必须停下来等待进程 A 的操作结束。\n 可见，所谓进程间的同步是指在系统中一些需要相互合作，协同工作的进程，这样的相互联系称为进程的同步。\n\n进程间的互斥\n 进程的互斥是指系统中多个进程因争用临界资源而互斥执行。在多道程序系统环境中，各进程可以共享各类资源，但有些资源一次只能供一个进程使用，称为临界资源（Critical Resource，CR），如打印机、共享变量和表格等。\n\n临界区管理的原则\n 临界区（Critical Section，CS）是进程中对临界资源实施操作的那段程序。\n\n对互斥临界区管理的 4 条原则如下\n\n有空即进：当无进程处于临界区时，允许进程进入临界区，并且只能在临界区运行有限的时间。\n无空则等：当有一个进程在临界区时，其他欲进入临界区的进程必须等待，以保证进程互斥地访问临界资源。\n有限等待：对于要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免陷入“机饿”状态。\n让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等状态。\n\n\n\n信号量机制信号量机制主要有整型信号量、记录型信号量和信号量集机制。\n整型信号量与 PV 操作：\n信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为如下两类：\n\n公用信号量：实现进程间的互斥，初值为 1 或资源的数目。\n私用信号量：实现进程间的同步，初值为 0 或某个正整数。\n\n信号量 S 的物理意义：S &gt;= 0 表示某资源的可用数，若 S &lt; 0，则其绝对值表示阻塞队列中等待该资源的进程数。\n对于系统中的每个进程，其工作的正确与否不仅取决于它自身的正确性，而且与它在执行中能否与其他相关进程正确地实施同步互异有关。PV 操作是实现进程同步与互斥的常用方法。P 操作和 V 操作是低级通信原语，在执行期间不可分割。其中，P 操作表示申请一个资源，V 操作表示释放一个资源。\n\nP 操作的定义：S = S - 1，若 S &gt;= 0，则执行 P 操作的进程继续执行；若 S &lt; 0，则置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列。\n\nV 操作的定义：S = S + 1，若 S &gt; 0，则执行 V 操作的进程继续执行；若 S &lt;= 0，则从阻塞状态唤醒一个进程，并将其插入就络队列，然后执行 V 操作的进程继续。\n\n\n利用 PV 操作实现进程的互斥：\n令信号量 mutex 的初值为 1，当进入临界区时执行 P 操作，退出临界区时执行 V 操作。\n利用 PV 操作实现进程的同步：\n进程的同步是由于进程间合作引起的相互制约的问题，要实现进程的同步可用一个信号量与消息联系起来，当信号量的值为 0 时表示希望的消息未产生，当信号量的值为非 0 时表示希望的消息已经存在。假定用信号量 S 表示某条消息，进程可以通过调用 P 操作测试消息是否到达，调用 V 操作通知消息已准备好。最典型的同步问题是单缓冲区的生产者和消费者的同步问题。\n死锁在计算机系统中有许多互斥资源（如磁带机、打印机和绘图仪等）或软件资源（如进程表、临界区等），若两个进程同时使用打印机，或同时进入临界区必然会出现问题。所谓死锁，是指两个以上的进程互相都要求对方已经占有的资源导致无法继续运行下去的现象。\n当有 n 个进程、m 个资源、且每个进程所需要的资源数为 k，并且系统采用的分配策略是轮流地为每个进程分配资源时，判断是否会发生死锁的公式如下：\n（）\n为真就不会发生死锁、为假就会发生死锁。\n死锁的处理死锁的处理策略主要有4种：驼鸟策略（即不理联策略）、预防策略、避免策略和检测与解除死锁。\n死锁预防是设法破坏产生死锁的 4 个必要条件之一，严格防止死锁的产生。死锁避免则不那么严格地限制产生死锁的必要条件。最著名的死锁避免算法是 Dijkstra 提出的银行家算法死锁避免算法需要很大的系统开销。\n银行家算法对于进程发出的每一个系统可以满足的资源请求命令加以检测，如果发现分配资源后系统进入不安全状态，则不予分配；若分配资源后系统仍处于安全状态，则实施分配。与死锁预防策略相比，它提高了资源的利用率，但检测分配资源后系统是否安全增加了系统开销。\n所谓安全状态，是指系统能按某种顺序如  来为每个进程分配其所需资源，直到最大需求，使每个进程都可顺序完成。通常称  序列为安全序列。若系统不存在这样一个安全序列，则称系统处于不安全状态。\n线程传统的进程有两个基本属性：可拥有资源的独立单位；可独立调度和分配的基本单位。引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高。引入线程后，将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。\n例如，在文件服务进程中可设置多个服务线程，当一个线程受阻时，第二个线程可以继续运行，当第二个线程受阻时，第三个线程可以继续运行……从而显著地提高了文件系统的服务质量及系统的吞吐量。\n这样，对于拥有资源的基本单位，不用频繁地切换，进一步提高了系统中各程序的并发程度。需要说明的是，线程是进程中的一个实体，是被系统独立分配和调度的基本单位。线程基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈），它可与同属一个进程的其他线程共享进程所拥有的全部资源。\n存储管理局部性原理程序的局限性表现在时间局限性和空间局限性两个方面。\n时间局限性是指如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。产生时间局限性的典型原因是在程序中存在着大量的循环操作。\n空间局限性是指一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为程序是顺序执行的。\n设备管理磁盘调度算法常用的磁盘调度算法如下：\n\n先来先服务（FCFS）\n 按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置。\n\n最短寻道时间优先（SSTF）\n 让离当前磁道最近的请求访问者启动磁盘驱动器，即让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁头移动过大的问题。\n\n扫描算法（SCAN）或电梯调度算法\n 总是从磁头当前位置开始，沿磁头的移动方向去选择离当前磁头最近的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。\n\n单向扫描调度算法（CSCAN）或循环扫描算法\n 循环扫描调度算法是在扫描算法的基础上改进的。为了减少延迟，规定磁头单向移动，例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。\n\n\n文件管理文件目录为了实现“按名存取”，系统必须为每个文件设置用于描述和控制文件的数据结构，它至少要包括文件名和存放文件的物理地址，这个数据结构称为文件控制块（FCB），文件控制块的有序集合称为文件目录。换句话说，文件目录是由文件控制块组成的，专门用于文件的检索。文件控制块也称为文件的说明或文件目录项（简称目录项）。\n文件控制块文件控制块中包含以下三类信息：基本信息类、存取控制信息类和使用信息类。\n\n基本信息类：例如文件名、文件的物理地址、文件长度和文件块数等。\n存取控制信息类：文件的存取权限，像 UNIX 用户分成文件主、同组用户和般用户三类，这三类用户的读/写执行 RWX 权限。\n使用信息类：文件建立日期、最后一次修改日期、最后一次访问的日期、当前使用的信息（如打开文件的进程数、在文件上的等待队列）等。\n\n目录结构文件目录结构的组织方式直接影响到文件的存取速度，关系到文件的共享性和安全性，因此组织好文件的目录是设计文件系统的重要环节。常见的目录结构有 3 种：一级目录结构、二级目录结构和多级目录结构。\n多级目录结构为了解决以上问题，在多道程序设计系统中常采用多级目录结构，这种目录结构像一棵倒置的有根树，所以也称为树型目录结构。从树根向下，每一个结点是一个目录，叶结点是文件。MS-DOS 和 UNIX 等操作系统均采用多级目录结构。\n在采用多级目录结构的文件系统中，用户要访问一个文件，必须指出文件所在的路径名，路径名是从根目录开始到该文件的通路上所有各级目录名拼起来得到的。在各目录名之间、目录名与文件名之间需要用分隔符隔开。例如，在 MS-DOS 中分隔符为“\\”，在 UNIX 中分隔符为“/”。\n绝对路径名（Absolute Path Name）是指从根目录“/”开始的完整文件名，即它是由从根目录开始的所有目录名以及文件名构成的。\n","categories":["证书考试"],"tags":["软考","软件设计师","操作系统"]},{"title":"软件设计师 | 数据库","url":"/posts/a1f6b007/","content":"数据与信息之间的关系可以表示为：信息 = 数据 + 数据处理。\n\n\n\n概念数据模型概念数据模型常用术语\n实体：客观存在并可以相互区别的事物称为实体。\n属性：描述实体的特性称为属性，一个实体可以由若干个属性来刻画。属性的具体取值称为属性值，用以表示一个具体实体。\n码：唯一标识实体的属性集称为码。\n域：属性的取值范围称为该属性的域。\n实体型：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。\n实体集：同型实体的集合称为实体集。\n联系：实体（型）之间的对应关系称为联系。\n\n实体之间的联系\n一对一联系：指实体集 A 中的一个实体最多只与实体集 B 中的一个实体相联系。如班和班长之间是一对一联系。\n一对多联系：表示实体集 A 中的一个实体可与实体集 B 中的多个实体相联系。如班和学生之间是一对多联系。\n多对多联系：表示实体集 A 中的多个实体可与实体集 B 中的多个实体相联系。如课程和学生之间是多对多联系。\n\nE-R 图E-R 图是抽象和描述现实世界的有力工具，它提供了表示实体型、属性和联系的方法。\n\n实体型用矩形表示，矩形框内写明实体名。\n属性用椭圆形表示，并用无向边将其相应的实体连接起来。\n联系用菱形表示，菱形框内写明联系名，并用无向边将其分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n 或 m:n）。如果一个联系具有属性，这些属性也要用无向边与该联系连接起来。\n\n\n三级模式和两级映像\n\n三级模式\n外模式（用户模式或子模式）：视图\n概念模式（模式）：基本表\n内模式（存储模式）：存储文件\n\n\n两级映像\n模式/内模式映像：概念模式和内模式之间的相互转换。保证数据的物理独立性。\n外模式/模式映像：外模式和概念模式之间的相互转换。保证数据的逻辑独立性。\n\n\n\n关系数据模型关系模型基本概念关系模型是一种用二维表格结构来表示实体以及实体之间联系的数据模型。每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述。因此可以说，关系模型是由关系模式组成的集合。\n两个关系模式：\n\n\n教师（教师编号，姓名，性别，所在系名）\n课程（课程号，课程名，任课教师编号，上课教室）\n\n两个关系模式的关系：\n\n两个关系均包含两个元组。教师关系的教师编号为主码，课程关系的课程号为主码。\n关系模型基本术语\n关系（表）：一个关系就是一张二维表，每个关系有一个关系名（表名）。\n元组（行）：表中的一行即为一个元组，对应存储文件中的一个记录值。\n属性（列）：表中的列称为属性，每一列有一个属性名。属性值相当于记录中的数据项或字段值。\n域（取值范围）：属性的取值范围，即不同元组对同一个属性的值所限定的范围。\n关系模式（表结构、表头）：对关系的描述称为关系模式，由关系名和其属性集合构成。\n候选码：属性或属性组合，其值能够唯一地标识一个元组。\n主码：在一个关系中可能有多个候选码，从中选择一个作为主码。\n主属性与非主属性：包含在任何候选码中的属性称为主属性。不包含在任何候选码中的属性为非主属性。\n外码：如果一个关系中的一个属性是另外一个关系中的主码，则该属性为外码。\n全码：若关系中只有一个候选码，且这个候选码中包含全部属性，则该候选码为全码。\n超码：一个包含主码的属性集称为超码。\n\n关系完整性约束\n实体完整性：关系中主码的值不能为空或部分为空，也就是说，主码中的属性即主属性不能取空值。\n参照完整性：又称引用完整性，如果关系  的外码  与关系  的主码相对应（ 和  可以是同一个关系），则外码  的每个值必须在关系  中主码的值中找到，或者为空值。\n用户定义完整性：指用户对某一具体数据指定的约束条件进行检验。\n\n关系代数关系代数运算符：\n\n集合运算符\n关系的并：关系  和关系  的所有元组合并，再删去重复的元组，组成一个新的关系，称为  和  的并，记为 。\n关系的交：关系  和关系  的交是由即属于  又属于  的元组组成的集合，即在两个关系  和  中取相同的元组，组成一个新的关系，记为 。\n关系的差：关系  和关系  的差是由属于  而不属于  的所有元组组成的集合，即关系  中删去与关系  中相同的元组，组成一个新的关系，记为 。\n笛卡尔积：两个关系  和  的笛卡尔积记为 。\n\n关系运算符投影运算从关系的垂直方向进行运算，在关系  中选取若干属性列 ，并用这些属性组成一个新的关系，记作 。例如：\n\n选择运算从关系的水平方向进行运算，从关系  中选出满足给定条件  的元组而组成的一个新的关系，记作 。例如：\n计算机\n连接运算从两个关系  和  的笛卡尔积中选取满足条件的元组。因此，可以认为笛卡尔积是无条件的连接，其他连接认为是有条件连接。连接运算主要有一下几种：\n\n 连接： 是比较运算符。\n \n\n等值连接：是  连接的特例，与  连接一致，是当  为  时的情况。\n \n\n自然连接：自然连接是除去重复属性的等值连接，它要求两个关系中进行比较的分量必须是相同的属性或属性组，并且在连接结果中去掉重复的属性列，使公共属性列只保留一个。\n\n外连接：如果希望不满足连接条件的元组也出现在连接结果中，则可以通过外连接操作实现。外连接有三种形式：左外连接、右外连接、全外连接。含义是将指定一边（如左连接就是左边的关系）中不满足的元组也保留到连接后的结果中，并在结果中将另一关系各属性置为空（NULL）值。\n\n\nSQL 语句分类SOL 语言按照用途可以分为如下 4 类：\n\nDDL（Data Definition Language，数据定义语言）：在数据库系统中，每一个数据库、数据库中的表、视图和索引等都是数据库对象。要建立和删除一个数据库对象，都可以通过 SOL 语言来完成。DDL 包括 CREATE、ALTER 和 DROP 等。\nDML（Data Manipulation Language，数据操纵语言）：DML 是指用来添加、修改和删除数据库中数据的语句，包括 INSERT（插入）、DELETE（删除）和 UPDATE（更新）等。\nDQL（Data Query Language，数据查询语言）：查询是数据库的基本功能，查询操作通过 SOL 数据查询语言来实现，例如，用 SELECT 查询表中的内容。\nDCL（Data Control Language，数据控制语言）：DCL 包括数据库对象的权限管理和事务管理等。\n\n数据库规范化关系模式关系的描述称为关系模式，它可以形式化地表示为：\n（，，，）\n其中  为关系名， 为组成该关系的属性名集合， 为属性组  中属性所来自的域， 为属性到域的映射， 为属性组  上的一组数据依赖。\n函数依赖设  是一个属性集  上的关系模式， 和  是  的子集。\n若对于  的任意两个可能的关系 r1、r2，若 r1[x] 等于 r2[x]，则 r1[y] 等于 r2[y]，或者若 r1[y] 不等于 r2[y]，则 r1[x] 不等于 r2[x]，称  决定 ，或者  依赖 。\n比如在设计学生表时，一个学生的学号能决定学生的姓名，也可称姓名属性依赖于学号，对于现实来说，就是如果知道一个学生的学号，就一定能知道学生的姓名，这种情况就是姓名依赖于学号，这就是函数依赖，函数依赖又分为非平凡依赖，平凡依赖；从性质上还可以分为完全函数依赖、部分函数依赖和传递函数依赖。\n\n数据依赖\n 在计算机科学中，数据依赖是指一种状态，当程序结构导致数据引用之前处理过的数据时的状态。其中最重要的是函数依赖和多值依赖。\n\n函数依赖\n 设  是关系  的两个属性集合，当任何时刻  中的任意两个元组中的  属性值相同时，则它们的  属性值也相同，则称  函数决定 ，或  函数依赖于 ， 记作 。\n\n平凡函数依赖\n 当关系中属性集合  是属性集合  的子集时 ，存在函数依赖  ，即一组属性函数决定它的所有子集，这种函数依赖称为平凡函数依赖。\n\n非平凡函数依赖\n 当关系中属性集合  不是属性集合  的子集时 ，存在函数依赖 ，则称这种函数依赖为非平凡函数依赖。\n\n完全函数依赖\n 设  是关系  的两个属性集合， 是  的真子集，存在 ，但对每一个  都有  不能函数决定 ，则称  完全函数依赖于 。\n\n部分函数依赖\n 设  是关系  的两个属性集合，存在 ，若  是  的真子集，存在 ，则称  部分函数依赖于 。\n\n传递函数依赖\n 设  是关系  中互不相同的属性集合，存在 ，，，则称  传递函数依赖于 。\n\n\n设关系模式 ，其中  为属性集， 是  上的一组函数依赖，那么有以下推理规则。\n\n合并规则：若 ，，则  为  所蕴涵。\n伪传递率：若 ，，则  为  所蕴涵。\n分解规则：若 ，，则  为  所蕴涵。\n\n规范化范式规范化是指用形式更为简洁、结构更加规范的关系模式取代原有关系模式的过程。数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入、删除、和更新操作异常。\n在对数据库进行一些操作的时候我们可能会遇到以下的一些问题：\n\n数据冗余：想修改一个属性，就要更新多行数据。\n插入异常：想要插入数据，结构因为表设计的问题，导致不能成功插入。\n删除异常：只想删除其中的某些数据 ，结果把不该删的也删了。\n更新异常：想更新一条数据，结果工作量大，还容易出错。\n\n目前主要有 6 种范式，按规范化程度从低到高可分为：1NF、2NF、3NF、BCNF、4NF、5NF。各种范式之间存在的关系：1NF ⊃ 2NF ⊃ 3NF ⊃ BCNF ⊃ 4NF ⊃ 5NF。\n\n第一范式（1NF）\n 若关系模式  的每一个分量是不可再分的数据项（每个属性都是不可再分的），则关系模式  属于第一范式。1NF 不能排除数据冗余和更新异常（包括修改，删除，插入异常），因为其中可能存在部分函数依赖。\n\n第二范式（2NF）\n 不存在非主属性对主属性的部分函数依赖（每个主属性都完全函数依赖于候选码）。2NF 也可能存在数据冗余和更新异常等问题，因为其中可能存在传递函数依赖。\n\n第三范式（3NF）\n 不存在非主属性对主属性的传递函数依赖（每个非主属性都非传递依赖于候选码）。3NF 中数据冗余和更新异常没有完全解决，因为可能存在主属性对候选码的部分依赖和传递依赖。\n\nBC 范式（BCNF）\n\n所有非主属性对每一个候选码都是完全函数依赖。\n所有的主属性对每一个不包含它的候选码，也是完全函数依赖。\n没有任何属性完全函数依赖于非候选码码的任何一组属性。\n\n 一个满足 BCNF 范式的关系模式已消除了插入和删除异常。\n\n\n关系模式分解对存在数据元余、插入异常、删除异常问题的关系模式，应采取将一个关系模式分解为多个关系模式的方法进行处理，相应地，原来存储在一个二维表内的数据就要分散到多个二维表中，要使这个分解有意义，起码的要求是后者不能去失前者的信息。\n在分解处理中会涉及一些新问题，为使分解后的模式保持原模式所满足的特性，其基本要求是模式分解具有无损连接性和保持函数依赖性。\n\n无损连接：对关系模式分解时，原关系模式下任一合法的关系实例在分解之后应能通过自然连接运算恢复起来。反之，则称为有损分解。\n保持函数依赖：对关系模式分解时，原关系的闭包与分解后关系闭包的并集相等。\n\n数据库杂题选讲https://www.bilibili.com/video/BV1LZ4y1k7ma?p=145\n","categories":["证书考试"],"tags":["软考","软件设计师","数据库"]},{"title":"软件设计师 | 数据流图","url":"/posts/a58493dd/","content":"数据流图也称数据流程图（DFD），它从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。\n\n\n\n数据流图基本图形元素数据流图中的基本图形元素包括数据流（Data Flow）、加工（Process，一般用 P 表示）、数据存储（Data Store，一般用 D 表示）和外部实体（External Agent，一般用 E 表示）。\n\n数据流数据流由一组固定成分的数据组成，表示数据的流向，数据流的起点或终点必须有一个是加工。在 DFD 中，数据流的流向可以有以下几种：\n\n从一个加工流向另一个加工。\n从加工流向数据存储（写）。\n从数据存储流向加工（读）。\n从外部实体流向加工（输入）。\n从加工流向外部实体（输出）。\n\n加工\n加工：将输入数据处理后得到输出数据，一个加工至少有一个输入数据流和一个输出数据流。\n加工只有输入没有输出称为：黑洞。\n加工只有输出没有输入称为：白洞。\n加工的输入数据不足以产生输出数据：灰洞。\n\n\n\n数据存储\n数据存储：存储数据和提供数据，即存储加工的输出数据和提供加工的输入数据。\n例如：客户表、订单表、学生表、巴士列表文件、维修记录文件、课表文件……\n\n\n\n外部实体\n外部实体：当前系统之外的人、物、外部系统。\n人：学生、老师、员工、主管、医生、客户、供应商……\n物：传感器、控制器、单车、车辆、采购部门……\n外部系统：支付系统、车辆交易系统、库存管理系统、道闸控制系统……\n\n\n\n三大设计原则这三大设计原则是解题的法宝。\n父图子图平衡原则模型分解时必须保持父图的输入输出数据流和子图输入输出数据流相同。\n数据守恒原则对不论什么一个加工来说，其全部输出数据流中的数据必须能从该加工的输入数据流中直接获得。\n\n外部实体与外部实体之间不存在数据流。\n外部实体与数据存储之间不存在数据流。\n数据存储与数据存储之间不存在数据流。\n\n守恒加工原则对同一个加工来说，输入与输出的名字必须不同样。即使它们的组成成分同样。\n\n对于数据流图的任意一个加工，必须既有输入数据流，又有输出数据流。\n数据流与加工有关，且必须经过加工。\n输入与输出一样，加工没有作用，违反了数据守恒原则。\n仅仅有输入，没有输出，违反了数据守恒原则。\n仅仅有输出，没有输入，违反了数据守恒原则。\n\n\n\n","categories":["证书考试"],"tags":["软考","软件设计师","数据流图"]},{"title":"软件设计师 | 数据结构（待更新）","url":"/posts/3ce0bce2/","content":"待更新\n\n\n\n复杂度时间复杂度空间复杂度顺序存储链式存储线性结构树形结构图形结构排序冒泡排序选择排序插入排序希尔排序归并排序快速排序计数排序基数排序堆排序查找顺序查找二分查找","categories":["证书考试"],"tags":["软考","软件设计师","数据结构"]},{"title":"软件设计师 | 知识产权","url":"/posts/d47f972e/","content":"知识产权也称为智慧财产权。\n\n\n\n知识产权的特点\n地域性\n各国主管机关依照本国法律授予的知识产权，只能在其本国领域内受法律保护。\n外国人在我国领域外使用中国专利局授权的发明专利，不侵犯我国专利权。\n\n\n时间性\n知识产权具有法定的保护期限，一旦保护期限届满，权力将自动终止，成为社会公众可以自由使用的知识。\n发明专利的保护期限为 20 年。\n实用新型专利权和外观设计专利的期限为 10 年。\n作品发表权的保护期为作者终身及其死亡后 50 年。\n商标权的保护期限自核准注册之日起 10 年内有效，期限届满前 6 个月内可以申请续展注册。\n商业秘密受法律保护的期限是不确定的。\n\n\n\n计算机软件著作权计算机软件著作权受到《中华人民共和国著作权法》和《计算机软件保护条例》这两个法律的保护。计算机软件著作权的权利自软件开发完成之日起产生，保护期为 50 年。\n计算机软件著作权的主体是指享有著作权的人。著作权法保护的计算机软件是指计算机程序（源程序和目标程序）及其有关文档（程序设计说明书、流程图、用户手册）。\n职务软件作品职务软件作品是指公民在单位任职期间为执行本单位工作任务所开发的计算机软件作品。开发者只有署名权。\n公民在单位任职期间所开发的软件，如果是执行本职工作的结果，即针对本职工作中明确指定的开发目标所开发的，或者是从事本职工作活动所预见的结果或自然的结果，则改软件的著作权属于该单位。\n当公民作为某单位的雇员时，如其开发的软件属于执行本职工作的结果，该软件著作权应当归单位享有。若开发的软件不是执行本职工作的结果，其著作权就不属单位享有。如果该雇员主要使用了单位的设备，不能属于该雇员个人享有。\n委托开发委托开发的软件作品属于著作权法规定的委托软件作品。委托开发软件作品著作权关系的建立，一般由委托方与受委托方订立合同而成立。\n接受他人委托开发的软件，其著作权的归属由委托者与受委托者签订书面合同约定。无书面合同或者合同未作明确约定的，其著作权由受托人享有。\n著作权侵权行为\n未经软件著作权人的同意而发表或者登记其软件作品。\n将他人开发的软件当作自己的作品发表或者登记。\n未经合作者的同意将与他人合作开发的软件当作自己独立完成的作品发表或者登记。\n在他人开发的软件上署名或者更改他人开发的软件上的署名。\n未经软件著作权人或者其合法受让者的许可，修改、翻译其软件作品。\n未经软件著作权人或其合法受让者的许可，复制或部分复制其软件作品。\n未经软件著作权人及其合法受让者同意，向公众发行、出租其软件的复制品。\n\n知识产权杂题选讲https://www.bilibili.com/video/BV1Qr4y167cX/?p=61\n","categories":["证书考试"],"tags":["软考","软件设计师","知识产权"]},{"title":"软件设计师 | 程序设计语言","url":"/posts/2103f0c6/","content":"语言之间的翻译形式有多种，基本方式为汇编、解释和编译。用某种高级语言或汇编语言编写的程序称为源程序，源程序不能直接在计算机上执行。\n\n\n\n编译、解释程序解释程序也称为解释器，它或者直接解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行；编译程序（编译器）则是将源程序翻译成目标语言程序，然后在计算机上运行目标程序。\n这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序（或其某种等价表示）要参与到程序的运行过程中，运行程序的控制权在解释程序。简单来说，在解释方式下，翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。\n解释器翻译源程序时不生成独立的目标程序。\n解释程序和源程序要参与到程序的运行过程中。\n编译器翻译时将源程序翻译成独立保存的目标程序。\n机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的运行过程。\n编译、解释过程编译方式：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成。\n解释方式：词法分析、语法分析、语义分析。\n编译器和解释器都不可省略词法分析、语法分析、语义分析，且顺序不可交换。\n编译器方式中，中间代码生成和代码优化不是必要，可省略，即编译器方式可以在词法分析、语法分析、语义分析阶段后直接生成目标代码。\n\n编译过程概述编译程序的功能是把某高级语言书写的源程序翻译成与之等价的日标程序（汇编语言或机器语言）。\n关于词法、语法、语义：\n\n词法：什么样的词是有效的。\n雪是 White：词法错误，White 不是有效的中文词。词法正确才能进行语法分析。\n\n\n语法：有效的词进行排列组合，什么样的排列组合才是有效的。\n雪白的是：词法正确，语法错误。雪、白的、是，都是有效的中文词，但是词的排列组合错误。\n\n\n语义：描述的内容是否正确。\n雪是红的：词法正确，语法正确，语义错误，描述的内容错误。\n\n\n\n词法分析源程序可以简单地被看成是一个多行的字符串。词法分析阶段是编译过程的第一个阶段，这个阶段的任务是对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号。“单词”符号是程序设计语言的基本语法单位，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。\n输入源程序，输出记号流。词法分析阶段的主要作用是分析构成程序的字符及又字符按照构造规则构成的符号是否符合程序语言的规定。\n语法分析语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如“表达式”“语句”和“程序”等。语法规则就是各类语法单位的构成规则。通过语法分析确定整个输入串是否构成一个语法上正确的程序。如果源程序中没有语法错误，语法分析后就能正确地构造出其语法树；否则指出语法错误，并给出相应的诊断信息。\n输入记号流，输出语法树（分析树）。语法分析阶段的主要作用是对各条语句的结构进行合法性分析，分析程序中的句子结构是否正确。语法分析阶段可以发现程序中的所有语法错误。\n语义分析语义分析阶段分析各语法结构的含义，检查源程序是否包含静态语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能翻译成正确的目标代码。语义分析的一个主要工作是进行类型分析和检查。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。例如，整除取余运算符只能对整型数据进行运算，若其运算对象中有浮点数就认为是类型不匹配的错误。\n输入语法树（分析树）。语义分析阶段的主要作用是进行类型分析和检查。语义分析阶段只能发现静态语义错误，不能发现动态语义错误。动态语义错误运行时才能发现。\n有语义错误是可以编译成功的，例如 a/0 这是符合语法的，也符合静态语义，编译器检验不出来这个是错的，只有运行才会报错，也就是动态语义，动态语义错误常见的有死循环。\n中间代码生成中间代码生成阶段的工作是根据语义分析的输出生成中间代码。“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。最常用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。\n常见的中间代码有：后缀式、三地址码、三元式、四元式和树（图）等形式。中间代码与具体的机器无关（不依赖具体的机器）。因为与具体的机器无关，使用中间代码有利于进行与机器无关的优化处理和提高编译程序的可移植性。可以将不同的高级程序语言翻译成同一种中间代码。中间代码可以跨平台。\n目标代码生成目标代码生成阶段的工作与具体的机器密切相关。寄存器的分配工作处于目标代码生成阶段。\n符号表管理符号表的作用是记录源程序中各个符号的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。符号表的建立可以始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码的运行阶段。\n词法分析工具正规式和正规集| 表示或， * 表示可以出现 0 次或者 n 次， (……) 表示一个整体。\n\n有限自动机有限自动机（有穷自动机）是一种识别装置的抽象概念，它能准确地识别正规集（通过正规式推到正规集）。有限自动机分为两类：确定的有限自动机和不确定的有限自动机。\n\n确定的有限自动机（DFA）：对每一个状态来说识别字符后转移的状态是唯一的。\n不确定的有限自动机（NFA）：对每一个状态来说识别字符后转移的状态是不唯一的。\n\n状态转换图表示法如下：\n\n其中 start 指向的表示初始状态（初始态或初态），箭头上面的表示输入，有向边（箭头）就是变化，圆圈内表示状态，圆圈内嵌套一个圆圈（例如状态 3）表示结束状态（结束态或终态），在这种状态下就不接受输入了。\n对于确定的有限自动机，一个输入决定的状态转移只可能有一个状态，这一点从根本上与不确定的有限自动机相区别。从上面的状态转换表我们能看到，对应的一个状态，和一个输入，可能有多种状态转移，比如状态 0 遇到 a 的时候既可能转移到状态 1，也有可能保持状态 0 不变。这种就是不确定有限自动机。\n\n上图中的  符号是表示空，意思是不用识别直转移状态。\n串能否识别成功的依据是路跑的通并且跑完后的终点是终态。\n上下文无关文法下面这个是一个上下文无关文法的一个例子，称为 ：\n\n上下文无关文法（CFG, Context-free Grammar）是由一系列产生式组成，每个产生式是由被一个箭头分成左右两个部分。左边的符号被称为非终结符，一般用大写字母表示。右边是一个字符串，包括非终结符和被称为终结符的其他符号组成，终结符可以是小写字母、数字和特殊符号组成。第一个产生式左边的非终结符被成为起始符。例如  有三个产生式， 和  是非终结符，并且  是起始符， 的终止符为 、 和 。\n上下文无关文法的形式化定义如下：\n\n上下文无关文法是一个四元组 ，其中\n 是非终结符的有限集。\n 是终结符的有限集。\n 是产生式的有限集，每个产生式是由非终结符和非终结符、终结符的字符串组成。\n 是起始符，。\n\n\n\n使用文法产生一个具体的语句的过程被称为推导，推导的过程就是不断挑选文法中的产生式将起始符的右边替换成只有终结符的字符串为止。例如，使用  产生字符串  的推导如下：\n\n这里安利一个非常好用的工具，可戳 cfg-grammar-tool，能够根据 CFG 文法推到句子和判断句子是否可以被推导。\n上下文无关文法之所以是“上下文无关”的，那是因为该文法中每个产生式的左边只有唯一符号（即非终结符）。每个产生式左边的非终结符可以自由地被替换成右边的字符串，而不管这个非终结符出现的位置（所处的上下文）。例如：\n\n这个就是一个上下文无关文法。而下面的例子则不是：\n\n这是个上下文相关文法，它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的  的时候必需确保  所处的“上下文”，即其左边的  和右边的 ，所以是上下文相关文法。\n在 CFG 中可能存在多个产生式的左边非终结符相同，可以将这样的产生式合并简化。例如：\n\n可以简化为：\n\n或者：\n\n中缀和后缀表达式什么是中缀表达式和后缀表达式（逆波兰表达式）：\n\n中缀表达式是最常用的算术表达式形式，运算符在运算数中间，但运算时需要考虑运算符优先级。\n例如：1 + 2 * 3\n\n\n​后缀表达式是计算机容易运算的表达式，运算符在运算数后面，从左到右进行运算无需考虑优先级，运算呈线性结构。\n例如：1 2 3 * +\n\n\n\n将中缀表达式 1 - 2 * (3 + 4) / 5 转为后缀表达式：\n\n首先判断中缀表达式中运算符的优先级。\n括号优先级最高，所以将括号中的 a?b 格式转为 ab? 得到 34+。\n1 - 2 * 34+ / 5\n\n\n优先级次高的是除号，将 34+ 看作一个整体与 / 5 进行转换得到 34+5/。\n1 - 2 * 34+5/\n\n\n按照上面的方式依次转换。\n1 - 234+5/*\n\n\n最后得到后缀表达式。\n1234+5/*-\n\n\n\n将后缀表达式 1234+5/*- 转为中缀表达式：\n\n首先从左往右数，直到遇到运算符。\n将第一个遇到的运算符以及右边的两位数进行转换得到 3 + 4。\n12 3 + 4 5/*-\n\n\n然后接着向右数，直到遇到的二个运算符，将 3 + 4 看作一个整体与 5/ 进行转换得到 (3 + 4) / 5。\n12 (3 + 4) / 5 *-\n\n\n按照上面的方式依次转换。\n1 2 * (3 + 4) / 5 -\n\n\n最后得到中缀表达式。\n1 - 2 * (3 + 4) / 5\n\n\n\n语法树遍历语法树也就是一个二叉树，二叉树的中根遍历结果就是中缀表达式的结果，后根遍历就是后缀表达式的结果。\n\n遍历方法\n中根遍历（第二次访问的结点）：左子树 —&gt; 根结点 —&gt; 右子树\n后根遍历（第三次访问的结点）：左子树 —&gt; 右子树 —&gt; 根结点\n\n\n\n程序设计语言杂题选讲https://www.bilibili.com/video/BV1tL411c7gi?p=131\n","categories":["证书考试"],"tags":["软考","软件设计师","程序设计语言"]},{"title":"软件设计师 | 算法（待更新）","url":"/posts/404c980a/","content":"待更新\n\n\n\n回溯法分治法贪心法动态规划法","categories":["证书考试"],"tags":["软考","软件设计师","算法"]},{"title":"软件设计师 | 结构化开发","url":"/posts/b68dcfb1/","content":"结构化方法由结构化分析、结构化设计、结构化程序设计构成，它是一种面向数据流的开发方法。\n\n\n\n模块化模块在程序中是数据说明、可执行语句等程序对象的集合，或者是单独命名和编址的元素，例如高级语言中的过程、函数和子程序等。在软件的体系结构中，模块是可组合、分解和更换的单元。\n模块化是指将一个待开发的软件分解成若干个小的简单部分，每个模块可独立地开发、测试，最后组装成完整的程序。这是一种复杂问题“分而治之”的原则。模块化的目的是使程序的结构清晰，容易阅读、理解、测试和修改。\n模块独立模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系简单。衡量模块独立程度的标准有两个：耦合性和内聚性。\n耦合性和内聚性是模块独立性的两个定性标准，在将软件系统划分模块时，应尽量做到高内聚、低耦合，提高模块的独立性。\n耦合耦合是模块之间的相对独立性（互相连接的紧密程度）的度量。耦合取决于各个模块之间接口的复杂程度、调用模块的方式以及通过接口的信息类型等。一般模块之间可能的耦合方式有 7 种类型，如下图所示。\n\n\n无直接耦合：指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何信息。因此，模块间耦合性最弱，模块独立性最高。\n\n数据耦合：指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递。\n\n标记耦合：指两个模块之间传递的是数据结构。\n\n控制耦合：指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择地执行模块内的某一功能。因此，被调用模块应具有多个功能，哪个功能起作用受调用模块控制。\n\n外部耦合：模块间通过软件之外的环境联结（如 I&#x2F;O 将模块耦合到特定的设备、格式、通信协议上）时称为外部耦合。\n\n公共耦合：指通过一个公共数据环境相互作用的那些模块间的耦合。\n\n内容耦合：当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时，这种模块之间的耦合称为内容耦合。\n\n\n内聚内聚是对一个模块内部各个元素彼此结合的紧密程度的度量。一个内聚程度高的模块（在理想情况下）应当只做一件事。一般模块的内聚性分为 7 种类型，如下图所示。\n\n\n偶然内聚：也称巧合内聚，指一个模块内的各处理元素之间没有任何联系。\n\n逻辑内聚：指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。\n\n时间内聚：把需要同时执行的动作组合在一起形成的模块称为时间内聚模块。\n\n过程内聚：指一个模块完成多个任务，这些任务必须按指定的过程执行。\n\n通信内聚：指模块内的所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或者产生相同的输出数据。\n\n顺序内聚：指一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入。\n\n功能内聚：这是最强的内聚，指模块内的所有元素共同作用完成一个功能，缺一不可。\n\n\n设计原则为保证总体结构设计顺利完成，应遵循以下几条原则。\n\n分解-协调原则。整个系统是一个整体，具有整体目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。\n\n自顶向下的原则。首先抓住系统总的功能目的，然后逐层分解，即先确定上层模块的功能，再确定下层模块的功能\n\n信息隐蔽、抽象的原则。上层模块只规定下层模块做什么和所属模块间的协调关系但不规定怎么做，以保证各模块的相对独立性和内部结构的合理性，使得模块与模块之间层次分明，易于理解、实施和维护。\n\n一致性原则。要保证整个软件设计过程中具有统一的规范、统一的标准和统一的文件模式等。\n\n明确性原则。每个模块必须功能明确、接口明确，消除多重功能和无用接口。\n\n模块之间的耦合尽可能小，模块的内聚度尽可能高。\n\n模块的扇入系数和扇出系数要合理。一个模块直接调用其他模块的个数称为模块的扇出系数；反之，一个模块被其他模块调用时，直接调用它的模块个数称为模块的扇入系数。模块的扇入、扇出系数必须适当。经验表明，一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7，否则会引起出错概率的增大。但菜单调用型模块的扇入与扇出系数可以大一些，公用模块的扇入系数可以大一些。\n\n模块的规模适当。过大的模块常常使系统分解得不充分，其内部可能包含了若干部分的功能，因此有必要进一步把原有的模块分解成若干功能尽可能单一的模块。但分解也必须适度，因为过小的模块有可能降低模块的独立性，造成系统接口的复杂性。\n\n模块的作用范围应该在其控制范围之内。\n\n\n系统文档信息系统的文档是系统建设过程的“痕迹”，是系统维护人员的指南，是开发人员与用户交流的工具。规范的文档意味着系统是按照工程化开发的，意味着信息系统的质量有了形式上的保障。文档的欠缺、文档的随意性和文档的不规范，极有可能导致原来的开发人员流动以后，系统不可维护、不可升级，变成了一个没有扩展性、没有生命力的系统。\n对文档在系统开发人员、项目管理人员、系统维护人员、系统评价人员以及用户之间的多种作用总结如下。\n\n用户与系统分析人员在系统规划和系统分析阶段通过文档进行沟通。这里的文档主要包括可行性研究报告、总体规划报告、系统开发合同和系统方案说明书等。有了文档，用户就能依次对系统分析师是否正确理解了系统的需求进行评价，如不正确，可以在已有文档的基础上进行修正。\n\n系统开发人员与项目管理人员通过文档在项目期内进行沟通。这里的文档主要有系统开发计划（包括工作任务分解表、PERT 图、甘特图和预算分配表等）、系统开发月报以及系统开发总结报告等项目管理文件。有了这些文档，不同阶段之间的开发人员就可以进行工作的顺利交接，同时还能降低因为人员流动带来的风险，因为接替人员可以根据文档理解前面人员的设计思路或开发思路。\n\n系统测试人员与系统开发人员通过文档进行沟通。系统测试人员可以根据系统方案说明书、系统开发合同、系统设计说明书和测试计划等文档对系统开发人员所开发的系统进行测试。系统测试人员再将评估结果撰写成系统测试报告。\n\n系统开发人员与用户在系统运行期间进行沟通。用户通过系统开发人员撰写的文档运行系统。这里的文档主要是用户手册和操作指南。\n\n系统开发人员与系统维护人员通过文档进行沟通。这里的文档主要有系统设计说明书和系统开发总结报告。有的开发总结报告写得很详细，分为研制报告、技术报告和技术手册 3 个文档，其中的技术手册记录了系统开发过程中的各种主要技术细节。这样，即使系统维护人员不是原来的开发人员，也可以在这些文档的基础上进行系统的维护与升级。\n\n用户与维修人员在运行维护期间进行沟通。用户在使用信息系统的过程中，将运行过程中的问题进行记载，形成系统运行报告和维护修改建议。系统维护人员根据维护修改建议以及系统开发人员留下的技术手册等文档对系统进行维护和升级。\n\n\n数据字典数据流图描述了系统的分解，但没有对图中各成分进行说明。数据字典就是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明。其中，对加工的描述称为“小说明”，也可以称为“加工逻辑说明”。\n数据字典的内容数据字典有以下 4 类条目：数据流、数据项、数据存储和基本加工。数据项是组成数据流和数据存储的最小元素。源点、终点不在系统之内，故一般不在字典中说明。\n数据词典管理词典管理主要是把词典条目按照某种格式组织后存储在词典中，并提供排序、查找和统计等功能。如果数据流条目包含了来源和去向，文件条目包含了读文件和写文件，还可以检查数据词典与数据流图的一致性。\n加工逻辑的描述加工逻辑也称为“小说明”。常用的加工逻辑描述方法有结构化语言、判定表和判定树 3 种。\n结构化语言通常可分为内层和外层。外层有严格的语法，内层的语法比较灵活，可以接近于自然语言的描述。外层用来描述控制结构，采用顺序、选择和重复 3 种基本结构。\n","categories":["证书考试"],"tags":["软考","软件设计师","结构化开发"]},{"title":"软件设计师 | 计算机系统","url":"/posts/b64e77a6/","content":"计算机系统是由硬件和软件组成的，计算机的基本硬件系统由运算器、控制器、存储器、输入设备和输出设备五大部件组成。运算器、控制器等部件被集成在一起统称为中央处理单元。\n\n\n\n中央处理单元中央处理单元（CPU）是计算机系统的核心部件，它负责获取程序指令、对指令进行译码并加以执行。CPU 是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。此外 CPU 还需要对系统内部和外部的中断（异常）做出响应，进行相应的处理。\n运算器\n功能\n\n数据处理：CPU 通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。所以，对数据的加工处理也是 CPU 最根本的任务。\n算术运算：加、减、乘、除等基本运算。\n逻辑运算：进行逻辑测试，例如与、或、非、零值测试或两个值的比较等。\n\n\n组成\n\n算术逻辑单元（ALU）：负责处理数据，实现对数据的算术运算和逻辑运算。\n累加寄存器（AC）：简称为累加器，它是一个通用寄存器。功能是为 ALU 提供一个工作区。运算结果是放在累加器中的，运算器中至少要有一个累加寄存器。\n数据缓冲寄存器（DR）：暂时存放由内存储器读/写的一条指令或一个数据字。作为 CPU 的内存、外部设备之间数据传送的中转站。\n状态条件寄存器（PSW）：保存当前指令执行完成之后的状态，通常一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。\n\n\n\n控制器\n功能\n\n程序控制：CPU 通过执行指令来控制程序的执行顺序。\n操作控制：一条指令功能的实现需要若干操作信号配合来完成，CPU 产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。\n时间控制：CPU 对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。\n\n\n组成\n\n指令寄存器（IR）：存放的是从内存中取得指令，就像个中间站一样，不过是存放指令的中间站。\n程序计数器（PC）：又称为指令计数器，存放的是指令的地址，还有计数的功能。大多数指令都是按顺序来执行的，修改指令地址过程是对 PC 加 1。\n地址寄存器（AR）：存放的是 CPU 访问内存单元的地址。\n指令译码器（ID）：是把操作码解析成对应的指令操作。指令等于操作码加地址码。\n\n\n\n计算机基本单位\n\n\n中文名称\n英文名称\n缩写\n换算\n\n\n\n位（比特）\nbit\nb\n8bit = 1B\n\n\n字节\nbyte\nB\n1B = 8bit\n\n\n千字节\nKbytes\nKB\n1KB = 1024B\n\n\n兆字节\nMbytes\nMB\n1MB = 1024KB\n\n\n吉字节\nGbytes\nGB\n1GB = 1024MB\n\n\n太字节\nTbytes\nTB\n1TB = 1024GB\n\n\n最小的数据单位：bit(b)最小的存储单位：byte(B)\n进制的转换\n十进制（D）：0 ~ 9\n二进制（B）：0 ~ 1\n八进制（O）：0 ~ 7\n十六进制（H）：0 ~ 9、A ~ E\n\nR 进制转十进制 进制（任意进制）转十进制使用按权展开法，其具体操作方式为：将  进制数的每一位数值用  形式表示，即幂的底数是 ，指数为 ， 与该位和小数点之间的距离有关，当该位位于小数点左边， 值是该位和小数点之间数码的个数，而当该位位于小数点右边， 值是负值，其绝对值是该位和小数点之间数码的个数加 1（小数点左边从 0 开始数，右边从 -1 开始数）。\n例如：\n\n二进制转十进制：\n七进制转十进制：\n\n十进制转 R 进制十进制转  进制（任意进制）使用短除法，也叫除  取余法， 代表你要转换为  进制中的 。\n二进制转八进制与十六进制二进制转八进制，每三个二进制位对应一个八进制位（以小数点为分界点，小数点左边的往左分段，不足三位补零，小数点右边的往右分段，不足三位补零），二进制转十六进制同理，每四个二进制位对应一个十六进制位。需要注意的是十六进制中的 10 ~ 15 使用 A ~ E 表示。\n二进制与八进制编码对应表：\n\n\n\n二进制\n八进制\n\n\n\n000\n0\n\n\n001\n1\n\n\n010\n2\n\n\n011\n3\n\n\n100\n4\n\n\n101\n5\n\n\n110\n6\n\n\n111\n7\n\n\n八进制与十六进制转二进制八进制转二进制，每一个八进制位对应三个二进制位。十六进制转二进制，每一个十六进制位对应四个二进制位。\n八进制与十六进制相互转换八进制转十六进制，将八进制转换为二进制，然后再将二进制转换为十六进制，小数点位置不变。十六进制转八进制则相反，但原理一样，都需要先转换为二进制。\n进制加减法\n加法：逢  进 1\n减法：借 1 当 \n\n特别注意无论是进 1 还是借 1 都要看是多少进制，二进制就满 2 进 1，借的那个 1 当 2 用，八进制满 8 进 1，借的那个 1 当 8 用，十六进制就满 16 进 1，借的那个 1 当 16 用。\n原码反码补码移码首先将一个数（下面用 1 做演示）转化为二进制的表达形式，二进制的首位（最左边的一位）代表符号位，正数的符号位是 0，负数的符号位是 1，符号位不参与进制转换。\n\n\n\n码制\n数值 1\n数值 -1\n1 加上 -1\n结果\n\n\n\n源码\n0000 0001\n1000 0001\n1000 0010\n-2\n\n\n反码\n0000 0001\n1111 1110\n1111 1111\n-0\n\n\n补码\n0000 0001\n1111 1111\n0000 0000\n0\n\n\n移码\n1000 0001\n0111 1111\n1000 0000\n0\n\n\n可以看到 1 和 -1 的源码相加得到的源码并不是 0 的源码而是 -2 的源码，所以像源码的这种操作方式是不能直接在机器中做相关的运算的，所以有了其他的编码方式。\n取值范围：\n\n\n\n码制\n整数\n字长 \n\n\n\n源码\n\n\n\n\n反码\n\n\n\n\n补码\n\n\n\n\n移码\n\n\n\n\n可以看到最下面一行，补码比反码、源码取值范围要多一位，原因是源码和反码中的 +0 和 -0 是两个不同的编码，而补码不是，补码的 +0 和 -0 的编码是一样的，所以要少占用一个编码。\n知识点:\n\n原码：正数是其二进制本身；负数是符号位为 1，数值部分取X绝对值的二进制。\n反码：正数的反码和原码相同；负数是符号位为 1，其它位是原码取反。\n补码：正数的补码和原码、反码相同；负数是符号位为 1，其它位是原码取反，未位加 1（或者说负数的补码是其绝对值反码未位加 1。注意 1+1 进 1）。\n移码：将符号位取反的补码（不区分正负）。\n\n浮点数运算一个二进制数  可以表示为更一般的形式 ，其中  为阶码， 为尾数。用阶码和尾数表示的数称为浮点数，这种表示数的方法称为浮点表示法。\n在浮点表示法中，阶码为带符号的纯整数，尾数为带符号的纯小数。浮点数的表示格式如下：\n\n阶码不一致先对阶，小阶向大阶对齐，尾数右移。\n浮点数所能表示的数值范围由阶码  决定，所表示数值的精度由尾数  决定。\n当机器字长为  时，补码和移码可表示  个数（0 的表示有相同的编码），原码和反码只能表示  个数（0 的表示占了两个编码）。\n如果浮点数的阶码（包括 1 位阶符）用  位的移码表示，尾数（包括 1 位数符）用  位的补码表示，则这种浮点数所能表示的数值范围如下：\n\n最大的正数：\n最小的负数：\n\n定点表示法中，小数点不需要占用存储位。\n寻址\n寻址方式\n\n立即寻址：操作数就包含在指令中。\n直接寻址：操作数存放在内存单元中，指令中直接给出操作数所在存储单元的地址。\n寄存器寻址：操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名。\n寄存器间接寻址：操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中。\n间接寻址：指令中给出操作数地址的地址。\n相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。\n变址寻址：操作数地址等于变址寄存器的内容加偏移量。\n\n\n寻址方式的速度排序\n\n立即寻址 &gt; 寄存器寻址 &gt; 直接寻址 &gt; 寄存器间接寻址 &gt; 间接寻址。\n\n\n采用不同寻址方式的目的是为了扩大寻址空间并提高编程灵活性。\n\n存储系统的层次结构\n\n\n\n校验码码距：一个编码方案中任意两个合法编码之间至少有多少个数据位（码字）不同。（意思是一个合法编码需要改变几个码字才能得到另外一个合法编码，这几个码字个数就是码距）。例如 4 位 8421 码的码距为 1，在传输过程中，该代码的一位或多位发生错误，都将变成另外一个合法的编码，因此这种代码无检错能力。\n码距等于 2 时有检错能力，码距大于等于 3 才可能有纠错能力。也就是一个校验码要想能够检错和纠错那么它的码距至少是 3。\n奇偶校验码对于奇偶校验，它可以检测代码奇数位出错（出错个数为奇数）的编码，但不能发现偶数位出错（出错个数为偶数）的情况。\n奇偶校验：码距为 2，仅能检测出奇数位错误，不能纠错。\n奇校验：增加一位校验码（码距加 1），使得编码中 1 的个数为奇数。\n偶校验：增加一位校验码（码距加 1），使得编码中 1 的个数为偶数。\n常用的奇偶校验码有 3 种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。\n海明校验码海明码的构成方法是在数据位之间的特定位置上插入  个校验位，通过扩大码距来实现检错和纠错。\n设数据位是  位，校验位是  位，则  和  必须满足以下关系：\n\n循环冗余校验码 个数据位后跟  个校验位，编码长度为 ，码距为 2 可以检错但不能纠错。\n采用模 2 运算得到校验码。\nRISC 和 CISCRISC 精简指令集（Reduced Instruction Set Computer）\nCISC 复杂指令集（Complex Instruction Set Computer）\n\n流水线\n概念\n子过程：重复的指令分解为若干个子过程，每个子过程与其他子过程并行进行。\n操作周期：执行指令中用时最长的子过程的执行时间为流水线的操作周期。\n\n\n流水线执行时间计算公式\n理论公式为：一条完整指令的时间操作周期\n实践公式为：子过程数操作周期操作周期\n\n\n\n吞吐率流水线的吞吐率  是指单位时间（固定时间）内所完成的任务数量或输出的结果数量。计算公式如下：\n指令条数流水线执行时间\n如果流水线的子过程所用时间不一样，则吞吐率  应为最长子过程的倒数。计算公式如下：\n操作周期\n加速比完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。计算流水线加速比的基本公式如下：\n不使用流水线所用的时间使用流水线所用的时间\n存储器虚拟存储器由主存和辅存两级存储器组成。\n局部性原理\n时间局部性：是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行，如果某数据被访问，则不久之后该数据可能再次被访问。\n空间局部性：是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。\n\n存储器的分类按所处的位置分类按存储器所处的位置可分为内存和外存。\n\n内存：也称为主存，设在主机内或主机板上，用来存放机器当前运行所需要的程序和数据，以使向CPU提供信息。相对于外存，其特点是容量小、速度快。\nDRAM：动态随机存储器，周期性的刷新。\nSRAM：静态随机存储器。\n\n\n外存：也称为辅存，如磁盘、磁带和光盘等，用来存放当前不参加运行的大量信息，而在需要时调入内存。\n\n按工作的方式分类按存储器的工作方式可分为读/写存储器和只读存储器。\n\n读/写存储器：简称 RAM，它指既能读取数据也能存入数据的存储器。\n只读存储器：工作过程中仅能读取的存储器，根据数据的写入方式，这种存储器又可细分为ROM、PROM、EPROM和EEPROM等类型。\n闪速存储器（FlashMemory）：简称闪存，闪存的特性介于 EPROM 和 EEPROM 之间，类似于 EEPROM，也可使用电信号进行信息的擦除操作。它以块为单位删除，整块闪存可以在数秒内删除，速度远快于 EPROM，可以代替 ROM 但不能代替主存。\n\n\n\n按访问的方式分类按访问方式可分为按地址访问的存储器和按内容访问的存储器。相联存储器是一种按内容访问的存储器。\n按寻址的方式分类按寻址方式可分为随机存储器、顺序存储器和直接存储器。\n高速缓存 Cache高速缓存用来存放当前最活跃的程序和数据，其特点是：位于 CPU 与主存之间；容量一般在几千字节到几兆字节之间；速度一般比主存快 5～10 倍，由快速半导体存储器构成；其内容是主存局部域的副本，对程序员来说是透明的。\nCache 的设计思想是在合理成本下提高命中率。\n高速缓存（Cache）、主存（Main Memory）与 CPU 的关系如图：\n\nCache 存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断 CPU 要访问的信息是否在 Cache 存储器中，若在即为命中，若不在则没有命中。命中时直接对 Cache 存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到 Cache 存储器的哪一块里。\n替换算法替换算法的目标就是使 Cache 获得尽可能高的命中率。常用算法有如下几种。\n\n随机替换算法：就是用随机数发生器产生一个要替换的块号，将该块替换出去。\n先进先出算法：就是将最先进入 Cache 的信息块替换出去。\n近期最少使用算法：这种方法是将近期最少使用的 Cache 中的信息块替换出去。\n优化替换算法：这种方法必须先执行一次程序，统计 Cache 的替换情况。有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换。\n\nCache 容量越大，则命中率越高，随着 Cache 容量的增加，其失效率接近 0%（命中率逐渐接近 100%）。但是，增加 Cache 容量意味着增加 Cache 的成本和增加 Cache 的命中时间。\nCache 设置多级高速缓存的主要目的是提高 CPU 访问主存数据或指令的效率。\n地址映像方法Cache 与主存地址的映射是由硬件自动完成的。\n在 CPU 工作时，送出的是主存单元的地址，而应从 Cache 存储器中读/写信息。这就需要将主存地址转换成 Cache 存储器的地址，这种地址的转换称为地址映像。\n\n直接映像：直接映像是指主存的块与 Cache 块的对应关系是固定的。\n全相联映像：这种映像方式允许主存的任一块可以调入 Cache 存储器的任何一个块的空间中。\n组相联映像：这种方式是前面两种方式的折中。具体方法是将 Cache 中的块再分成组。\n\n发生块冲突多少的排序：直接映像（冲突多） &gt; 组相联映像（冲突较少） &gt; 全相联映像（冲突少）\n输入/输出中断计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序转去执行有关服务程序，处理完后自动返回源程序，这个过程称为中断。中断是一种非常重要的技术，输入输出设备和主机交换数据、分时操作、实时系统、计算机网络和分布式计算机系统中都要用到这种技术。为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。\n\n\n中断向量：是中断服务程序的入口地址，或中断向量表（它是一个中断处理程序地址的数组）的表项。\n中断响应时间：就是中断的响应过程的时间，从发出中断请求到进入中断服务程序的的时间。\n保存现场：当出现中断时，为使中断处理程序不破坏主程序中寄存器的内容，应先将断点处各寄存器的内容压入堆栈保护起来。\n恢复现场：当中断处理完毕后，用户通过 POP 指令将保存在堆栈中的各个寄存器的内容弹出，即恢复主程序断点处寄存器的原值。\n可屏蔽中断：可屏蔽中断源的请求，CPU 可以响应，也可以不响应。I/O 设备提出的中断请求是可屏蔽中断。\n不可屏蔽中断：不可屏蔽中断源一旦提出请求，CPU 必须无条件响应。电源掉电是不可屏蔽中断。\n\nI/O 控制方式程序查询方式程序查询方式是一种程序直接控制方式，这是主机与外设间进行信息交换的最简单的方式，输入和输出完全是通过 CPU 执行程序来完成的。\n\nCPU 和 I/O（外设）只能串行工作。\nCPU 需要一直轮询检查，长期处于忙等状态。\n一次只能读/写一个字。\n由 CPU 将数据放入内存。\nCPU 的利用率底。\n\n\n中断驱动方式中断驱动就是将 CPU 从繁忙等待的繁琐中解脱出来。在发送完一个或一批数据后，CPU 就去忙别的事情。I/O 设备处理完这批数据后，向 CPU 发出中断。CPU 响应中断后再发送下一批数据。\n\nCPU 和 I/O（外设）可并行工作。\nI/O 设备通过中断信号主动报告 I/O 操作已完成。\n一次只能读/写一个字。\n由 CPU 将数据放入内存。\nCPU 的利用率得到提升。\n\n\n直接存储器方式直接存储器存取（DMA）是一种高速数据传输的方法，数据可以从一个通道，不经过 CPU 的处理就直接在存储器或输入输出设备之间进行传输。\n\nCPU 和 I/O（外设）可并行工作。\n仅在传送数据块的开始和结束时才需要 CPU 的干预。\n由外设直接将数据放入内存。\n一次读写的单位是块而不是字。\n\n\n总线微机中的总线分为数据总线、地址总线和控制总线 3 类。\n\n常见总线\nISA 总线：工业标准总线。\nEISA 总线：EISA 是在 ISA 总线的基础上发展起来的 32 位总线。\nPCI 总线：PCI 总线是日前微型机上广泛采用的内总线，采用并行传输方式。\nPCI Express 总线：PCI Express 简称为 PCI-E，采用点对点串行连接，每个设备都有自已的专用连接，不需要向整个总线请求带宽，而且可以把数据传输率提高到一个很高的频率。\nSCSI 总线：小型计算机系统接口（SCSI）是一条并行外总线。\n\n\n\n加密技术与认证技术加密技术加密技术是最常用的安全保密手段，数据加密技术的关键在于加密/解密算法和密钥管理。数据加密的基本过程就是对原来为明文的文件或数据按某种加密算法进行处理，使其成为不可读的一段代码，通常称为“密文”。“密文”只能在输入相应的密钥之后才能显示出原来的内容，通过这样的途径使数据不被窃取。\n对称加密对称加密是最快速、最简单的一种加密方式，加密与解密用的是同样的密钥，加密解密速度快，适合加密大量明文数据。密钥的分发有缺陷，发送密钥的过程中，密钥有很大的风险会被黑客们拦截。对称加密只能防止窃听。\n对称加密算法：\n\nDES\n3DES\nIDEA\nAES\nRC4\nRC5\n\n非对称加密非对称加密使用了一对密钥，分别是公钥和私钥。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人（银行）才能对你的消息解密。加密解密速度慢。\n非对称加密算法：\n\nRSA\nECC\nDSA\n\n混合加密对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。\n认证技术摘要认证对一份数据进行一个单向的 Hash 函数，生成一个固定长度的 Hash 值，这个值就是这份数据的摘要，也称为指纹。\n摘要算法是单向的，只能根据原始数据计算出它的摘要值，但是不能根据摘要值反算出原始数据。\n对于同一个摘要算法，无论输入的数据是什么，输出都是相同长度的值。\n将发送的明文进行 Hash 算法后得到摘要，将摘要和密文一起发送过去，然后与接收方解密后的明文进行相同的 Hash 算法得到的摘要进行对比，如果一致，则没有篡改，否则有篡改。\n摘要一般不会单独使用，而是和数字签名一起使用。\n数字签名发送方用自己的私钥对摘要进行签名（加密），将得到的数字签名和密文一起发送过去，然后接收方用发送方的公钥对数字签名进行验证（解密），如果验证成功，则该消息没有被假冒且不能否认（防止发送方否认签名），否则该消息的真实性为假冒发送。\n数字证书数字证书是互联网通讯中标志通讯各方身份信息的一系列数据，提供了验证身份的方式。它是由一个由权威机构中心发行的，人们可以在网上用它来识别对方的身份。最简单的数字证书包含一个公开密钥、名称以及证书授权中心的数字签名。\n用户向 CA 机构申请数字证书，将个人信息和公钥发给 CA 机构，CA 机构颁发数字证书给用户。数字证书用 CA 的私钥进行签名（加密），用 CA 的公钥验证（解密）数字证书，得到用户的公钥。\n计算机可靠性串联系统\n设系统中各个子系统的可靠性分别用  来表示，则系统的可靠性  可由下式求得。\n\n并联系统\n设每个子系统的可靠性分别以  表示，整个系统的可靠性可由下式求得。\n\n计算机系统杂题选讲https://www.bilibili.com/video/BV1ym4y1D7RW?p=187\n","categories":["证书考试"],"tags":["软考","软件设计师","计算机系统"]},{"title":"软件设计师 | 计算机网络","url":"/posts/6f70781c/","content":"计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享。\n\n\n\n网络设备\n物理层的互连设备有中继器和集线器。集线器是一个多端口的中继器。\n\n数据链路层的互连设备有网桥和交换机。交换机是一个多端口的网桥。\n\n网络层的互联设备有路由器。\n\n应用层的互联设备有网关。\n\n\n协议簇\n\nTCPTCP 的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。\n\n是一个可靠的、面向连接的全双工的数据传输协议。\nTCP 是面向连接（虚连接）的传输层协议。\nTCP 的流量控制采用了可变大小的滑动窗口协议。\nTCP 提供可靠交付的服务，无差错、不丢失、不重复、按序到达。\n每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的。\n主机之间建立和关闭连接操作时，均需要通过三次握手来确认建立和关闭是否成功。\n\nUDPUDP 的全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n\n是一个不可靠的、无连接的协议。\nUDP 有助于提高传输的高速率性。\nUDP 是无连接的，减少开销和发送数据之前的时延。\nUDP 使用最大努力交付，即不保证可靠交付。\nUDP 是面向报文的，适合一次性传输少量数据的网络应用。\nUDP 无拥塞控制，适合很多实时应用。\nUDP 首部开销小。\n\nipconfig 工具\nipconfig：显示所有网络适配器的 IP 地址、子网拖码和缺省网关值。\nipconfig&#x2F;all：显示所有网络适配器的完整 TCP&#x2F;IP 配置信息，包括 DHCP 服务是否已启动。\nipconfig&#x2F;renew：DHCP 客户端手工向服务器刷新请求（重新申请 IP 地址）。\nipconfig&#x2F;release：DHCP 客户端手工释放 IP 地址。\nipconfig&#x2F;flushdns：清除本地 DNS 缓存内容。\nipconfig&#x2F;displaydns：显示本地 DNS 内容。\nipconfig&#x2F;registerdns：DNS 客户端手工向服务器进行注册。\n\n","categories":["证书考试"],"tags":["软考","软件设计师","计算机网络"]},{"title":"软件设计师 | 设计模式","url":"/posts/a31d3cb4/","content":"设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性，以及更加简单方便的复用成功的设计和体系结构。\n\n\n\n设计模式分类设计模式确定了所包含的类和实例，它们的角色、协作方式以及职责分配。每一个设计模式都集中于一个特定的面向对象设计问题或设计要点，描述了什么时候使用它，在另一些设计约束条件下是否还能使用，以及使用的效果和如何取舍。按照设计模式的目的可以分为三大类。\n创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。\n创建型这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。\n创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。\n\n类模式\n工厂方法模式（Factory Method）\n\n\n对象模式\n抽象工厂模式（Abstract Factory）\n生成器模式（Builder）\n原型模式（Prototype）\n单例模式（Singleton）\n\n\n\n结构型这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。\n\n类模式\n适配器模式（Adapter）\n\n\n对象模式\n适配器模式（Adapter）\n桥接模式（Bridge）\n组合模式（Composite）\n装饰模式（Decorator）\n外观模式（Facade）\n享元模式（Flyweight）\n代理模式（Proxy）\n\n\n\n行为型这些设计模式特别关注对象之间的通信。\n\n类模式\n解释器模式（Interpreter）\n模板方法模式（Template Method）\n\n\n对象模式\n责任链模式（Chain of Responsibility）\n命令模式（Command）\n迭代器模式（Iterator）\n中介者模式（Mediator）\n备忘录模式（Memento）\n观察者模式（Observer）\n状态模式（State）\n策略模式（Strategy）\n访问者模式（Visitor）\n\n\n\n创建型模式工厂方法模式意图：\n\n定义一个用于创建对象的接口，让子类决定实例化哪一个类。\n\n适用性：\n\n当一个类不知道它所必须创建的对象的类的时候。\n当一个类希望由它的子类来指定它所创建的对象的时候。\n当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个助子类是代理者这一信息局部化的时候。\n\n实现代码：\n/** * 简单工厂模式 */public class SimpleFactory {    public static void main(String[] args) {        Product productA = Factory.createProduct(\"A\");        productA.info();        Product productB = Factory.createProduct(\"B\");        productB.info();    }}class Factory {    public static Product createProduct(String type) {        Product product = null;        switch(type) {            case \"A\":                product = new ProductA();                break;            case \"B\":                product = new ProductB();                break;            default:                System.out.println(\"没有 \" + type + \" 类型的产品！\");        }        return product;    }}abstract class Product {    public abstract void info();}class ProductA extends Product {    @Override    public void info() {        System.out.println(\"产品的信息：A\");    }}class ProductB extends Product {    @Override    public void info() {        System.out.println(\"产品的信息：B\");    }}\n\n/** * 工厂方法模式 */public class FactoryMethod {    public static void main(String[] args) {        Factory factoryA = new FactoryA();        Product productA = factoryA.createProduct();        productA.info();        Factory factoryB = new FactoryB();        Product productB = factoryB.createProduct();        productB.info();    }}interface Factory {    Product createProduct();}class FactoryA implements Factory {    @Override    public Product createProduct() {        return new ProductA();    }}class FactoryB implements Factory {    @Override    public Product createProduct() {        return new ProductB();    }}interface Product {    void info();}class ProductA implements Product {    @Override    public void info() {        System.out.println(\"产品的信息：A\");    }}class ProductB implements Product {    @Override    public void info() {        System.out.println(\"产品的信息：B\");    }}\n\n抽象工厂模式意图：\n\n提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n适用性：\n\n一个系统要独立于它的产品的创建、组合和表示时。\n一个系统要由多个产品系列中的一个来配置时。\n当要强调一系列相关的产品对象的设计以便进行联合使用时。\n当提供一个产品类库，只想显示它们的接口而不是实现时。\n\n实现代码：\n/** * 抽象工厂模式 */public class AbstractFactory {    public static void main(String[] args) {        Factory factory1 = new Factory1();        ProductA productA1 = factory1.createProductA();        productA1.info();        ProductB productB1 = factory1.createProductB();        productB1.info();        Factory factory2 = new Factory2();        ProductA productA2 = factory2.createProductA();        productA2.info();        ProductB productB2 = factory2.createProductB();        productB2.info();    }}interface Factory {    ProductA createProductA();    ProductB createProductB();}class Factory1 implements Factory {    @Override    public ProductA createProductA() {        return new ProductA1();    }    @Override    public ProductB createProductB() {        return new ProductB1();    }}class Factory2 implements Factory {    @Override    public ProductA createProductA() {        return new ProductA2();    }    @Override    public ProductB createProductB() {        return new ProductB2();    }}interface ProductA {    void info();}interface ProductB {    void info();}class ProductA1 implements ProductA {    @Override    public void info() {        System.out.println(\"产品的信息：A1\");    }}class ProductA2 implements ProductA {    @Override    public void info() {        System.out.println(\"产品的信息：A2\");    }}class ProductB1 implements ProductB {    @Override    public void info() {        System.out.println(\"产品的信息：B1\");    }}class ProductB2 implements ProductB {    @Override    public void info() {        System.out.println(\"产品的信息：B2\");    }}\n\n生成器模式意图：\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n适用性：\n\n当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。\n当构造过程必须允许被构造的对象有不同的表示时。\n\n原型模式意图：\n\n用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。\n\n适用性：\n\n当一个系统应该独立于它的产品创建、构成和表示时。\n当要实例化的类是在运行时刻指定时，例如，通过动态装载。\n为了避免创建一个与产品类层次平行的工厂类层次时。\n当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。\n\n单例模式意图：\n\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n适用性：\n\n当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。\n当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时。\n\n单利模式有饿汉式和懒汉式两种实现方式，饿汉式在类加载时就创建对象，可能存在资源资源浪费问题。懒汉式存在线程安全问题。\n单例模式的实现步骤：\n\n构造器私有化（防止在其它类直接创建对象）。\n在类的内部创建对象。\n向外暴露一个静态的公共方法。\n\n饿汉式public class SingleTon01 {    public static void main(String[] args) {        GirlFriend gf = GirlFriend.getInstance();        System.out.println(gf);    }}class GirlFriend {    private String name;    private GirlFriend(String name) {        this.name = name;    }    private static GirlFriend gf = new GirlFriend(\"girl\");    public static GirlFriend getInstance() {        return gf;    }    @Override    public String toString() {        return \"GirlFriend{\" +                \"name='\" + name + '\\'' +                '}';    }}\n\n懒汉式public class SingleTon02 {    public static void main(String[] args) {        Cat cat = Cat.getInstance();        System.out.println(cat);    }}class Cat {    private String name;    private Cat(String name) {        this.name = name;    }    private static Cat cat;    public static Cat getInstance() {        if (cat == null) {            cat = new Cat(\"jack\");        }        return cat;    }    @Override    public String toString() {        return \"Cat{\" +                \"name='\" + name + '\\'' +                '}';    }}\n\n结构型模式适配器模式意图：\n\n将一个类的接口转换成客户希望的另外一个接口。\n适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n适用性：\n\n想使用一个已经存在的类，而它的接口不符合要求。\n想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。\n想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。\n\n装饰器模式意图：\n\n动态的给一个对象添加一些额外的职责。就增加功能而言，装饰器模式比生成子类更加灵活。\n\n适用性：\n\n在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n处理那些可以撤销的职责。\n当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是由于类定义被隐藏，或类定义不能用于生成子类。\n\n桥接模式意图：\n\n将抽象部分与其实现部分分离，使它们都可以独立的变化。\n\n适用性：\n\n不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。\n类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge 模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。\n对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。\n有许多类要生成的类层次结构。\n想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。\n\n组合模式意图：\n\n将对象组合成树形结构以表示“部分-整体”的层次机构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n适用性：\n\n想表示对象的“部分-整体”层次结构。\n希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n\n外观模式意图：\n\n为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n适用性：\n\n要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 Facade  层。\n客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。\n当需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系。\n\n享元模式意图：\n\n运用共享技术有效的支持大量细粒度的对象。\n\n适用性：\n\n一个应用程序使用了大量的对象。\n完全由于使用大量的对象，造成很大的存储开销。\n对象的大多数状态都可变为外部状态。\n如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。\n应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值。\n\n代理模式意图：\n\n为其他对象提供一种代理以控制这个对象的访问。\n\n适用性：\n\n远程代理（Remote Proxy）为一个对象在不同地址空间提供局部代表。\n虚代理（Virtual Proxy）根据需要创建开销很大的对象。\n保护代理（Protection Proxy）控制对原始对象的访问，用于对象应该有不同的访问权限的时候。\n智能引用（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。典型用途包括：对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放；当第一次引用一个持久对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。\n\n行为型模式责任链模式意图：\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n适用性：\n\n有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。\n想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。\n可处理一个请求的对象集合应被动态指定。\n\n命令模式意图：\n\n将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。\n\n适用性：\n\n抽象出待执行的动作以参数化某对象。Command 模式是过程语言中的回调（Callback）机制的一个面向对象的替代品。\n在不同的时刻指定、排列和执行请求。一个 Command 对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程并在那儿实现该请求。\n支持取消操作。Command 的 Execute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个 Unexecute 操作，该操作取消上一次 Execute 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用 Unexecute 和 Execute 来实现重数不限的“取消”和“重做”。\n支持修改日志。这样当系统崩溃时，这些修改可以被重做一遍。在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用 Execute 操作重新执行它们。\n用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。Command 模式提供了对事务进行建模的方法。Command 有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。\n\n解释器模式意图：\n\n给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n适用性：\n\n该文法简单。对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。\n效率不是一个关键问题。最高效的解释器通常不是通过直接解释语法分析树实现的而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。\n\n迭代器模式意图：\n\n提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。\n\n适用性：\n\n访问一个聚合对象的内容而无须暴露它的内部表示。\n支持对聚合对象的多种遍历。\n为遍历不同的聚合结构提供一个统一的接口。\n\n中介者模式意图：\n\n用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n适用性：\n\n组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。\n一个对象引用其他很多对象并日直接与这些对象通信，导致难以复用该对象。\n想定制一个分布在多个类中的行为，而又不想生成太多的子类。\n\n备忘录模式意图：\n\n在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。\n\n适用性：\n\n必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。\n如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。\n\n观察者模式意图：\n\n定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n适用性：\n\n当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。\n当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。\n当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。\n\n状态模式意图：\n\n允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n\n适用性：\n\n一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。\n一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State 模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。\n\n策略模式意图：\n\n是义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。\n\n适用性：\n\n许多相关的类仅仅是行为有异。“策略提供了一种用多个行为中的一个行为来配置一个类的方法。\n需要使用一个算法的不同变体。例如，定义一些反映不同空间的空间/付时间权衡的算法当这些变体实现为一个算法的类层次时，可以使用策略模式。\n算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。\n一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现将相关的条件分支移入它们各自的 Strategy 类中，以代替这些条件语句。\n\n模板方法模式意图：\n\n定义一个操作中的算法骨架，而将一些步骤延退到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n适用性：\n\n一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。\n各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。\n控制子类扩展。模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展），这就只允许在这些点进行扩展。\n\n访问者模式意图：\n\n表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n适用性：\n\n一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。\n需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作“污染”这些对象的类。Visitor 使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用 Visitor 模式让每个应用仅包含需要用到的操作。\n定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变那么可能还是在这些类中定义这些操作较好。\n\n","categories":["证书考试"],"tags":["软考","软件设计师","设计模式"]},{"title":"软件设计师 | 软件工程","url":"/posts/4357767a/","content":"软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。\n\n\n\n软件过程能力成熟度模型能力成熟度模型（CMM）将软件过程改进分为以下 5 个成熟度级别。\n\n初始级。软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人的努力和英雄式核心人物的作用。\n\n可重复级。建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。\n\n已定义级。管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。\n\n已管理级。制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制。\n\n优化级。加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。\n\n\n能力成熟度模型集成能力成熟度模型集成（CMMI）提供了两种表示方法：阶段式模型和连续式模型。\n阶段式模型阶段式模型的结构类似于 CMM，它关注组织的成熟度。\n\n初始的：过程不可预测且缺乏控制。\n\n已管理的：过程为项目服务。\n\n已定义的：过程为组织服务。\n\n定量管理的：过程已度量和控制。\n\n优化的：集中于过程改进。\n\n\n连续式模型连续式模型关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级。CMMI 中包括 6 个过程域能力等级，等级号为 0~5。\n能力等级可以独立地应用于任何单独的过程域，任何一个能力等级都必须满足比它等级低的能力等级的所有准则。对各能力等级的含义简述如下。\n\n未完成的：过程域未执行或未得到“已执行的”中定义的所有目标。\n\n已执行的：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。\n\n已管理的：其共性目标集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。\n\n已定义级的：其共性目标集中于已定义的过程的制度化。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。\n\n定量管理的：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。\n\n优化的：使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。\n\n\n软件过程模型软件过程模型习惯上也称为软件开发模型，它是软件开发全部过程、活动和任务的结构框架。典型的软件过程模型有瀑布模型、增量模型、演化模型（原型模型、螺旋模型）、喷泉模型、基于构件的开发模型和形式化方法模型等。\n瀑布模型瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、测试、运行与维护。它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落，如下图所示。\n\n优点：\n\n容易理解和管理，且管理成本低。\n过程可见，项目经理能够根据项目计划监控项目过程。\n\n缺点：\n\n客户必须能够完整、正确和清晰地表达他们的需要。\n在开始的两个或三个阶段中，很难评估真正的进度状态。\n当接近项目结束时，出现了大量的集成和测试工作。\n直到项目结束之前，都不能演示系统的能力。\n需求或设计中的错误往往只有到了项目后期才能够被发现。\n对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。\n\n适用范围：\n\n瀑布模型是以文档作为驱动，适合于软件需求很明确的软件项目的模型。\n系统开发过程中不太可能发生重大改变。\n\nV 模型V 模型是瀑布模型的一个变体，强调在各个阶段进行测试和验证，以提升软件质量。\n\n左侧大体遵照瀑布模型，在编码完成后反弹，逐阶段测试。\n优缺点：\n\nV 模型是瀑布模型的一种加强，可以提升软件质量，但也更消耗人力和时间。\n\n增量模型增量模型，先开发出一个初始的实现，给用户使用并听取用户的使用意见，通过不断修改直到产生一个充分的版本。各活动不是分离而是交织在一起的。反应了我们解决问题的方法，我们很少能提前制定出完整的问题解决方案，而是摸着石头过河，逐步逼近结果。\n增量模型融合了瀑布模型的基本成分和原型实现的送代特征，它假设可以将需求分段为一系列增量产品，每一增量可以分别开发。\n当使用增量模型时，第一个增量往往是核心的产品。客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。增量模型强调每个增量均发布一个可操作的产品。\n\n优点：\n\n增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。\n第一个可交付版本所需要的成本和时间很少。\n开发由增量表示的小系统所承担的风险不大。\n由于很快发布了第一个版本，因此可以减少用户需求的变更。\n运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。\n用户可以更早的使用软件并创造价值。\n\n缺点：\n\n过程不可见，不方便管理。\n缺乏整体规划，导致功能堆砌。\n越往后变更越困难，成本逐渐上升。\n如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定。\n如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布。\n管理发生的成本、进度和配置的复杂性可能会超出组织的能力。\n\n适用范围：\n\n软件产品可以分批次地进行交付。\n待开发的软件系统能够被模块化。\n软件开发人员对应用领域不熟悉，难以一次性地进行系统开发。\n项目管理人员把握全局的水平较高。\n需要快速构造可运行的产品。\n开发团队人力资源、时间不充足的情况。\n\n演化模型软件类似于其他复杂的系统，会随着时间的推移而演化。演化模型主要针对事先不能完整定义需求的软件开发。\n在开发过程中，常常会面临以下情形：\n\n商业和产品需求经常发生变化，直接导致最终产品难以实现。\n严格的交付时间使得开发团队不可能圆满地完成软件产品，但是必须交付功能有限的版本以应对竞争或商业压力。\n很好地理解了核心产品和系统需求，但是产品或系统扩展的细节问题却没有定义。\n\n在上述情况和类似情况下，软件开发人员需要一种专门应对不断演变的软件产品的过程模型。\n演化模型是送代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于对软件需求缺乏准确认识的情况。典型的演化模型有原型模型和螺旋模型等。\n原型模型并非所有的需求都能够预先定义，大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。这主要是由于客户往往不能准确地表达对未来系统的全面要求，开发者对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚全是有歧异的。\n在整个开发过程中，用户可能会产生新的要求，导致需求的变更。而瀑布模型难以适应这种需求的不确定性和变化，于是出现了快速原型这种新的开发方法。\n\n原型开发模型开始于沟通，开发人员和用户沟通，了解软件整体目标，明确已知需求，大致勾画出以后进一步定义的东西，然后迅速策划一个原型，进行建模，快速开发一个原型，对原型进行部署，由相关人员进行评价，根据评价进一步细化软件的需求，不断调整已满足需求。\n优点：\n\n有助于启发和验证系统需求。\n可以有效地捕获系统的需求。\n\n缺点：\n\n原型开发会忽略掉非功能性要求 ，如性能、安全性、可靠性等。\n开发过程的快速更改意味着没有文档，唯一的设计描述是原型的代码，这不利于长期的维护。\n\n适用范围：\n\n用户需求模糊、需求经常变化。\n系统规模不是很大也不太复杂时，采用该方法比较好。\n开发人员对算法效率、操作系统的兼容性，人机交互形式等情况不明确。\n\n根据使用原型的目的不同，原型可以分为探索型原型、实验型原型和演化型原型 3 种。\n\n探索型原型的目的是要弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性。\n实验型原型的目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。\n演化型原型的目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。\n\n螺旋模型对于复杂的大型软件，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。\n\n螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。每个螺旋周期分为如下 4 个工作步骤。\n\n制订计划：确定软件的目标，选定实施方案，明确项目开发的限制条件。\n风险分析：分析所选的方案，识别风险，消除风险。\n实施工程：实施软件开发，验证阶段性产品。\n用户评估：评价开发工作，提出修正建议，建立下一个周期的开发计划。\n\n螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。\n优点：\n\n实现风险管理，降低变更风险。\n确定一系列里程碑，确保利益相关者都能支持。\n与瀑布模型相比，螺旋模型支持用户需求的动态变化。\n为用户参与软件开发的所有关键决策提供了方便，有助于提高软件的适应能力。\n为项目管理人员及时调整管理决策提供了便利，从而降低了软件开发的风险。\n\n缺点：\n\n很难说服客户以合同形式合作。\n依赖大量风险评估专家及风险评估工作。\n过多的迭代次数会增加开发成本，延迟提交时间。\n需要开发人员具有相当丰富的风险评估经验和专门知识。\n\n适用范围：\n\n开发大型系统和软件。\n预期存在较大风险的项目。\n适用于庞大、复杂并且具有高风险的系统。\n\n喷泉模型喷泉模型是一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的。\n软件的某个部分常常被重复工作多次，相关对象在每次迭代中随之加入渐进的软件成分。由于对象概念的引入，表达分析、设计、实现等活动只用对象类和关系，从而可以较为容易地实现活动的迭代和无间隙（无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限）。\n\n优点：\n\n可以提高软件项目的开发效率，节省开发时间。\n喷泉模型的各个阶段没有明显的界线，开发人员可以同步进行。\n克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。\n将功能需求、功能模块间的关系、数据流等描述清楚，提升需求、设计准确性，最终提升软件质量。\n\n缺点：\n\n各个阶段有重叠，在开发过程中需要大量的开发人员，不利于项目的管理。\n这种模型要求严格管理文档，使得审核的难度加大。\n\n统一过程模型统一过程模型是一种“用例驱动，以体系结构为核心，迭代及增量”的软件过程框架，由 UML 方法和工具支持。\n统一过程定义了 4 个技术阶段及其制品。\n\n起始阶段。起始阶段专注于项目的初创活动，产生的主要工作产品有构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划（阶段及送代）、业务模型以及一个或多个原型（需要时）。\n\n精化阶段。精化阶段在理解了最初的领域范围之后进行需求分析和架构演进，产生的主要工作产品有用例模型、补充需求（包括非功能需求）、分析模型、软件体系结构描述、可执行的软件体系结构原型、初步的设计模型、修订的风险列表、项目计划（包括送代计划、调整的工作流、里程碑和技术工作产品）以及初始用户手册。\n\n构建阶段。构建阶段关注系统的构建，产生实现模型，产生的主要工作产品有设计模型、软件构件、集成的软件增量、测试计划及步骤、测试用例以及支持文档（用户手册、安装手册和对于并发增量的描述）。\n\n移交阶段。移交阶段关注于软件提交方面的工作，产生软件增量，产生的主要工作产品有提交的软件增量、测试报告和综合用户反馈。\n\n\n在每个送代中有 5 个核心工作流。\n\n捕获系统应该做什么的需求工作流。\n精化和结构化需求的分析工作流。\n在系统构架内实现需求的设计工作流\n构造软件的实现工作流。\n验证实现是否如期望那样工作的测试工作流。\n\n随着统一过程模型的阶段进展，每个核心工作流的工作量发生了变化。4 个技术阶段由主要里程硬所终止。\n\n初始阶段：生命周期目标。\n精化阶段：生命周期架构。\n构建阶段：初始运作功能。\n移交阶段：产品发布。\n\n敏捷方法敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”使客户满意。\n极限编程极限编程（XP）是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式。它由价值观、原则、实践和行为 4 个部分组成，彼此相互依赖、关联，并通过行为贯穿于整个生存周期。\n\n4 大价值观\n沟通、简单性、反馈和勇气。\n\n\n5 个原则\n快速反馈、简单性假设、逐步修改、提倡更改和优质工作。\n\n\n12 个最佳实践\n计划游戏：快速制定计划、随着细节的不断变化而完善。\n小型发布：系统的设计要能够尽可能早地交付。\n简单设计：只处理当前的需求，使设计保持简单。\n测试先行：先写测试代码，然后再编写程序。\n持续集成：可以按日甚至按小时为客户提供可运行的版本。\n隐喻：找到合适的比喻传达信息。\n重构：重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求。\n结队编程。\n集体代码所有制。\n每周工作 40 个小时。\n现场客户和编码标准。\n\n\n\n水晶法水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论，认为人对软件质量有重要的影响，因此随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。通过更好地交流和经常性的交付，软件生产力得到提高。\n并列争求法并列争求法使用迭代的方法，其中，把每 30 天一次的送代称为一个“冲刺”，并按需求的优先级别来实现产品。多个自组织和自治的小组并行地递增实现产品。协调是通过简短的日常情况会议来进行，就像橄榄球中的“并列争球”。\n自适应软件开发ASD 有 6 个基本的原则：\n\n有一个使命作为指导。\n特征被视为客户价值的关键点。\n过程中的等待是很重要的，因此“重做”与“做”同样关键。\n变化不被视为改正，而是被视为对软件开发实际情况的调整。\n确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求。\n风险也包含其中。\n\n敏捷统一过程敏捷统一过程采用“在大型上连续”以及在“在小型上送代”的原理来构建软件系统。采用经典的统一过程模型（UP）阶段性活动（初始、精化、构建和转换），提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。\n每个敏捷统一过程（AUP）迭代执行以下活动：\n\n建模：建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进。\n实现：将模型翻译成源代码。\n测试：像极限编程一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求。\n部署：对软件增量的交付以及获取最终用户的反馈。\n配置及项目管理：着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。\n环境管理：协调标准、工具以及适用于开发团队的支持技术等过程基础设施。\n\n软件需求\n功能需求：考虑系统要做什么，在何时做，在何时以及如何修改或升级。\n\n性能需求：考虑软件开发的技术性指标。例如，存储容量限制、执行速度、响应时间及吞吐量。\n\n用户或人的因素：考虑用户的类型。例如，各种用户对使用计算机的熟练程度，需要接受的训练，用户理解、使用系统的难度，用户错误操作系统的可能性等。\n\n环境需求：考虑未来软件应用的环境，包括硬件和软件。对硬件设备的需求包括机型、外设、接口、地点、分布、湿度、磁场干扰等；对软件的需求包括操作系统、网络、数据库等。\n\n界面需求：考虑来自其他系统的输入，到其他系统的输出，对数据格式的特殊规定，对数据存储介质的规定。\n\n文档需求：考虑需要哪些文档，文档针对哪些读者。\n\n数据需求：考虑输入、输出数据的格式，接收、发送数据的频率，数据的准确性和精度，数据流量，数据需保持的时间。\n\n资源使用需求：考虑软件运行时所需要的数据、其他软件、内存空间等资源；软件开发、维护所需的人力、支撑软件、开发设备等。\n\n安全保密要求：考虑是否需要对访问系统或系统信息加以控制，隔离用户数据的方法，用户程序如何与其他程序和操作系统隔离以及系统备份要求等。\n\n可靠性要求：考虑系统的可靠性要求，系统是否必须检测和隔离错误；出错后，重启系统允许的时间等。\n\n软件成本消耗与开发进度需求：考虑开发是否有规定的时间表，软/硬件投资有无限制等。\n\n其他非功能性要求：如采用某种开发模式，确定质量控制标准、里程碑和评审、验收标准、各种质量要求的优先级等，以及可维护性方面的要求。\n\n\n软件设计概要设计\n设计软件系统总体结构\n其基本任务是采用某种设计方法，将一个复杂的系统按功能划分成模块。\n确定每个模块的功能。\n确定模块之间的调用关系。\n确定模块之间的接口，即模块之间传递的信息。\n评价模块结构的质量。\n\n\n数据结构及数据库设计\n编写概要设计文档。文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划。\n评审。对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方法的可行性，关键的处理及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审。\n\n详细设计\n对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来。\n对模块内的数据结构进行设计。\n对数据库进行物理设计，即确定数据库的物理结构。\n其他设计。根据软件系统的类型，还可能要进行以下设计。\n代码设计。\n输入/输出格式设计。\n用户界面设计。\n\n\n编写详细设计说明书。\n评审。对处理过程的算法和数据库的物理结构都要评审。\n\n软件测试软件测试是为了发现错误而执行程序的过程，成功的测试是发现了全今尚未发现的错误的测试。\n测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。用户应根据开发各阶段的需求、设计等文档或程序的内部结构精心设计测试实例，并利用这些实例来运行程序，以便发现错误的过程。\n根据测试的概念和目的，在进行信息软件测试时应遵循以下基本原则。\n\n应尽早并不断地进行测试。测试不是在应用系统开发完之后才进行的。由于原始问题的复杂性、开发各阶段的多样性以及参加人员之间的协调等因素，使得在开发的各个阶段都有可能出现错误。因此，测试应贯穿在开发的各个阶段，应尽早纠正错误，消除隐患。\n\n测试工作应该避免由原开发软件的人或小组承担，一方面，开发人员往往不愿否认自已的工作，总认为自己开发的软件没有错误；另一方面，开发人员的错误很难由本人测试出来，很容易根据自己编程的思路来制定测试思路，具有局限性。测试工作应由专门人员来进行，这样会更客观、更有效。\n\n在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。将实际输出结果与预期结果相比较就能发现测试对象是否正确。\n\n在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。在测试的时候，人们往往习惯按照合理的、正常的情况进行测试，而忽略了对异常、不合理、意想不到的情况进行测试，而这可能就是隐患。\n\n在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。多余的工作会带来副作用，影响程序的效率，有时会带来潜在的危害或错误。\n\n严格按照测试计划来进行，避免测试的随意性。测试计划应包括测试内容、进度安排、人员安排、测试环境、测试工具和测试资料等。严格地按照测试计划可以保证进度，使各方面都得以协调进行。\n\n妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便。\n\n测试用例都是精心设计出来的，可以为重新测试或追加测试提供方便。当纠正错误、系统功能扩充后，都需要重新开始测试，而这些工作的重复性很高，可以利用以前的测试用例或在其基础上修改，然后进行测试。\n\n\n测试方法在软件测试过程中，应该为定义软件测试模板，即将特定的测试方法和测试用例设计放在一系列的测试步骤中。\n软件测试方法分为静态测试和动态测试。\n\n静态测试。静态测试是指被测试程序不在机器上运行，而是采用人工检测和计算机辅助静态分析的手段对程序进行检测。\n\n动态测试。动态测试是指通过运行程序发现错误。在对软件产品进行动态测试时可以采用黑盒测试法和白盒测试法。\n\n\n黑盒测试黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。\n常用的黑盒测试技术有等价类划分、边界值分析、错误推测和因果图等。\n\n等价类划分。等价类划分法将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以用少量代表性的测试用例取得较好的测试效果。等价类划分有两种不同的情况：有效等价类和无效等价类。在设计测试用例时，要同时考虑这两种等价类。\n\n边界值分析。输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。边界值划分选择等价类边界的测试用例，既注重于输入条件边界，又适用于输出域测试用例。\n\n\n白盒测试白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。\n白盒测试常用的技术是逻辑覆盖、循环覆盖和基本路径测试。\n逻辑覆盖逻辑覆盖考察用测试数据运行被测程序时对程序逻辑的覆盖程度，主要的逻辑覆盖标准有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖 6 种。\n\n语句覆盖是指选择足够的测试数据，使被测试程序中的每条语句至少执行一次。语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。\n\n判定覆盖是指设计足够的测试用例，使得被测程序中的每个判定表达式至少获得一次“真”值和“假”值，或者说是程序中的每一个取“真”分支和取“假”分支至少都通过一次，因此判定覆盖也称为分支覆盖。判定覆盖要比语句覆盖更强一些。\n\n条件覆盖是指构造一组测试用例，使得每一判定语句中每个逻辑条件的各种可能的值至少满足一次。\n\n判定/条件覆盖是指设计足够的测试用例，使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次。\n\n条件组合覆盖是指设计足够的测试用例，使得每个判定中条件的各种可能值的组合都至少出现一次。满足条件组合覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的。\n\n路径覆盖是指覆盖被测试程序中所有可能的路径。\n\n\n白盒测试的原则如下。\n\n程序模块中的所有独立路径至少执行一次。\n在所有的逻辑判断中，取“真”和取“假”的两种情况至少都能执行一次。\n每个循环都应在边界条件和一般条件下各执行一次。\n测试程序内部数据结构的有效性等。\n\n软件维护软件维护是软件生命周期中的最后一个阶段，处于系统投入生产性运行以后的时期中，因此不属于系统开发过程。\n软件维护主要是指根据需求变化或硬件环境的变化对应用程序进行部分或全部修改。\n可维护性软件系统可维护性的评价指标：\n\n可理解性\n可测试行\n可修改性\n\n软件文档\n文档是软件可维护性的决定因素。\n在开发阶段必须保证软件具有可维护的特点。\n在软件工程的每一个阶段都应考虑并提高软件的可维护性。\n\n维护内容\n正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。\n\n适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。\n\n完善性维护是为扩充功能和改善性能而进行的修改，主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。\n\n预防性维护是为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰。\n\n\n项目管理项目估算COCOMO 估算模型\n基本 COCOMO 估算是一个静态单变量模型。\n中级 COCOMO 估算是一个静态多变量模型。\n\nCOCOMOⅡ 估算模型COCOMOⅡ 被分为 3 个阶段性模型：\n\n应用组装模型，估算信息是对象点。\n早期设计阶段模型，估算信息是功能点。\n体系结构阶段模型，估算信息是代码行。\n\n进度安排Gantt 图Gantt 图（甘特图）是一种简单的水平条形图，它以日历为基准描述项目任务。水平轴表示日历时间线（如时、天、周、月和年等），每个条形表示一个任务，任务名称垂直地列在左边的列中，图中水平条的起点和终点对应水平轴上的时间，分别表示该任务的开始时间和结束时间，水平条的长度表示完成该任务所持续的时间。当日历中同一时段存在多个水平条时，表示任务之间的并发。\n\nGantt 图能清晰地描述每个任务从何时开始，到何时结束，任务的进展情况以及各个任务之间的并行性。但是它不能清晰地反映出各任务之间的依赖关系，难以确定整个项目的关键所在，也不能反映计划中有潜力的部分。\nPERT 图PERT 图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了任务之间的关系，即哪些任务完成后才能开始另外一些任务，以及如期完成整个工程的关键路径。图中的松驰时间则反映了完成某些任务是可以推迟其开始时间或延长其所需完成的时间。但是，PERT 图不能反映任务之间的并行关系。\n项目活动图下图是一个软件项目的活动图，其中顶点表示项目里程碑，连接顶点的边表示活动，边上的值表示完成活动所需要的时间，没有前驱的顶点是开始，没有后继的顶点是结束。\n\n关键路径：\n\n从开始到结束的所有路径中，时间最长的一条为关键路径。\n特点：在关键路径上，所有任务的松弛时间都为 0。\n\n\n\n松弛时间：\n\n第一种方法：最晚开始时间 - 最早开始时间。\n\n第二种方法：关键路径的总时间 - 包含该任务的任务路径花的时间。\n\n前提条件：必须不影响该任务以后的任务路径。\n\n\n\n风险管理软件风险包含两个特性：\n\n不确定性：指风险可能发生也可能不发生。\n损失：指如果风险发生，就会产生恶性后果。\n\n三种风险类型：\n\n项目风险威胁到项目计划。项目风险是指预算、进度、人员（聘用职员及组织）、资源、利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。项目复杂度、规模及结构不确定性也属于项目风险因素。\n\n技术风险威胁到要开发软件的质量及交付时间。技术风险是指设计、实现、接口、验证和维护等方面的潜在问题。\n\n商业风险威胁到要开发软件的生存能力，且常常会危害到项目或产品。\n\n\n风险预测又称风险估计，它试图从两个方面评估一个风险：\n\n风险发生的可能性或概率。\n\n如果风险发生了所产生的后果。\n\n\n风险控制的目的是辅助项目组建立处理风险的策略。一个有效的策略必须考虑以下问题：\n\n风险避免。主动地避免风险，即在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生。\n\n风险监控。项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。\n\nRMMM 计划。评估所预测的风险是否真的发生了；保证正确地实施了各风险的缓解步骤；收集能够用于今后风险分析的信息。\n\n\n风险显露度 = 风险发生的概率 * 风险发生时带来的项目成本\n软件质量质量模型\n软件度量可靠性、可用性和可维护性是软件的质量属性，软件工程中，用 0~1 之间的数来度量。\n可靠性是指一个系统对于给定的时间间隔内，在给定条件下无失效运作的概率。可以用 MTTF/(1+MTTF) 来度量，其中 MTTF 为平均无故障时间。\n可用性是在给定的时间点上，一个系统能够按照规格说明正确运作的概率。可以用 MTBF/(1+MTBF) 来度量，其中 MTBF 为平均失效间隔时间。\n可维护性是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。可以用 1/(1+MTTR) 来度量，其中 MTTR 为平均修复时间。\nMcCabe 度量法McCabe 度量法是由 托马斯·麦克凯 提出的一种基于程序控制流的复杂性度量方法。又称环路度量，循环复杂度（Cyclomatic complexity）， 也称为条件复杂度或圈复杂度，是一种软件度量。它认为程序的复杂性很大程度上取决于程序图的复杂性。单一的顺序结构最为简单，循环和选择所构成的环路越多，程序就越复杂。\n根据图论，在一个强连通的有向图  中，环的个数  由以下公式给出：\n\n其中， 是有向图  中环路数， 是图  中弧数， 是图  中结点数， 是图  中强连通分量个数。在一个程序中，从程序图的入口点总能到达图中任何一个结点，因此，程序总是连通的，但不是强连通的。为了使图成为强连通图，从图的出口点到入口点加一条用虚线表示的有向边，使图成为强连通图。这样就可以使用上式计算环路复杂性了。\n","categories":["证书考试"],"tags":["软考","软件设计师","软件工程"]},{"title":"软件设计师 | 面向对象","url":"/posts/bd700ef5/","content":"面向对象 = 对象 + 分类 + 继承 + 通过消息的通信\n\n\n\n什么是面向对象“我去给你打杯水。”我们分别从面向过程的角度和面向对象的角度来分析这句话。\n面向过程：“我”和“你”这两个主体都参与到了“去打水”这件事中。我们是围绕着“打杯水”去分析的。\n面向对象：我们先将这句话尽可能的分解出多个对象，这句话中“我”、“你”、“水”、“装水的容器”、“打水的地点”。这些都是我们通过这句话分解出来的对象，我们可以将这些对象进行分类、封装，比如这句话中的“我”和“你”其实再抽象可以抽象为“参与者”，我们在这么分析了之后，对这句话的理解就转换为以对象为主体的面向对象思维了，这个时候我们再去通过实例化对应的具体类就可以代码开发了。\n面向对象基本概念\n属性 = 状态 = 数据 = 成员变量方法 = 行为 = 操作 = 成员函数\n\n对象对象是基本的运行时的实体，它既包括数据，也包括作用于数据的操作。在对象内的操作通常称为方法。\n对象是构成世界的一个独立单位，它具有自己的静态特征和动态特征，事物的静态特征用对象的属性表示，动态特征（即事物的行为）用对象的操作表示。\n一个对象通常可由对象名、属性和方法 3 个部分组成。\n消息对象之间进行通信的一种构造叫作消息。当一个消息发送给某个对象时，包含要求接收对象去执行某些活动的信息。接收到信息的对象经过解释，然后予以响应。这种通信机制称为消息传递。发送消息的对象不需要知道接收消息的对象如何对请求予以响应。\n类类就是对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例（类的实例称为对象）。\n一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。\n类是一种用户定义的引用数据类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。\n类可以分为三种：\n\n实体类：实体类的对象表示现实世界中真实的实体。\n接口类：接口类（边界类）的对象为用户提供一种与系统合作交互的方式。\n控制类：控制类的对象用来控制活动流，充当协调者。\n\n面向对象三大特性\n子类 = 派生类 = 特殊类父类 = 基类 = 超类 = 祖先类 = 一般类重写 = 覆写 = 覆盖 = 置换\n\n封装封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。\n封装是将数据和操作封装为一个整体，由于类中私有成员都是隐藏的，只向外部提供有限的接口，所以能够保证内部的高内聚性和与外部的低耦合性。用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员，能够增强安全性和简化编程。\n封装就是把抽象出来的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行操作。\n继承通过在不同程度上运用抽象的原则（较多或较少地忽略事物之间的差异），可以得到较一般的类（父类）和较特殊的类（子类）。特殊类（子类）继承一般类（父类）的属性和操作。\n继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。\n一个父类可以有多个子类，这些子类都是父类的特例，父类描述了这些子类的公共属性和方法。一个子类可以继承它的父类中的属性和方法，这些属性和操作在子类中不必定义，子类中还可以定义自己的属性和方法。\n如果一个子类只从一个父类得到继承，叫作“单重继承”。如果从多个父类得到继承，则称为“多重继承”。\n多态多态性是指同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果。\n在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象称为多态。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。\n多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应。\n多态的不同形式：\n\n通用多态\n参数多态：应用比较广泛的多态，被称为最纯的多态。采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。\n包含多态：包含多态在许多语言中存在，最常见的例子就是子类型化，即一个类型是另一个类型的子类型。\n\n\n特定多态\n过载多态：过载多态是同一个名字（操作符﹑函数名）在不同的上下文所代表的含义不同。\n强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制多态。\n\n\n\n面向对象三个步骤你要建个网上商城，那就首先要把客观的业务需求转化为各个功能模块，用户、菜单（登录菜单、购物菜单、商品菜单、其他菜单）、商品管理员等，这个过程就是 OOA；根据上面的理论模型制定实现方案，将模型映射为具体的对象，这个就是 OOD 过程；最后按照设计代码实现的过程就是 OOP。\n面向对象分析面向对象分析（OOA）的实质就是建模，对客观存在的事物建立理论模型。\n\n认定对象\n组织对象\n描述对象间的相互作用\n确定对象的操作\n定义对象的内部信息\n\n面向对象设计面向对象设计（OOD）实际上就是把分析阶段得到的需求抽象为系统实现方案的过程。\n\n识别类及对象\n定义属性\n定义服务\n识别关系\n识别包\n\n面向对象编程面向对象编程（OOP）即把设计好的系统通过代码编程实现。\n面向对象设计原则五大设计原则单一责任原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因。即，当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。\n开放-封闭原则（OCP）：软件实体（类、模块、函数等）应该是可以扩展的（开放的），但是不可修改的（封闭的）。\n里氏替换原则（LSP）：子类型必须能够替换掉他们的基类型。即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。\n接口分离原则（ISP）：不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。即，依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。这样做的好处就在于可以最大限度地应对可能的变化。\n依赖倒置原则（DIP）：抽象不应该依赖于细节，细节应该依赖于抽象。即，高层模块不应该依赖于低层模块，二者都应该依赖于抽象。\n其他设计原则重用发布等价原则（REP）：重用的粒度就是发布的粒度。\n共同封闭原则（CCP）：包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。\n共同重用原则（CRP）：一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类。\n无环依赖原则（ADP）：在包的依赖关系图中不允许存在环，即包之间的结构必须是一个直接的五环图形。\n稳定依赖原则（SDP）：朝着稳定的方向进行依赖。\n稳定抽象原则（SAP）：包的抽象程度应该和其稳定程度一致。\n面向对象杂题选讲https://www.bilibili.com/video/BV1QU4y1o7MS?p=75\n","categories":["证书考试"],"tags":["面向对象","软考","软件设计师"]}]